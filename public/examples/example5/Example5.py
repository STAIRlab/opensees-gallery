# OpenSees -- Open System for Earthquake Engineering Simulation
# Pacific Earthquake Engineering Research Center
# http://opensees.berkeley.edu/
#
# 3 Story One-by-One Bay Frame Example 5.1
# ----------------------------------------
#  Reinforced concrete one-bay, three-story frame
#  Distributed vertical load on girder
# 
# Example Objectives
# ------------------
#  3D building with rigid diaphragms
#  Nonlinear beam-column elements
#  Gravity load analysis followed by transient analysis
#
# Written: Andreas Schellenberg (andreas.schellenberg@gmail.com)
# Date: September 2017

# import the OpenSees Python module
import opensees.openseespy as ops
import opensees.units.iks as units
import math
import sys
#
def ReinforcedRectangle(model, id, h, b, cover, coreID, coverID, steelID, numBars, barArea, nfCoreY, nfCoreZ, nfCoverY, nfCoverZ, GJ):
# Define a procedure which generates a rectangular reinforced concrete section
# with one layer of steel evenly distributed around the perimeter and a confined core.
# 
#                       y
#                       |
#                       |
#                       |    
#             ---------------------
#             |\                 /|
#             | \---------------/ |
#             | |               | |
#             | |               | |
#  z ---------| |               | |  h
#             | |               | |
#             | |               | |
#             | /---------------\ |
#             |/                 \|
#             ---------------------
#                       b
#
# Formal arguments
#    id - tag for the section that is generated by this procedure
#    h - overall height of the section (see above)
#    b - overall width of the section (see above)
#    cover - thickness of the cover patches
#    coreID - material tag for the core patch
#    coverID - material tag for the cover patches
#    steelID - material tag for the reinforcing steel
#    numBars - number of reinforcing bars on any given side of the section
#    barArea - cross-sectional area of each reinforcing bar
#    nfCoreY - number of fibers in the core patch in the y direction
#    nfCoreZ - number of fibers in the core patch in the z direction
#    nfCoverY - number of fibers in the cover patches with long sides in the y direction
#    nfCoverZ - number of fibers in the cover patches with long sides in the z direction
#
# Notes
#    The thickness of cover concrete is constant on all sides of the core.
#    The number of bars is the same on any given side of the section.
#    The reinforcing bars are all the same size.
#    The number of fibers in the short direction of the cover patches is set to 1.
# 
# Written: Andreas Schellenberg (andreas.schellenberg@gmail.com)
# Date: June 2017

    # The distance from the section z-axis to the edge of the cover concrete
    # in the positive y direction
    coverY = h/2.0

    # The distance from the section y-axis to the edge of the cover concrete
    # in the positive z direction
    coverZ = b/2.0

    # Determine the corresponding values from the respective axes to the
    # edge of the core concrete
    coreY = coverY - cover
    coreZ = coverZ - cover

    # Define the fiber section
    model.section("Fiber", id, "-GJ", GJ)

    # Define the core patch
    model.patch("quad", coreID, nfCoreZ, nfCoreY, -coreY, coreZ, -coreY, -coreZ, coreY, -coreZ, coreY, coreZ)

    # Define the four cover patches
    model.patch("quad", coverID, 1,        nfCoverY, -coverY,  coverZ, -coreY,   coreZ,   coreY,   coreZ,   coverY,  coverZ)
    model.patch("quad", coverID, 1,        nfCoverY, -coreY,  -coreZ,  -coverY, -coverZ,  coverY, -coverZ,  coreY,  -coreZ)
    model.patch("quad", coverID, nfCoverZ, 1,        -coverY,  coverZ, -coverY, -coverZ, -coreY,  -coreZ,  -coreY,   coreZ)
    model.patch("quad", coverID, nfCoverZ, 1,         coreY,   coreZ,   coreY,  -coreZ,   coverY, -coverZ,  coverY,  coverZ)

    # Define the steel along constant values of y (in the z direction)
    model.layer("straight", steelID, numBars, barArea, -coreY, coreZ, -coreY, -coreZ)
    model.layer("straight", steelID, numBars, barArea,  coreY, coreZ,  coreY, -coreZ)

    # Determine the spacing for the remaining bars in the y direction
    spacingY = (2.0*coreY)/(numBars-1)

    # Avoid double counting bars
    numBars = numBars-2

    # Define remaining steel in the y direction
    model.layer("straight", steelID, numBars, barArea, coreY-spacingY,  coreZ, (-coreY+spacingY),  coreZ)
    model.layer("straight", steelID, numBars, barArea, coreY-spacingY, -coreZ, (-coreY+spacingY), -coreZ)


# ----------------------------
# Start of model generation
# ----------------------------
def create_model():
    # create ModelBuilder (with three-dimensions and 6 DOF/node)
    model = ops.Model(ndm=3, ndf=6)

    # Define geometry
    # ---------------

    # Set parameters for model geometry
    h  = 144.0;      # Story height
    by = 240.0;      # Bay width in Y-direction
    bx = 240.0;      # Bay width in X-direction

    # Create nodes
    #       tag    X        Y        Z 
    model.node( 1, -bx/2.0,  by/2.0, 0.0)
    model.node( 2,  bx/2.0,  by/2.0, 0.0)
    model.node( 3,  bx/2.0, -by/2.0, 0.0)
    model.node( 4, -bx/2.0, -by/2.0, 0.0)

    model.node( 5, -bx/2.0,  by/2.0, h)
    model.node( 6,  bx/2.0,  by/2.0, h)
    model.node( 7,  bx/2.0, -by/2.0, h)
    model.node( 8, -bx/2.0, -by/2.0, h)

    model.node(10, -bx/2.0,  by/2.0, 2.0*h)
    model.node(11,  bx/2.0,  by/2.0, 2.0*h)
    model.node(12,  bx/2.0, -by/2.0, 2.0*h)
    model.node(13, -bx/2.0, -by/2.0, 2.0*h)

    model.node(15, -bx/2.0,  by/2.0, 3.0*h)
    model.node(16,  bx/2.0,  by/2.0, 3.0*h)
    model.node(17,  bx/2.0, -by/2.0, 3.0*h)
    model.node(18, -bx/2.0, -by/2.0, 3.0*h)

    # Retained nodes for rigid diaphragm
    #        tag   X    Y    Z 
    model.node( 9,  0.0, 0.0,     h)
    model.node(14,  0.0, 0.0, 2.0*h)
    model.node(19,  0.0, 0.0, 3.0*h)

    # Set base constraints
    #      tag DX DY DZ RX RY RZ
    model.fix(1, 1, 1, 1, 1, 1, 1)
    model.fix(2, 1, 1, 1, 1, 1, 1)
    model.fix(3, 1, 1, 1, 1, 1, 1)
    model.fix(4, 1, 1, 1, 1, 1, 1)

    # Define rigid diaphragm multi-point constraints
    #              normalDir retained constrained
    model.rigidDiaphragm(3,  9,  5,  6,  7,  8)
    model.rigidDiaphragm(3, 14, 10, 11, 12, 13)
    model.rigidDiaphragm(3, 19, 15, 16, 17, 18)

    # Constraints for rigid diaphragm retained nodes
    #      tag DX DY DZ RX RY RZ
    model.fix( 9, 0, 0, 1, 1, 1, 0)
    model.fix(14, 0, 0, 1, 1, 1, 0)
    model.fix(19, 0, 0, 1, 1, 1, 0)

    # Define materials for nonlinear columns
    # --------------------------------------
    # CONCRETE
    fc = 4.0
    Ec = 57000.0*math.sqrt(fc*1000.0)/1000.0;

    # Core concrete (confined)
    #                                 tag  f'c   epsc0  f'cu  epscu
    model.uniaxialMaterial("Concrete01", 1, -5.0, -0.005, -3.5, -0.02)

    # Cover concrete (unconfined)
    #                                 tag  f'c   epsc0  f'cu  epscu
    model.uniaxialMaterial("Concrete01", 2, -fc, -0.002, 0.0, -0.006)

    # STEEL
    fy = 60.0;       # Yield stress
    Es = 30000.0;    # Young's modulus
    # Reinforcing steel 
    #                              tag fy  E0  b
    model.uniaxialMaterial("Steel01", 3, fy, Es, 0.02)

    # Column parameters
    h  = 18.0
    GJ = 1.0E10
    colSec = 1
    beamSec = 2

    # Call the RCsection procedure to generate the column section
    #                              id  h  b cover core cover steel nBars barArea nfCoreY nfCoreZ nfCoverY nfCoverZ GJ
    ReinforcedRectangle(model, colSec, h, h, 2.5, 1,    2,    3,    3,   0.79,     8,      8,      10,      10,   GJ)

    # Define material properties for elastic beams
    # Using beam depth of 24 and width of 18
    Abeam = 18.0*24.0
    # "Cracked" second moments of area
    Ibeamzz = 0.5*1.0/12.0*18.0*pow(24.0,3)
    Ibeamyy = 0.5*1.0/12.0*24.0*pow(18.0,3)

    # Define elastic section for beams
    #                       tag     E    A      Iz       Iy     G    J
    model.section("Elastic", beamSec, Ec, Abeam, Ibeamzz, Ibeamyy, GJ, 1.0)

    # Define column elements
    # ----------------------
    PDelta = "OFF"
    #PDelta = "ON"

    # Geometric transformation for columns
    if (PDelta == "OFF"):
       model.geomTransf("Linear", 1, 1.0, 0.0, 0.0)
    else:
       model.geomTransf("PDelta", 1, 1.0, 0.0, 0.0)

    # Number of column integration points (sections)
    np = 4
    itg = 1
    model.beamIntegration("Lobatto", itg, colSec, np)

    # Create the nonlinear column elements
    eleType = sys.argv[1] #"forceBeamColumn"
    #                   tag ndI ndJ transfTag integrationTag
    model.element(eleType, 1, 1, 5, 1, itg)
    model.element(eleType, 2, 2, 6, 1, itg)
    model.element(eleType, 3, 3, 7, 1, itg)
    model.element(eleType, 4, 4, 8, 1, itg)

    model.element(eleType, 5, 5, 10, 1, itg)
    model.element(eleType, 6, 6, 11, 1, itg)
    model.element(eleType, 7, 7, 12, 1, itg)
    model.element(eleType, 8, 8, 13, 1, itg)

    model.element(eleType,  9, 10, 15, 1, itg)
    model.element(eleType, 10, 11, 16, 1, itg)
    model.element(eleType, 11, 12, 17, 1, itg)
    model.element(eleType, 12, 13, 18, 1, itg)

    # Define beam elements
    # --------------------

    # Geometric transformation for beams
    model.geomTransf("Linear", 2, 1.0, 1.0, 0.0)

    # Number of beam integration points (sections)
    np = 3
    model.beamIntegration("Lobatto", beamSec, beamSec, np)

    # Create the beam elements
    eleType = "forceBeamColumn"
    #                   tag ndI ndJ transfTag integrationTag
    model.element(eleType, 13, 5, 6, 2, beamSec)
    model.element(eleType, 14, 6, 7, 2, beamSec)
    model.element(eleType, 15, 7, 8, 2, beamSec)
    model.element(eleType, 16, 8, 5, 2, beamSec)

    model.element(eleType, 17, 10, 11, 2, beamSec)
    model.element(eleType, 18, 11, 12, 2, beamSec)
    model.element(eleType, 19, 12, 13, 2, beamSec)
    model.element(eleType, 20, 13, 10, 2, beamSec)

    model.element(eleType, 21, 15, 16, 2, beamSec)
    model.element(eleType, 22, 16, 17, 2, beamSec)
    model.element(eleType, 23, 17, 18, 2, beamSec)
    model.element(eleType, 24, 18, 15, 2, beamSec)

    # Define gravity loads
    # --------------------
    # Gravity load applied at each corner node
    # 10% of column capacity
    p = 0.1*fc*h*h

    # Mass lumped at retained nodes
    m = (4.0*p)/units.gravity

    # Rotary inertia of floor about retained node
    i = m*(bx*bx + by*by)/12.0

    # Set mass at the retained nodes
    #         tag MX MY MZ   RX   RY   RZ
    model.mass( 9, m, m, 0.0, 0.0, 0.0, i)
    model.mass(14, m, m, 0.0, 0.0, 0.0, i)
    model.mass(19, m, m, 0.0, 0.0, 0.0, i)

    # Define gravity loads
    # create a Plain load pattern with Constant scaling
    model.pattern("Plain", 1, "Constant")

    for i in [5, 6, 7, 8, 10, 11, 12, 13, 15, 16, 17, 18]:
        model.load(i, 0.0, 0.0, -p, 0.0, 0.0, 0.0, pattern=1)

    # set rayleigh damping factors
    model.rayleigh(0.0, 0.0, 0.0, 0.0018)

    # Define earthquake excitation
    # ----------------------------
    dt = 0.02
    # Set up the acceleration records for Tabas fault normal and fault parallel
    model.timeSeries("Path", 2, "-filePath", "tabasFN.txt", "-dt", dt, "-factor", units.gravity)
    model.timeSeries("Path", 3, "-filePath", "tabasFP.txt", "-dt", dt, "-factor", units.gravity)

    # Define the excitation using the Tabas ground motion records
    #                         tag dir         accel series args
    model.pattern("UniformExcitation", 2, 1, "-accel", 2)
    model.pattern("UniformExcitation", 3, 2, "-accel", 3)

    # print model

    model.print(json="model.json")

    return model

def analyze(model):
    # ----------------------------
    # Start of analysis generation
    # ----------------------------

    # create the system of equation
    model.system("UmfPack")

    # create the DOF numberer
    model.numberer("Plain")

    # create the constraint handler
    model.constraints("Transformation")

    # create the convergence test
    model.test("EnergyIncr", 1.0e-8, 20)

    # define the solution algorithm, a Newton-Raphson algorithm
    model.algorithm("Newton")

    # define the integration scheme, the Newmark with gamma=0.5 and beta=0.25
    model.integrator("Newmark", 0.5, 0.25)

    # Define the analysis
    model.analysis("Transient")

    # ----------------------------
    # Start of recorder generation
    # ----------------------------

    # Record DOF 1 and 2 displacements at nodes 9, 14, and 19
    model.recorder("Node", "-file", "Node51.out", "-time", "-node", 9, 14, 19, "-dof", 1, 2, "disp")
    #recorder("plot", "Node51.out", "Node9_14_19_Xdisp", 10, 340, 300, 300, "-columns", 1, 2, "-columns", 1, 4, "-columns", 1, 6, "-dT", 1.0)


    # --------------------
    # Perform the analysis
    # --------------------

    # record once at time 0
    model.record()

    # Analysis duration of 20 seconds
    #              numSteps dt
    return model.analyze(2000, 0.01)

if __name__ == "__main__":

    model = create_model()
    ok = analyze(model)

    if (ok != 0):
        print("analysis FAILED")

    else:
        print("analysis SUCCESSFUL")


