[{"content":"","title":"Filter","uri":"/opensees-gallery/filter/"},{"content":"To-do section(\"Fiber\", ...) No Fix defaultUnits APIs II. Python Builder The Python API\nIII. Legacy API (opensees.openseespy) OpenSeesPy class loosly wraps TclRuntime. Forwards member access to TclRuntime::eval\nopensees.openseespy module creates an instance of OpenSeesP as a private global variable.\nwhen the opensees.openseespy module is star-imported (i.e, from opensees.openseespy import *), the __all__ variable (defined in openseespy.py) variable is iterated over, and __getattr__ is called for each symbol name.\nwhen a symbol is requested from the opensees.openseespy module, (eg, doing import opensees.openseespy as ops; ops.model()) the special Python function __getattr__() (defined in openseespy.py) is called, which dynamically creates a function that wraps the OpenSeesPy::tcl_call method of the global OpenSeesPy instance.\nNOTE: the aforementioned functions are only created if the function name is contained in the special Python variable __all__, defined in openseespy.py.\n","title":"","uri":"/opensees-gallery/legacy/examples/readme/"},{"content":"| PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl SUCCESS : mdofModal.tcl SUCCESS : mdofModal.tcl SUCCESS : mdofModal.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl FAILED : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl FAILED : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl FAILED : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl FAILED : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl FAILED : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | sdofTransient.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl FAILED : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl FAILED : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | sdofTransient.tcl | PASSED | sdofTransient.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl FAILED : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl FAILED : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl FAILED : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl FAILED : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl FAILED : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl FAILED : sdofTransient.tcl | PASSED | sdofTransient.tcl FAILED : sdofTransient.tcl FAILED : sdofTransient.tcl FAILED : sdofTransient.tcl FAILED : sdofTransient.tcl FAILED : sdofTransient.tcl | PASSED | sdofTransient.tcl | PASSED | sdofTransient.tcl FAILED : sdofTransient.tcl FAILED : sdofTransient.tcl FAILED : sdofTransient.tcl | PASSED | sdofTransient.tcl FAILED : sdofTransient.tcl FAILED : sdofTransient.tcl FAILED : sdofTransient.tcl FAILED : sdofTransient.tcl | PASSED | sdofTransient.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | sdofTransient.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl | PASSED | sdofTransient.tcl | PASSED | SmallEigen.tcl | PASSED | NewmarkIntegrator.tcl SUCCESS : mdofModal.tcl\n","title":"","uri":"/opensees-gallery/validation/basic/readme/"},{"content":"| PASSED | EigenFrame.Extra.tcl eleType: elasticBeam | PASSED | EigenFrame.Extra.tcl eleType: forceBeamElasticSection | PASSED | EigenFrame.Extra.tcl eleType: dispBeamElasticSection | PASSED | EigenFrame.Extra.tcl eleType: forceBeamFiberSectionElasticMaterial | PASSED | EigenFrame.Extra.tcl eleType: dispBeamFiberSectionElasticMaterial | PASSED | EigenFrame.Extra.tcl solverType: -genBandArpack | PASSED | EigenFrame.Extra.tcl solverType: -fullGenLapack | PASSED | EigenFrame.Extra.tcl solverType: -UmfPack | PASSED | EigenFrame.Extra.tcl solverType: -SuperLU | PASSED | EigenFrame.Extra.tcl solverType: -ProfileSPD\n","title":"","uri":"/opensees-gallery/validation/frame/readme/"},{"content":" Status Notes PASSED PlanarTruss.tcl PASSED PlanarTruss.Extra.tcl PASSED PortalFrame2d.tcl PASSED EigenFrame.tcl PASSED EigenFrame.Extra.tcl eleType: elasticBeam PASSED EigenFrame.Extra.tcl eleType: forceBeamElasticSection PASSED EigenFrame.Extra.tcl eleType: dispBeamElasticSection PASSED EigenFrame.Extra.tcl eleType: forceBeamFiberSectionElasticMaterial PASSED EigenFrame.Extra.tcl eleType: dispBeamFiberSectionElasticMaterial PASSED EigenFrame.Extra.tcl solverType: -genBandArpack PASSED EigenFrame.Extra.tcl solverType: -fullGenLapack PASSED EigenFrame.Extra.tcl solverType: -UmfPack PASSED EigenFrame.Extra.tcl solverType: -SuperLU PASSED EigenFrame.Extra.tcl solverType: -ProfileSPD PASSED AISC25.tcl PASSED PinchedCylinder.tcl PASSED PlanarShearWall.tcl ","title":"","uri":"/opensees-gallery/validation/readme/"},{"content":"Arch bridge example\n","title":"Arch Bridge","uri":"/opensees-gallery/gallery/archbridge/"},{"content":"Download (ArchDynamicSnap.ipynb)\nCurved arch April 2020, Amir Hossein Namadchi This is an OpenSeesPy simulation of one of the numerical examples in A robust composite time integration scheme for snap-through problems by Yenny Chandra et. al. It’s a special problem involving dynamic snap-through with large deformations in elastic range. In their study, a new three sub-step composite time integration algorithm was presented to handle such problems. Here, I will use the Bathe scheme (TRBDF2) to perform transient analysis.\nimport numpy as np import opensees.openseespy as ops import matplotlib.pyplot as plt from time import process_time Below, the base units are defined as python variables:\n# Units mm = 1.0 # milimeters N = 1.0 # Newtons sec = 1.0 # Seconds Model Defintion # Node Coordinates Matrix (size : nn x 3) node_coords = np.array([[-152.4, 0], [-137.337, 2.91714], [-122.218, 5.53039], [-107.049, 7.8387], [-91.8371, 9.84114], [-76.5878, 11.5369], [-61.3076, 12.9252], [-46.0024, 14.0057], [-30.6787, 14.7777], [-15.3424, 15.2411], [0, 15.3955], [15.3424, 15.2411], [30.6787, 14.7777], [46.0024, 14.0057], [61.3076, 12.9252], [76.5878, 11.5369], [91.8371, 9.84114], [107.049, 7.8387], [122.218, 5.53039], [137.337, 2.91714], [152.4, 0]], dtype = np.float64)*mm # Element Connectivity Matrix (size: nel x 2) connectivity = [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [9, 10], [10, 11], [11, 12], [12, 13], [13, 14], [14, 15], [15, 16], [16, 17], [17, 18], [18, 19], [19, 20], [20, 21]] # Get Number of total Nodes nn = len(node_coords) # Get Number of total Elements nel = len(connectivity) #Boundary Conditions (size: fixed_nodes x 4) B_C = [[1,1,1,1], [nn,1,1,1]] # Modulus of Elasticity E = 206843*(N/mm**2) # Mass Density rho = (7.83e-9)*(N*(sec**2)/(mm**4)) # Cross-sectional area, 2nd Moment of Inertia A, I_1 = (12.7*0.6096*mm*mm, (1/12)*(12.7*(0.6096**3))*mm**4) model = ops.Model( ndm=2, ndf=3) # Adding nodes to the model object using list comprehensions for n in range(nn): model.node(n+1,*node_coords[n]) # Applying BC for n in range(len(B_C)): model.fix(B_C[n][0],*B_C[n][1:]) # Define Transformation model.geomTransf('Corotational', 1) # Adding Elements for e in range(nel): model.element('elasticBeamColumn', e+1, *connectivity[e], A, E, I_1,1, '-mass',rho*A,'-cMass',1) # load function (Applied @ top node) F = lambda t: (t if t\u003c=8 else 8)*N # Dynamic Analysis Parameters dt = 0.0001 time = 15 time_domain = np.arange(0,time,dt) # Loading Definition model.timeSeries('Path', 1 , dt=dt, values=np.vectorize(F)(time_domain), time=time_domain) model.pattern('Plain', 1, 1) model.load(11, *[0.0, -1.0, 0.0]) # Analysis model.constraints('Transformation') model.numberer('RCM') model.system('ProfileSPD') model.test('NormUnbalance', 0.000001, 100) model.algorithm('Newton') model.integrator('TRBDF2') model.analysis('Transient') # let's do this time_lst =[] # list to hold time stations for plotting d_list = [] # list to hold vertical displacments of the top node # start the timer tic = process_time() for i in range(len(time_domain)): model.analyze(1, dt) time_lst.append(model.getTime()) d_list.append(model.nodeDisp(11,2)) # stop the timer toc = process_time() print('Time elapsed:',toc-tic, 'sec') Output:\nTime elapsed: 44.4480693 sec Visualization plt.figure(figsize=(14,5)) ax1 = plt.axes() # standard axes plt.grid() plt.yticks(fontsize = 14) plt.xticks(fontsize = 14) plt.title('Time history of vertical displacement of the top node', {'fontstyle':'italic','size':18}); ax2 = plt.axes([0.65, 0.60, 0.2, 0.25]) ax1.plot(time_lst, d_list,'k') ax2.plot(time_lst, d_list,'k') ax2.set_xlim(left=13.5, right=14) ax2.set_ylim(bottom=-15, top=-30) ax1.set_xlabel('Time (sec)', {'fontstyle':'italic','size':14}) ax1.set_ylabel('Vertical Displacement (mm)', {'fontstyle':'italic','size':14}); Output:\n\u003cFigure size 1400x500 with 2 Axes\u003e Closure The figure deomnstrates a dynamic jump from the quasi static configuration. It then begins to oscillate around the remote equilibrium configuration. It is to be noted that conventional time integration algorithm like the Newmark method might not be able to present a stable and bounded solution like this. It is therefore necessary to employ an energy-conserving algorithms with proper numerical dissipation in order to tackle these kind of problems (like TRBDF2 and TRBDF3 in OpenSees).\nReferences Chandra, Y., Zhou, Y., Stanciulescu, I., Eason, T. and Spottswood, S., 2015. A robust composite time integration scheme for snap-through problems. Computational Mechanics, 55(5), pp.1041-1056. ","tags":["Notebook"],"title":"Arch Dynamic Snapping","uri":"/opensees-gallery/examples/archdynamicsnap/"},{"content":"Download (IncrementalAnalysis.ipynb)\nIncremental Analysis of a Shallow Arch Clarke, M.J. and Hancock, G.J. (1990) ‘A study of incremental‐iterative strategies for non‐linear analyses’, International Journal for Numerical Methods in Engineering, 29(7), pp. 1365–1391. Available at: https://doi.org/10.1002/nme.1620290702.\nBegin by importing the arch_model helper function from the file arch.py:\nfrom arch import arch_model Import some helpful third-party libraries\nimport numpy as np import matplotlib.pyplot as plt try: import scienceplots plt.style.use(\"steel\") #([\"ieee\", \"science\", \"notebook\"]) except: pass The Framework def analyze(model, mid, increment, steps, dx, *args): dof = 2 xy = [] status = 0 increment(model, mid, dof, dx, *args) for step in range(steps): if status != 0: dx /= 2 increment(model, mid, dof, dx, *args) status = model.analyze(1) xy.append([model.nodeDisp(mid, dof), model.getTime()]) return np.array(xy).T The strategies used by Clarke and Hancock are:\nSolution 1 Iterative strategy: Constant load (Section 3.1) Load incrementation strategy: Direct incrementation of the load parameter (Section 4.1.1) Solution 2 Iterative strategy: Constant vertical displacement under the load, $v_6$ (Section 3.2) Load incrementation strategy: Incrementation of the displacement component $v_6$ (Section 4.1.2) Solution 3 Iterative strategy: Constant arc-length (Section 3.3) Load incrementation strategy: Incrementation of the arc-length (Section 4.1.3) Solution 4 Iterative strategy: Minimum unbalanced displacement norm (Section 3.5) Load incrementation strategy: Incrementation of the arc-length (Section 4.1.3) Solution 5 Iterative strategy: Constant weighted response (Section 3.7, equation (39)) Load incrementation strategy: Incrementation of the arc-length (Section 4.1.3) Solution 6 Iterative strategy: Minimum unbalanced force norm (Section 3.6) Load incrementation strategy: Using the current stiffness parameter (Section 4.2, equation (57)) Solution 7 Iterative strategy: Minimum unbalanced force norm (Section 3.6) Load incrementation strategy: Incrementation of the arc-length (Section 4.1.3) Solution 8 Iterative strategy: Constant arc-length (Section 3.3) Load incrementation strategy: Using the current stiffness parameter (Section 4.2, equation (57)) def solution0(model, mid, dof, dx): model.integrator(\"LoadControl\", 400.0) def solution1(model, mid, dof, dx): Jd = 5 model.integrator(\"LoadControl\", dx, Jd, -800., 800.) def solution2(model, mid, dof, dx): Jd = 5 model.integrator(\"DisplacementControl\", mid, dof, dx, Jd) def norm_control(model, mid, dof, dx): Jd = 15 model.integrator(\"MinUnbalDispNorm\", dx, Jd, -10, 10, \"-det\") def arc_control(model, mid, dof, dx, a): model.integrator(\"ArcLength\", dx, a, det=True, exp=0.5, reference=\"point\") fig, ax = plt.subplots() # x, y = solution0(*arch_model(), 6, 400.0) # ax.plot(-x, y, 'x', label=\"S0\") # x, y = analyze(*arch_model(), solution1, 6, 400.0) # ax.plot(-x, y, 'x', label=\"S1\") # print(y) x, y = analyze(*arch_model(), solution2, 7, -150) ax.plot(-x, y, 'o', label=\"S2\") x, y = analyze(*arch_model(), solution2, 536, -1.5) ax.plot(-x, y, '-', label=\"S2\") # x, y = analyze(*arch_model(), arc_control, 9500, 0.5, 0) # ax.plot(-x, y, \"-\", label=\"arc\") # Requires -det x, y = analyze(*arch_model(), arc_control, 110, 45, 0) ax.plot(-x, y, \"x\", label=\"arc\") x, y = analyze(*arch_model(), arc_control, 80, 88, 0) ax.plot(-x, y, \"+\", label=\"arc\") x, y = analyze(*arch_model(), arc_control, 80, 188, 0) ax.plot(-x, y, \"*\", label=\"arc\") # x, y = analyze(*arch_model(), arc_control, 8000, 0.8, 0) # ax.plot(-x, y, \"x\", label=\"arc\") # x, y = analyze(*arch_model(), norm_control, 7000, 1.0) # ax.plot(-x, y, \"-\", label=\"norm\") ax.set_xlim([0, 1200]) ax.set_ylim([-800, 3000]) fig.legend() Output:\n\u001b[0;31m FAILURE\u001b[0m :: Iter: 25, Norm: 49845.5, Norm deltaX: 152.498 \u001b[0;31m FAILURE\u001b[0m :: Iter: 25, Norm: 11340.8, Norm deltaX: 123.419 ArcLength::update() - imaginary roots due to multiple instability directions - initial load increment was too large a: 6.20586 b: -2674.5 c: 319258 b24ac: -772128 \u001b[0;31m FAILURE\u001b[0m :: Iter: 25, Norm: 3293.9, Norm deltaX: 54.5382 \u003cmatplotlib.legend.Legend at 0x7f1ddb0b8d00\u003e \u003cFigure size 2560x1920 with 1 Axes\u003e plt.plot(-x, '.') Output:\n[\u003cmatplotlib.lines.Line2D at 0x7f1dd8e8ec40\u003e] \u003cFigure size 2560x1920 with 1 Axes\u003e ax.plot(-x, \".\") Output:\n[\u003cmatplotlib.lines.Line2D at 0x7f1dd8cc8340\u003e] The following animation of the solution is created in Animating.ipynb\n","description":"Several nonlinear static analysis methods are used to investigate\ninstabilities in a shallow arch.\n","tags":["Python","Static","Notebook"],"title":"Arch Instability","uri":"/opensees-gallery/examples/archstaticsnap/"},{"content":"Few things related to the BART Shattuck curved bridge OpenSees file (see attached zip file):\nAdded the ground motions and the dynamic analysis, along with a loop for running multiple ground motions with the same tcl file, where each ground motion starts from the initial undamaged state.\nConsidering that there may have been changes on the files from the last time Selim worked on it, the newly added lines are listed in a file called Readme_New. The additions are generic, so they may be copied and pasted to another file. In case you cannot open it, information is repeated here:\n======== Rows 9-63 for running multiple ground motions with the same tcl file. Each ground motion starts from the initial undamaged state. Rows 296-361 for defining the ground motion and running the dynamic analysis There are some numerical issues with the dynamic analysis from the very beginning. We need to figure those out.\n","title":"BART Shattuck Bridge","uri":"/opensees-gallery/gallery/shattuck_curved_fibersection_gm_loop/readme/"},{"content":"Download (Bathe Model Problem.ipynb)\nBathe Model Problem March 2020, By Amir Hossein Namadchi This is an OpenSeesPy simulation of a simple linear 3 DOF system introduced by Bathe and Noh. The model was used to demonstrate the ability of Bathe method in filtering out the unwanted artificial high-frequency responses. The effectiveness of numerical dissipation in a specific time integration algorithm could be evaluated by analyzing this benchmark model problem [1].\nimport numpy as np import opensees.openseespy as ops import matplotlib.pyplot as plt No units were defined in the original paper. So, I just assume the base units as follows:\n## Units m = 1 # Meters KN = 1 # KiloNewtons s = 1 # Seconds kg = KN*(s**2)/m # mass unit (derived) Model specifications are defined as follows:\n# Nodal mass values m_1, m_2, m_3 = 0*kg, 1*kg, 1*kg # Modulus of Elasticity E_1, E_2 = (10.0**7)*(KN/m**2) , 1.0*(KN/m**2) # Prescribed displacment @ node 1 d_p = lambda t: np.sin(1.2*t)*m # Dynamic Analysis Parameters dt = 0.2618 time = 10 Here’s the exact solution for comparison. It can be obtained using modal decomposition technique, considering only the lowest frequency plus the static correction [1].\nd_2_ex = lambda t : (2.7273e-7)*np.sin(t) + np.sin(1.2*t) d_3_ex = lambda t : (2.7273)*np.sin(t) - (2.2727)*np.sin(1.2*t) v_2_ex = lambda t : (2.7273e-7)*np.cos(t) + 1.2*np.cos(1.2*t) v_3_ex = lambda t : (2.7273)*np.cos(t) - 1.2*(2.2727)*np.cos(1.2*t) a_2_ex = lambda t : -(2.7273e-7)*np.sin(t) - 1.2*1.2*np.sin(1.2*t) a_3_ex = lambda t : -(2.7273)*np.sin(t) + 1.2*1.2*(2.2727)*np.sin(1.2*t) Model Construction Use ZeroLength elements to model the spings, then add nodal masses via mass command. Also,I wrapped the whole modeling steps in build_model() function to use it later.\ndef build_model(): model = ops.Model(ndm=1, ndf=1) # Adding nodes [model.node(n+1, 0.0) for n in range(3)] # Defining Material (spring stiffness) model.uniaxialMaterial('Elastic', 1, E_1) model.uniaxialMaterial('Elastic', 2, E_2) # Adding springs model.element('zeroLength', 1, *[1,2], '-mat', 1, '-dir', 1) model.element('zeroLength', 2, *[2,3], '-mat', 2, '-dir', 1) # Adding Nodal masses [model.mass(n+1, mass) for n, mass in enumerate([m_1,m_2,m_3])]; print('Model built successfully!') return model Dynamic Analysis To use different time integration algorithms, the function do_dynamic_analysis is defined herein. Just pass the time, dt and integrator_params and run it multiple times with different integrators. Here, Newmark with $\\gamma=0.5$ and $\\beta=0.25$ (a non-dissipative algorithm) and the Bathe method, named as ‘TRBDF2’ (with asymptotic annihilation property) are used.\ndef do_dynamic_analysis(time, dt, integrator_params): model = build_model() time_domain = np.arange(0,time,dt) # Constraints model.timeSeries('Path', 1, dt=dt, values=np.vectorize(d_p)(time_domain), time=time_domain) model.pattern('Plain', 1, 1) model.sp(1, 1, 1) # Analysis model.constraints('Transformation') model.numberer('Plain') model.system('ProfileSPD') model.algorithm('Linear') model.integrator(*integrator_params) model.analysis('Transient') time_lst =[0] # list to hold time stations for plotting res_node_2 = [[0,0,0]] # response params of node 2 res_node_3 = [[0,0,0]] # response params of node 3 for i in range(len(time_domain)): model.analyze(1, dt) time_lst.append(model.getTime()) res_node_2.append([model.nodeDisp(2,1), model.nodeVel(2,1), model.nodeAccel(2,1)]) res_node_3.append([model.nodeDisp(3,1), model.nodeVel(3,1), model.nodeAccel(3,1)]) print('Done with ', integrator_params[0],'!') return {'time_list':np.array(time_lst), 'Node 2': np.array(res_node_2), 'Node 3': np.array(res_node_3)} Let’s perform analysis:\nnewmark = do_dynamic_analysis(time, dt,['Newmark',0.5,0.25]) bathe = do_dynamic_analysis(time, dt,['TRBDF2']) Output:\nModel built successfully! Done with Newmark ! Model built successfully! Done with TRBDF2 ! Visualization plt.figure(figsize=(12,4)) plt.plot(np.arange(0, time, 0.2*dt), np.vectorize(v_2_ex)(np.arange(0,time,0.2*dt)), color = '#7D3C98', linewidth = 2, label = 'Exact') plt.plot(newmark['time_list'], newmark['Node 2'][:,1], color = '#d62d20', linewidth=1.5, ls='--', label = 'Newmark (CAAM)' ) plt.plot(bathe['time_list'], bathe['Node 2'][:,1], color = '#008000', linewidth=1.75, label = 'Bathe (TRBDF2)', marker = 'o',ls=':') plt.ylabel('Velocity of Node 2 (m/s)', {'fontstyle':'italic','size':14}) plt.xlabel('Time (sec)', {'fontstyle':'italic','size':14}) plt.xlim([0.0, time]) plt.ylim([-3, 3]) plt.grid() plt.legend() plt.yticks(fontsize = 14) plt.xticks(fontsize = 14); Output:\n\u003cFigure size 1200x400 with 1 Axes\u003e plt.figure(figsize=(12,4)) plt.plot(np.arange(0, time, 0.2*dt), np.vectorize(a_2_ex)(np.arange(0,time,0.2*dt)), color = '#7D3C98', linewidth = 2, label = 'Exact') plt.plot(newmark['time_list'], newmark['Node 2'][:,2], color = '#d62d20', linewidth=1.5, ls='--', label = 'Newmark (CAAM)' ) plt.plot(bathe['time_list'], bathe['Node 2'][:,2], color = '#008000', linewidth=1.75, label = 'Bathe (TRBDF2)', marker = 'o',ls=':') plt.ylabel('Acceleration of Node 2 m/s^2', {'fontstyle':'italic','size':14}) plt.xlabel('Time (sec)', {'fontstyle':'italic','size':14}) plt.xlim([0.0, time]) #plt.ylim([-30, 30]) plt.grid() plt.legend() plt.yticks(fontsize = 14) plt.xticks(fontsize = 14); Output:\n\u003cFigure size 1200x400 with 1 Axes\u003e Closure As expected, non-dissipative methods like CAAM are unable to represent the exact response due to spurious high frequency oscillations. On the other hand, TRBDF2 scheme can effectively damp out these oscillations via algorithmic damping.\nReferences Bathe, K.J. and Noh, G., 2012. Insight into an implicit time integration scheme for structural dynamics. Computers \u0026 Structures, 98, pp.1-6. Namadchi, A.H., Jandaghi, E. and Alamatian, J., 2020. A new model-dependent time integration scheme with effective numerical damping for dynamic analysis. Engineering with Computers, pp.1-16. ","title":"Bathe's Springs","uri":"/opensees-gallery/examples/bathesprings/"},{"content":" source\nThe example files (PR.tcl, procMKPC2.tcl, procUniaxialPinching.tcl, procRC2.tcl) create a model of a RC beam column sub-assemblage. The cruciform is subjected to constant gravity load at nodes 4 and 7 and pseudo-static cyclic lateral load under displacement control at node 10. The beam-column-joint region (element number 7) is represented using a BeamColumnJoint element, and the beams and columns (element numbers 1 through 6) are modeled using the nonlinearBeamColumn element. The beam-column joint consists of 13 components that may have different material constitutive models; in this example 9 of the 13 components utilize the nonlinear material model - Pinching4.\nBeamColumnJointExample.jpg The displacement history for node 10 is as shown below.\nBeamColumnJointExample2.jpg The p-delta response of cruciform, along with the response of each of the nonlinear joint components is shown below.\nBeamColumnJointExample3.jpg The shear panel response shows the moment-curvature relationships whereas the bar slips at the beam top and bottom are represented by the force-slip plots\nBeamColumnJointExample4.jpg ","tags":["Joint"],"title":"Beam Column Joint","uri":"/opensees-gallery/community/beamcolumnjointexample/"},{"content":"\n","tags":["Python"],"title":"Building Modes","uri":"/opensees-gallery/examples/buildingmodes/"},{"content":"Incremental Dynamic Analysis (IDA) is carried out to identify maximum story drifts for 20 earthquake records and generate fragility curves,\nEarthquake Records: Earthquake Records\nModel Files: Model Files\nIncremental Dynamic Analysis: IDA\nMaximum Drifts Identification: Max Drift\nFragility Calculation: Fragility Calc\nFig. IDA curve for Tabas Earthquake (PGMD No. 143) References Hossain, M. R., Ashraf, M., \u0026 Padgett, J. E. (2013). \"Risk-based seismic performance assessment of Yielding Shear Panel Device.\" Engineering Structures, 56, 1570-1579.\nDEVELOPED BY:\nRaquib Hossain, The University of Queensland (UQ), Australia \u0026 Bangladesh University of Engineering and Technology (BUET), Bangladesh.\n","title":"BWBN Example","uri":"/opensees-gallery/community/bwbnexample/"},{"content":"Cable force optimization of a curved cable stayed bridge Cable force optimization of a curved cable-stayed bridge with combined simulated annealing\nGuo J, Yuan W, Dang X, et al. Cable force optimization of a curved cable-stayed bridge with combined simulated annealing method and cubic B-Spline interpolation curves[J]. Engineering Structures, 2019, 201: 109813.downLoadPDF SimulatedAnnealing.py CurvedCableStayedBridge.tcl SimulatedAnnealing.py CurvedCableStayedBridge.tcl ","title":"Cable force optimization of a curved cable stayed bridge","uri":"/opensees-gallery/gallery/cablestayedcurved/"},{"content":"Author: Junjun Guo([HomePage](https://github.com/Junjun1guo)) E-mail: guojj@tongji.edu.cn/guojj_ce@163.com Tutorials Download the zip file Run the example model (AnExampleBridgeOpenSeesPyModel.py) and generate the result database (resultsDB_1_1.db) Run the main.py to open the OpenSeesPyView window. Click loadResultDB button, and load the result database (resultsDB_1_1.db) Then display the model and conduct post process. Prepare your own openseespy model by referring the file AnExampleBridgeOpenSeesPyModel.py records==0.5.3, sQLAlchemy==1.3.20 ","tags":["Python"],"title":"Cable-Stayed Bridge","uri":"/opensees-gallery/gallery/cablestayed01/"},{"content":"This model is sourced from the opstool repository.\n","tags":["Python"],"title":"CableStayed02","uri":"/opensees-gallery/gallery/cablestayed02/"},{"content":"","title":"Categories","uri":"/opensees-gallery/_categories/"},{"content":"Eigen analysis of a two-storey shear frame This example demonstrates how to perform eigenvalue analysis and plot mode shapes. Idealized two-storey shear frame (Example 10.4 from “Dynamic of Structures” book by Professor Anil K. Chopra) is used for this purpose. In this idealization beams are rigid in flexure, axial deformation of beams and columns are neglected, and the effect of axial force on the stiffness of the columns is neglected. Geometry and material characteristics of the frame structure are shown in Figure 1. Node and element numbering is given in Figure 2.\nShearFrame5.png Instructions on how to run this example To execute this ananlysis in OpenSees the user has to download this files:\nEigenAnal_twoStoreyShearFrame.tcl Place EigenAnal_twoStoreyShearFrame.tcl in the same folder with the OpenSees.exe. By double clicking on OpenSees.exe the OpenSees interpreter will pop out. To run the analysis the user should type:\nPython Tcl python EigenAnal_twoStoreyShearFrame8.py python -m opensees EigenAnal_twoStoreyShearFrame8.tcl and hit enter. To create output files (stored in directory “data”) the user has to exit OpenSees interpreter by typing “exit”.\nCreate the model Spatial dimension of the model and number of degrees-of-freedom (DOF) at nodes are defined using model command. In this example we have 2D model with 3 DOFs at each node. This is defined in the following way:\nPython Tcl import opensees.openseespy as ops model = ops.Model(ndm=2, ndf=3) model BasicBuilder -ndm 2 -ndf 3 Note: geometry, mass, and material characteristics are assigned to variables that correspond to the ones shown in Figure 1 (e.g., the height of the column is set to be 144 in. and assigned to variable h; the value of the height can be accessed by $h).\nNodes of the structure (Figure 2) are defined using the node command:\nPython Tcl model.node(1, 0., 0.) model.node(2, L , 0.) model.node(3, 0., h ) model.node(4, L , h ) model.node(5, 0., 2*h ) model.node(6, L , 2*h ) node 1 0. 0. ; node 2 $L 0. ; node 3 0. $h ; node 4 $L $h ; node 5 0. [expr 2*$h]; node 6 $L [expr 2*$h]; The boundary conditions are defined next using single-point constraint command fix. In this example nodes 1 and 2 are fully fixed at all three DOFs:\nPython Tcl model.fix(1, 1, 1, 1) model.fix(2, 1, 1, 1) fix 1 1 1 1; fix 2 1 1 1; Masses are assigned at nodes 3, 4, 5, and 6 using mass command. Since the considered shear frame system has only two degrees of freedom (displacements in x at the 1st and the 2nd storey), the masses have to be assigned in x direction only.\nPython Tcl model.mass(3, m , 0., 0. ) model.mass(4, m , 0., 0. ) model.mass(5, m/2., 0., 0. ) model.mass(6, m/2., 0., 0. ) mass 3 $m 0. 0. ; mass 4 $m 0. 0. ; mass 5 [expr $m/2.] 0. 0. ; mass 6 [expr $m/2.] 0. 0. ; The geometric transformation with id tag 1 is defined to be linear.\nset TransfTag 1; geomTransf Linear $TransfTag ; The beams and columns of the frame are defined to be elastic using elasticBeamColumn element. In order to make beams infinitely rigid moment of inertia for beams (Ib) is set to very high value (10e+12).\nPython Tcl model.element(\"ElasticBeamColumn\", 1, 1, 3, Ac, Ec, 2.*Ic, TransfTag) model.element(\"ElasticBeamColumn\", 2, 3, 5, Ac, Ec, Ic, TransfTag) model.element(\"ElasticBeamColumn\", 3, 2, 4, Ac, Ec, 2.*Ic, TransfTag) model.element(\"ElasticBeamColumn\", 4, 4, 6, Ac, Ec, Ic, TransfTag) model.element(\"ElasticBeamColumn\", 5, 3, 4, Ab, E, Ib, TransfTag) model.element(\"ElasticBeamColumn\", 6, 5, 6, Ab, E, Ib, TransfTag) element elasticBeamColumn 1 1 3 $Ac $Ec [expr 2.*$Ic] $TransfTag; element elasticBeamColumn 2 3 5 $Ac $Ec $Ic $TransfTag; element elasticBeamColumn 3 2 4 $Ac $Ec [expr 2.*$Ic] $TransfTag; element elasticBeamColumn 4 4 6 $Ac $Ec $Ic $TransfTag; element elasticBeamColumn 5 3 4 $Ab $E $Ib $TransfTag; element elasticBeamColumn 6 5 6 $Ab $E $Ib $TransfTag; To comply with the assumptions of the shear frame (no vertical displacemnts and rotations at nodes) end nodes of the beams are constrained to each other in the 2nd DOF (vertical displacement) and the 3rd DOF (rotation). EqualDOF command is used to imply these constraints.\nequalDOF 3 4 2 3; equalDOF 5 6 2 3; Define recorders For the specified number of eigenvalues (numModes) (for this example it is 2) the eigenvectors are recorded at all nodes in all DOFs using node recorder command.\nPython Tcl for k in range(numModes): model.recorder(\"Node\", f\"eigen {k}\", file=f\"modes/mode{k}.out\", nodeRange=[1, 6], dof=[1, 2, 3]) foreach k [range $numModes] { recorder Node -file [format \"modes/mode%i.out\" $k] -nodeRange 1 6 -dof 1 2 3 \"eigen $k\" } Perform eigenvalue analysis and store periods into a file The eigenvalues are calculated using eigen commnad and stored in lambda variable.\nset lambda [eigen $numModes]; The periods and frequencies of the structure are calculated next.\nset omega {} set f {} set T {} set pi 3.141593 foreach lam $lambda { lappend omega [expr sqrt($lam)]; lappend f [expr sqrt($lam)/(2*$pi)]; lappend T [expr (2*$pi)/sqrt($lam)]; } The periods are stored in a Periods.txt file inside of directory modes/.\nset period \"modes/Periods.txt\" set Periods [open $period \"w\"] foreach t $T { puts $Periods \" $t\" } close $Periods Record the eigenvectors For eigenvectors to be recorded record command has to be issued following the eigen command.\nrecord Display mode shapes TODO\nExample Provided by: Vesna Terzic, UC Berkeley\n","tags":["Eigen","Frame","Python"],"title":"Chopra 10.4: Eigen Analysis","uri":"/opensees-gallery/examples/chopra-10.4/"},{"content":"Cold-Formed Steel Steel Sheathed Shear Wall Panel examples In order to check the accuracy of the proposed models, results from quasi-static non-linear analyses of Steel-Sheathed Cold-Formed Steel Shear Wall Panel have been carried out using CFSSSWP uniaxialMaterial model implemented into OpenSees version 2.4.6. For this purpose, specimens 1C-b and 3C-a tested by Balh (2010) were selected from the literature and analyzed under similar loading conditions. This set of specimens covers a wide range of variation in physical and mechanical characteristics such as: spacing, number, shear strength, diameter of screw fasteners (sc, nc, Vs, and ds); wall aspect ratio (H/W); frame thickness, chord stud moment of inertia, chord stud cross section area, interior stud moment of inertia, yield and tensile strengths of steel frame (tf, Af, Ife, Ifi, fyf, and fuf); sheathing thickness, yield and tensile strengths of sheathing (type, ts, Fys, and Fus); as well as the anchor bolt diameter of the HoldDown system (dt).\nEach SWP was subjected to the Consortium of Universities for Research in Earthquake Engineering (CUREE) loading protocol.\nTCL FILES:\n1Cbn.tcl\n3Can.tcl\nprocRCycDAns.tcl\nuniaxialMaterial CFSSSWP 1 2440 1220 346 396 1.14 436.22 395 300 0.46 1 4.166 1560 150 22.2 0 0\nFig 1. Comparison between steel sheathed CFS SWP experimental and numerical results specimens No 1C-b uniaxialMaterial CFSSSWP 2 2440 1220 391 342 0.87 436.22 395 300 0.46 1 4.166 1560 150 22.2 0 0\nFig 2. Comparison between steel sheathed CFS SWP experimental and numerical results specimens No 3C-a References Smail Kechidi and Nouredine Bourahla, Deteriorating hysteresis model for cold-formed steel shear wall panel based on its physical and mechanical characteristics, Journal of Thin-Walled Structures (2016), pp.421-430. DOI:10.1016/j.tws.2015.09.022.\nSmail Kechidi, Hysteresis model development for cold-formed steel shear wall panel based on physical and mechanical characteristics, Master Thesis, University of Blida 1, Algeria, 2014.\nSmail Kechidi and N Bourahla, Deteriorating hysteresis model for cold-formed steel shear wall panel based on physical and mechanical characteristics, OpenSees Days Portugal 2014- OPD 2014, 3-4 July 2014, Porto, Portugal.\nL.N. Lowes, A. Altoontash, Modelling reinforced-concrete beam-column joints subjected to cyclic loading, Journal of Structural Engineering, 129(12):1686-1697, 2003.\nYanagi N, Yu C. Effective strip method for the design of cold-formed steel framed shear wall with steel sheet sheathing. Journal of Structural Engineering, ASCE 2014; 140(4).\nNisreen Balh, Development of seismic design provisions for steel sheathed shear walls, Master Thesis, McGill University, Canada, 2010.\nCode Developed by: Smail Kechidi and Nouredine Bourahla, University of Blida 1, Algeria Images Developed by: Smail Kechidi, University of Blida 1, Algeria Authors contact:\nSmail Kechidi, PhD student at University of Blida 1, Algeria, s_kechidi@univ-blida.dz, skechidi@yahoo.com\nNouredine Bourahla, Professor at University of Blida 1, Algeria, nbourahla@univ-blida.dz\n","title":"Cold-Formed Steel Steel Sheathed Shear Wall Panel examples","uri":"/opensees-gallery/community/cfssswp/"},{"content":"Cold-Formed Steel Wood Sheathed Shear Wall Panel examples In order to check the accuracy of the proposed models, results from quasi-static non-linear analyses of Wood-sheathed Cold-Formed Steel Shear Wall Panel have been carried out using CFSWSWP uniaxialMaterial model implemented into OpenSees version 2.4.6. For this purpose, specimen No 26, No 32 and No 16 tested by Branston et al. (2006) were selected from the literature and analyzed under similar loading conditions. This set of specimens covers a wide range of variation in physical and mechanical characteristics such as: spacing, number, shear strength, diameter of screw fasteners (sc, nc, Vs, and ds); wall aspect ratio (H/W); frame thickness, chord stud moment of inertia, chord stud cross section area, interior stud moment of inertia, yield and tensile strengths of steel frame (tf, Af, Ife, Ifi, fyf, and fuf); type of sheathing wood (DFP: Douglas Fir Plywood, OSB: Oriented strand Board and CSP: Canadian Soft Plywood), sheathing thickness, as well as the yield and tensile strengths of sheathing (type, ts, Fys, and Fus).\nEach SWP was subjected to the Consortium of Universities for Research in Earthquake Engineering (CUREE) loading protocol.\nTCL FILES:\n26n.tcl\n32n.tcl\n16n.tcl\nprocRCycDAns.tcl\nuniaxialMaterial CFSWSWP 26 2440 2440 344 1.12 181600 51240 12.5 1 4.064 3256 102 98 3 0 0 Fig 1. Comparison between wood-sheathed CFS SWP experimental and numerical results specimens No 26 uniaxialMaterial CFSWSWP 32 2440 2440 344 1.12 181600 51240 12.5 1 4.064 3256 102 98 3 0 0 Fig 2. Comparison between wood-sheathed CFS SWP experimental and numerical results specimens No 32 uniaxialMaterial CFSWSWP 16 2440 610 344 1.12 181600 51240 12.5 1 4.064 3256 152 40 3 0 0 Fig 3. Comparison between wood-sheathed CFS SWP experimental and numerical results specimens No 16 References Smail Kechidi and Nouredine Bourahla, Deteriorating hysteresis model for cold-formed steel shear wall panel based on its physical and mechanical characteristics, Journal of Thin-Walled Structures (2016), pp.421-430. DOI:10.1016/j.tws.2015.09.022.\nSmail Kechidi, Hysteresis model development for cold-formed steel shear wall panel based on physical and mechanical characteristics, Master Thesis, University of Blida 1, Algeria, 2014.\nSmail Kechidi, Nouredine Bourahla, Deteriorating hysteresis model for cold-formed steel shear wall panel based on physical and mechanical characteristics, OpenSees Days Portugal 2014- Workshop on Multi-Hazard Analysis of Structures using OpenSees, Porto 3-4, Portugal, July 2014.\nL.N. Lowes, A. Altoontash, Modelling reinforced-concrete beam-column joints subjected to cyclic loading, Journal of Structural Engineering, 129(12):1686-1697, 2003.\nA.E. Branston, Y.C. Chen, F.A. Boudreault and C.A. Rogers, Testing of light-gauge steel frame wood structural panel shear walls, Canadian Journal of Civil Engineering, 33(9):561-572, 2006.\nJ. Martinez and L. Xu, Strength and stiffness determination of shear wall panels in cold-formed steel framing, Thin-Walled Structures, 44(10):1084-1095, 2006.\nCode Developed by: Smail Kechidi and Nouredine Bourahla, University of Blida 1, Algeria Images Developed by: Smail Kechidi, University of Blida 1, Algeria Authors contact:\nSmail Kechidi, PhD student at University of Blida 1, Algeria, s_kechidi@univ-blida.dz, skechidi@yahoo.com\nNouredine Bourahla, Professor at University of Blida 1, Algeria, nbourahla@univ-blida.dz\n","title":"Cold-Formed Steel Wood Sheathed Shear Wall Panel examples","uri":"/opensees-gallery/community/cfswswp/"},{"content":"","title":"Concentrically Braced Portal Frame","uri":"/opensees-gallery/examples/steelbracedportal/"},{"content":"\n","tags":["Python"],"title":"Concrete","uri":"/opensees-gallery/examples/concretesurface/"},{"content":"Download (Reinforced Concrete 3D Frame (FGU).ipynb)\nReinforced Concrete 3D Frame January 2022, By Amir Hossein Namadchi This notebook is adapted from https://github.com/AmirHosseinNamadchi/OpenSeesPy-Examples/blob/master/Reinforced%20Concrete%203D%20Frame%20(FGU).ipynb\nIn this notebook, a 3-Dimensional one story Reinforced Concrete moment resisting frame is modeled. This is an OpenSeesPy simulation of TCL version of the model, presented by Fernando Gutiérrez Urzúa in his YouTube channel. Some minor modifications are made by me in the python version. According to his, modeling assumptions are:\nColumns \u0026 Beams are modeled as distributed plasticity elements To have cleaner code, all of the neccessary functions are written in a single .py file named RC3DF.py. The file contains:\nbuild_RC_rect_section: Build fiber rectangular RC section build_model: Builds the 3D RC Frame model run_gravity: Runs gravity analysis run_modal: Runs Modal analysis run_pushover: Runs Pushover analysis run_time_history: Runs Time history analysis reset_analysis: Resets the analysis by setting time to 0,removing the recorders and wiping the analysis. Some additional function arguments are provided to be able to tweak model parameters. Please note that some functions use data obtained by running other functions. For example, in order to run time-history analysis, some of the system’s natural frequencies are required which can be obtained by running run_modal function.\nThe model has been idealized as follows:\nBeam and Column sections are defined as:\nDependencies import time import sys import os import opensees.openseespy as ops import numpy as np import matplotlib.pyplot as plt import pandas as pd import RC3DF as RC Model Data Units (Silvia’s Style) m = 1.0 # Meters KN = 1.0 # KiloNewtons sec = 1.0 # Seconds mm = 0.001*m # Milimeters cm = 0.01*m # Centimeters ton = KN*(sec**2)/m # mass unit (derived) g = 9.81*(m/sec**2) # gravitational constant (derived) MPa = 1e3*(KN/m**2) # Mega Pascal GPa = 1e6*(KN/m**2) # Giga Pascal Geometric Dimensions L_X = 6.0*m # Span in X-direction L_Y = 7.0*m # Span in Y-direction L_Z = 3.5*m # Story height Material Definition f_c_1 = -25*MPa # f'c in compression for unconfined concrete f_c_2 = -28*MPa # f'c in compression for confined concrete eps_c = -0.002 # strain at maximum stress in compression eps_u = -0.02 # strain at ultimate stress in compression f_y = 420.0*MPa # fy for reinforcing steel E_s = 210.0*GPa # E for reinforcing steel Section Definition rebar = 0.25*np.pi*(25*mm)**2 # uniaxial Kent-Scott-Park concrete material with degraded linear unloading/reloading mat_KSP_unconf = {'ID':'Concrete02', 'matTag': 1, 'fpc': f_c_1, 'epsc0': eps_c, 'fpcu': 0.2*f_c_1, 'epsU': eps_u, 'lamda': 0.1, 'ft': -0.1*f_c_1, 'Ets': (-0.1*f_c_1)/0.002} # uniaxial Kent-Scott-Park concrete material with degraded linear unloading/reloading mat_KSP_conf = {'ID':'Concrete02', 'matTag': 2, 'fpc': f_c_2, 'epsc0': eps_c, 'fpcu': 0.2*f_c_2, 'epsU': eps_u, 'lamda': 0.1, 'ft': -0.1*f_c_2, 'Ets': (-0.1*f_c_2)/0.002} # uniaxial Giuffre-Menegotto-Pinto steel with isotropic strain hardening mat_GMP = {'ID':'Steel02', 'matTag':3, 'Fy': f_y, 'E0': E_s, 'b':0.005, 'R0': 20.0, 'cR1': 0.925, 'cR2': 0.15} sections = {'Beam':{'B':300*mm, 'H':600*mm, 'cover':40*mm, 'n_bars_top':3, 'n_bars_bot':3, 'n_bars_int_tot':4, 'bar_area_top':rebar, 'bar_area_bot':rebar, 'bar_area_int':rebar}, 'Column':{'B':300*mm, 'H':400*mm, 'cover':40*mm, 'n_bars_top':3, 'n_bars_bot':3, 'n_bars_int_tot':4, 'bar_area_top':rebar, 'bar_area_bot':rebar, 'bar_area_int':rebar} } Loading C_L = 80.0*(KN) # Concentrated load m_1 = 200.0*ton # lumped mass 1 Analysis Gravity analysis m = RC.build_model(L_X, L_Y, L_Z, mat_KSP_unconf, mat_KSP_conf, mat_GMP, sections, C_L, m_1) RC.run_gravity(m) Output:\nModel Built Successfully! Gravity analysis Done! Modal analysis m = RC.build_model(L_X, L_Y, L_Z, mat_KSP_unconf, mat_KSP_conf, mat_GMP, sections, C_L, m_1) RC.run_modal(m) Output:\nModel Built Successfully! Modal analysis Done! Pushover analysis in X directions m = RC.build_model(L_X, L_Y, L_Z, mat_KSP_unconf, mat_KSP_conf, mat_GMP, sections, C_L, m_1) RC.run_gravity(m) RC.reset_analysis(m) RC.run_pushover(m, m_1, direction='X') Output:\nModel Built Successfully! Gravity analysis Done! Pushover Analysis in X Done in 37.95 seconds Pushover analysis in Y directions m = RC.build_model(L_X, L_Y, L_Z, mat_KSP_unconf, mat_KSP_conf, mat_GMP, sections, C_L, m_1) RC.run_gravity(m) RC.reset_analysis(m) RC.run_pushover(m, m_1, direction='Y') Output:\nModel Built Successfully! Gravity analysis Done! Pushover Analysis in Y Done in 38.59 seconds Time history analysis in X directions m = RC.build_model(L_X, L_Y, L_Z, mat_KSP_unconf, mat_KSP_conf, mat_GMP, sections, C_L, m_1) RC.run_gravity(m) RC.reset_analysis(m) RC.run_time_history(m, direction='X') Output:\nModel Built Successfully! Gravity analysis Done! Running Time-History analysis with lambda= 1 Time-History Analysis in X Done in 46.35 seconds Time history analysis in Y directions m = RC.build_model(L_X, L_Y, L_Z, mat_KSP_unconf, mat_KSP_conf, mat_GMP, sections, C_L, m_1) RC.run_gravity(m) RC.reset_analysis(m) RC.run_time_history(m,direction='Y') Output:\nModel Built Successfully! Gravity analysis Done! Running Time-History analysis with lambda= 1 Time-History Analysis in Y Done in 45.58 seconds Visualization Pushover Curve df_R_X = pd.read_table('assets/Pushover_Horizontal_ReactionsX.out', sep = \" \", header = None, names=[\"Pseudo-Time\",\"R1_X\",\"R2_X\",\"R3_X\",\"R4_X\"]) df_R_Y = pd.read_table('assets/Pushover_Horizontal_ReactionsY.out', sep = \" \", header = None, names=[\"Pseudo-Time\",\"R1_Y\",\"R2_Y\",\"R3_Y\",\"R4_Y\"]) df_R_X['sum_R'] = df_R_X.values[:,1:5].sum(axis =1) df_R_Y['sum_R'] = df_R_Y.values[:,1:5].sum(axis =1) df_D_X = pd.read_table('assets/Pushover_Story_DisplacementX.out', sep = \" \", header = None, names=[\"Pseudo-Time\",\"D1_X\",\"D2_X\",\"D3_X\",\"D4_X\"]) df_D_Y = pd.read_table('assets/Pushover_Story_DisplacementY.out', sep = \" \", header = None, names=[\"Pseudo-Time\",\"D1_Y\",\"D2_Y\",\"D3_Y\",\"D4_Y\"]) df_D_X['avg_D'] = df_D_X.values[:,1:5].mean(axis = 1) df_D_Y['avg_D'] = df_D_Y.values[:,1:5].mean(axis = 1) plt.figure(figsize=(10,5)) plt.plot(df_D_X['avg_D'], -df_R_X['sum_R'], color = '#C0392B', linewidth=1.5) plt.plot(df_D_Y['avg_D'], -df_R_Y['sum_R'], color = '#27AE60', linewidth=1.5) plt.ylabel('Base Shear (KN)', {'fontstyle':'italic','size':14}) plt.xlabel('Average of Roof Displacement (m)', {'fontstyle':'italic','size':14}) plt.grid(which='both') plt.title('Pushover Curve',{'fontstyle':'normal','size':16}) plt.yticks(fontsize = 14) plt.xticks(fontsize = 14); plt.legend(['X-Direction', 'Y-Direction'],prop={'size':14}); Output:\n\u003cFigure size 1000x500 with 1 Axes\u003e Ground Motion histroy G_M =np.loadtxt('assets/acc_1.txt') times = np.arange(0,0.02*len(G_M),0.02) plt.figure(figsize=(12,4)) plt.plot(times,G_M, color = '#6495ED', linewidth=1.2) plt.ylabel('Acceleration (m/s2)', {'fontstyle':'italic','size':14}) plt.xlabel('Time (sec)', {'fontstyle':'italic','size':14}) plt.grid(which='both') plt.title('Time history of Ground Motion record',{'fontstyle':'normal','size':16}) plt.yticks(fontsize = 14); Output:\n\u003cFigure size 1200x400 with 1 Axes\u003e Time history of displacement and acceleration story_disp_X = np.loadtxt('assets/TimeHistory_Story_DisplacementX1.1.out') story_disp_Y = np.loadtxt('assets/TimeHistory_Story_DisplacementY1.1.out') plt.figure(figsize=(12,5)) plt.plot(story_disp_X[:,0], story_disp_X[:,1], color = '#DE3163', linewidth=1.2) plt.plot(story_disp_Y[:,0], story_disp_Y[:,2], color = '#FFBF00', linewidth=1.2) plt.ylabel('Horizontal Displacement (m)', {'fontstyle':'italic','size':14}) plt.xlabel('Time (sec)', {'fontstyle':'italic','size':14}) plt.grid(which='both') plt.title('Time history of horizontal dispacement',{'fontstyle':'normal','size':16}) plt.yticks(fontsize = 14); plt.xticks(fontsize = 14); plt.legend(['X-Direction', 'Y-Direction'], prop={'size':14}); Output:\n\u003cFigure size 1200x500 with 1 Axes\u003e story_accel_X = np.loadtxt('assets/TimeHistory_Story_AccelerationX1.1.out') story_accel_Y = np.loadtxt('assets/TimeHistory_Story_AccelerationY1.1.out') plt.figure(figsize=(12,5)) plt.plot(story_accel_X[:,0], story_accel_X[:,1], color = '#DE3163', linewidth=1.2) plt.plot(story_accel_Y[:,0], story_accel_Y[:,2], color = '#FFBF00', linewidth=1.2) plt.ylabel('Horizontal Acceleration (m/s2)', {'fontstyle':'italic','size':14}) plt.xlabel('Time (sec)', {'fontstyle':'italic','size':14}) plt.grid(which='both') plt.title('Time history of horizontal acceleration',{'fontstyle':'normal','size':16}) plt.yticks(fontsize = 14); plt.xticks(fontsize = 14); plt.legend(['X-Direction', 'Y-Direction'], prop={'size':14}); Output:\n\u003cFigure size 1200x500 with 1 Axes\u003e References Fernando Gutiérrez Urzúa's YouTube channel (https://www.youtube.com/user/lfgurzua) OpenseesPy Documentation (https://openseespydoc.readthedocs.io/en/latest/) ","title":"Concrete MRF","uri":"/opensees-gallery/examples/concretemrf/"},{"content":"From opstool\n","title":"Dam Break","uri":"/opensees-gallery/gallery/dambreak/"},{"content":"Floor diaphragm need to be axially rigid to assure proper distribution of seismic forces to all lateral force resisting elements (columns and walls). Common modeling approach for frame structures is to represent the structural components (beams and columns) by line elements located at the original member centerlines and having cross-sectional properties equal to those of components.\nThe effect of a rigid diaphragm at a floor level is usually modeled by imposing rigid constraints on all nodes of that floor level and thus enforcing the same lateral displacements of all nodes at the floor level. These constrains enforce condition of zero axial strain on elements that are part of that floor level. For sections where the neutral axis does not shift as a consequence of bending in the beam, axial strains at element’s centerlines are zero, and thus rigid constraints can be applied to model the rigid diaphragm (e.g. steel sections, elastic materials). However, for nonlinear beam-column elements (force-based or displacement-based) with reinforced concrete fiber section where the neutral axis shifts due to bending in the beam axial strains at element’s centerlines are no longer zero. Thus, rigid constraints that enforce condition of zero axial strain on elements will change the response of the frame. In this web-learning session, the effect of a rigid constraints is demonstrated on a 2D frame with force-based beam column elements considering three types of sections: elastic, nonlinear steel, and nonlinear reinforced concrete.\nThis web-learning series covers:\nIntroduction to problem Consequences of applying a rigid constraint on a force-based beam-column element with different types of sections (demonstrated on examples) Conclusions and summary PPT presentation of the seminar can be found here:\nModeling Diaphragms in 2D Models Video of the seminar can be found here:\nModeling Diaphragms in 2D Models OpenSees files used to demonstrate the effect of rigid constraints can be found here:\nThe main file that is to be sourced from the OpenSees interpreter: ModelingDiaphragms2D.tcl Supporting files to be stored in the same folder with the main file: RectangularRCsection2D.tcl (procedure for discretizing RC rectangular section into fibers) WSection.tcl (procedure for discretizing W steel section into fibers) A10000.txt (ground motion) ","title":"Diaphragms in 2D","uri":"/opensees-gallery/examples/modelingdiaphragms2d/"},{"content":"This article describes the OpenSees implementation of an effective stress analysis of a slope which is subject to a seismic event. The slope is modeled in two-dimensions and it is assumed that the slope is underlain by an elastic half-space. The free-field response of the soil is considered through the use of massive columns of soil with periodic boundary conditions located at both ends of the model. Nine-node quadrilateral elements with both displacement and pore pressure degrees of freedom enable the model to track changes in pore pressure and effective stress during the course of the analysis. A Lysmer-Kuhlemeyer (1969) dashpot is utilized to account for the finite rigidity of the underlying elastic medium.\nThis article also discusses the use of the tool GiD as a means for post-process visualization of the results of the analysis. Files are provided which convert the recorded output from OpenSees into a format which can be read by GiD and the processes behind this are briefly discussed. The pre-processing capabilities of GiD, and the application of these capabilities to the generation of the input file for this example, are discussed in a separate example, GiD ProblemTypes for 2D Slope Analysis Input File Generation. The GiD tool can be downloaded from http://gid.cimne.upc.es/download.\nNote: Some of the details of this analysis are shared with the Effective Stress Site Response Analysis of a Layered Soil Column example posted in the Practical Examples area of this manual. The user is referred to that example for further information on details which may be omitted or quickly explained here.\nProvided with this article are several files. Files which are required for the analysis are indicated. The files include:\nThe example input file, slopeAnalysis2Deff.tcl (required for analysis) The velocity time history of the selected earthquake record, velocityHistory.out (required for analysis) A series of Matlab scripts (flaviaWriter.m, dispFlavia.m, porePressFlavia.m, ppRatioFlavia.m, stressFlavia.m) which can be used to reformat the recorded displacement, pore pressure, and stress data into a file which can be read by GiD for post-process visulization. Non-Matlab users may find the process represented by these files useful in creating an alternative means for accomplishing this reformatting. A Matlab script, processMotion.m, which takes a particular acceleration time history, in this case the file GilroyNo1EW.out, and converts it into a velocity time history through numerical integration using the trapezoidal rule. All of the files mentioned above can be downloaded by clicking here.\nTo run this example, the user must download the input file, slopeAnalysis2Deff.tcl, and the velocity time history file, velocityHistory.out, and place them in a single directory. Once this has been done, the user can then run the analysis. The additional files described above are not essential to the analysis. They are provided to demonstrate how to use the GiD tool to visualize results from this type of analysis.\nModel Description The analysis discussed in this article is for the site shown in Fig. 1 above. There are several layers of cohesive and cohesionless material which make up this site, and the site is partially submerged below a body of water. The groundwater table in the portion of the site away from Puget Sound is assumed to have a constant elevation. The entire site is underlain by an elastic half-space, allowing some of the energy imparted by the seismic event to be removed from the site in a manner consistent with the existence of layer of bedrock below the slope site. The elastic half-space is modeled using a Lysmer-Kuhlemeyer (1969) dashpot in a similar manner to that used in the effective and total stress site response examples posted in the Practical Examples section of this manual.\nMesh Geometry The input file for this example analysis, slopeAnalysis2Deff.tcl, was generated using the GiD problemtype UWnineQuad2Dup.gid, which is provided and discussed in a separate example, GiD ProblemTypes for 2D Slope Analysis Input File Generation. Using this problemtype, it is possible to create the mesh geometry visually in GiD, and export this information, along with additional conditions such as nodal fixities and material assignments, into an input file which can be read by OpenSees. Further details into this process can be found in the GiD ProblemTypes for 2D Slope Analysis Input File Generation example.\nThe mesh created for this example using GiD as a pre-processor is shown in Fig. 2. The use of the GiD tool greatly simplifies mesh-generation for 2D problems as compared to creating the nodes using loops inside the input file. The benefit is especially evident when mesh modifications or refinement are necessary.\nThe formulation of the nine-node quadrilateral elements used in this example necessitates care in the number of degrees of freedom which are currently in the domain when defining certain aspects of the model. The corner nodes of the elements must be created in a domain which considers three degrees of freedom, while the interior nodes of the elements must be created in a domain which considers only two degrees of freedom. This is also true of the fixities, masses, and loads applied to these two sets of nodes. Further discussion on the nine-node quadrilateral elements is available in the example, Effective Stress Site Response Analysis of a Layered Soil Column.\nBoundary Conditions The nodes at the base of the mesh are fixed against vertical translation only. The technique used to model the underlying elastic half-space necessitates that these nodes be left free to displace in the horizontal direction, however, the nodes on the base of the model are all given equalDOF for horizontal displacements. The pore pressure degree of freedom is fixed for all nodes on the upper boundary of the model and/or above the groundwater table. Fixing this degree of freedom creates a drainage path for the water in the adjacent elements and restricts the pore pressure in these locations to zero. These two sets of boundary conditions are the only fixities applied to the model.\nIn the horizontal direction, the model only represents a small section of a presumably infinite (or at least very large) soil domain. To ensure that free-field conditions exist at the horizontal boundaries of the model, the elements in these locations (the free-field columns indicated in red in Fig. 1) are given increased thickness to ensure that they are significantly more massive than the elements in the interior of the mesh, and the displacement degrees of freedom for the nodes on either side of these columns are tied together using equalDOF to create periodic boundary conditions. When the horizontal excitation is applied to the model, the reaction of these massive columns should be the free-field response. To ensure that the critical portions of the model, such as the slope in this example, are not affected by the horizontal boundaries, the free-field columns must be located sufficiently far away from the critical regions.\nMaterial and Element Definitions The soil constitutive behavior is modeled using the PressureDependMultiYield02 nDMaterial object for the cohesionless material and the PressureIndependMultiYield nDMaterial object for the cohesive material.\nNote: The mass density input values for the material objects should be total mass densities, i.e. above the groundwater table, the mass density should reflect dry or moist conditions, and below the groundwater table, the mass density should be the saturated value. For elements with free pore pressure degrees of freedom (those below the water table), the 9_4_QuadUP element computes the effective mass density using the input value from the material object and the fluid mass density specified during the element generation.\nIncluded with the material definitions for each soil layer are additional parameters which are used by the 9_4_QuadUP element. These include the element thickness, the horizontal and vertical body forces on the element, the undrained bulk modulus, and the horizontal and vertical permeabilities. Each layer of soil is given appropriate values for these parameters. The elements in the free-field columns are given increased thickness here.\nNote: Gravity must be incorporated into an analysis using the 9_4_QuadUP element in a manner which differs from that used for the standard four node quad element. With the four node quad element, gravity is typically considered through the use of body forces which represent the unit weight of the soil. In the case of the nine node quad element, the body forces should not be the unit weights, instead they should have magnitudes equal to the components of gravity only.\nThe 9_4_QuadUP element should be defined in the following manner:\nFig 3. Nine node quadrilateral element. element 9_4_QuadUP eleID nodei j k l m n p q r thickness matID uBulk fMass hPerm vPerm hBody vBody\nwhere uBulk is the undrained bulk modulus, fMass is the fluid mass density, hPerm and vPerm are the horizontal and vertical permeabilites, and hBody and vBody are the horizontal and vertical body forces. The nodal connectivity pattern matches that shown in Fig. 3. The creators of the 9_4_QuadUP element recommend an undrained bulk modulus which is equal to the bulk modulus of the fluid (2.2e6 kPa for water) divided by the porosity of the soil layer. In this example, the fluid is water, therefore, the fluid mass density for each layer is set to 1.0 Mg/m^3.\nThe permeabilities for all of the elements are initially set to 1.0 m/s to ensure that hydrostatic conditions exist after the application of gravity in the model. If the permeability of a particular layer is too low, it may take many gravity analysis steps in order to reach hydrostatic pressure conditions. Prior to the application of the ground motion, the permeabilities of each soil layer are updated using the updateParameter command to their respective assigned values so pore pressure generation during the horizontal excitation is captured appropriately. The usage of the updateParameter command seems to differ from that documented here. Parameter tags must be defined for each permeability parameter (horizontal and vertical) for each element. Then these tags can be used to update the corresponding parameters.\nAn example of the parameter update process for two elements is provided here. To set the parameter tags:\ntag eleTag parameterType parameter 10001 element 1 vPerm parameter 10002 element 1 hPerm parameter 10003 element 2 vPerm parameter 10004 element 2 hPerm To update the permeability parameters:\ntag parameterValue updateParameter 10001 1.0e-4 updateParameter 10002 1.0e-4 updateParameter 10003 1.0e-5 updateParameter 10004 1.0e-5 It seems to help to make the parameter tags different from any of the other tags used in the model (e.g. material, element tags), hence the numbers in this example start at 10001 and increase incrementally. As might be expected, the parameter tags must be defined before the parameters can be updated.\nLysmer Dashpot Definition A single zeroLength element is used to define the Lysmer-Kuhlemeyer (1969) dashpot. One end of the dashpot element is fixed against all displacements, while the other is given equalDOF with the soil node in the lower left hand corner of the model. The node in the lower left hand corner of the model is the master node for the horizontal equalDOF assigned to the nodes at the base of the mesh.\nThe viscous uniaxial material is used to define the constitutive behavior of the Lysmer-Kuhlemeyer (1969) dashpot in the horizontal direction. This material model requires a single input, the dashpot coefficient, c. Following the method of Joyner and Chen (1975), the dashpot coefficient is defined as the product of the mass density and shear wave velocity of the underlying medium, which, in this example, is assumed to have the properties of bedrock. The dashpot coefficient must be scaled by the area of the base of the model to ensure that equivalent loading is applied.\nNote: This area factor must take into account the increased thickness of the free-field columns and must be entered manually into the input file via the variable, $baseArea ; GiD does not calculate this factor.\nIncorporating the Body of Water into the Model As shown in Fig. 1, a portion of the site modeled in this example is submerged beneath Puget Sound. To incorporate the dynamic effects of the water on the site without altering the effective stresses in the soil elements, each node on the boundary of the mesh which is below the body of water is assigned a nodal mass using the mass command. For the nodes on the level surface, the horizontal mass is set to zero and the vertical mass is set as the mass of the volume of water 'supported' by the node. For each respective node, this volume is bounded by the depth of water above the node, half the distance to adjacent nodes, and the element thickness. The nodes on the slope are assigned horizontal and vertical mass components based on the geometry of the slope.\nNote: These values must be manually input in to the analysis, GiD does not automatically calculate them. Also, care must be taken as to how many degrees of freedom exist at each node. In this example, the nodes with three degrees of freedom are assigned masses separately from the nodes with two degrees of freedom.\nGravity Analysis and Recorders The first step in the analysis is to apply gravity to the model. This ensures that the distributions of pore pressure and effective stresses in the model are appropriate for the site conditions prior to the application of a ground motion. Separate recorders are set up so the gravity analysis information is distinct from any post-gravity results. Nodal displacements, accelerations, and pore pressures are recorded along with the elemental stresses and strains at each of the nine Gauss points.\nThe gravity analysis is conducted in two parts. In the first part, the soil elements are considered to be linear elastic. This is accomplished by setting the material stage to be zero for each material object using the updateMaterialStage command. The second part of the gravity analysis considers elastoplastic constitutive behavior by setting updating the material stage to one for each material object.\nThe elastic portion of the gravity analysis is run as a transient analysis with very large time steps, thus simulating a static analysis while avoiding the conflicts which may occur when mixing static and transient analyses. Gravity is applied for 10 steps with a time step of 500, and 10 steps with a timestep of 5000. This is done to ensure that hydrostatic pore pressure conditions are achieved. The plastic portion of the gravity analysis is run using smaller time steps to aid in convergence, and because drastic, free-vibration causing displacements, do not typically occur in this stage of the analysis.\nHorizontal Analysis and Recorders Using the method of Joyner and Chen (1975), dynamic excitation is applied as a force time history to the base of the soil column, at the node which shares equal degrees-of-freedom with the Lysmer-Kuhlemeyer (1969) dashpot. This force history is obtained by multiplying the velocity time history of the recorded ground motion by the mass density and shear wave velocity of the underlying bedrock layer and the area of the base of the model (This factor is the same as the previously discussed dashpot coefficient). This technique considers the finite rigidity of the underlying layer by allowing energy to be radiated back into the underlying material.\nThe force history is applied to the model as a Path TimeSeries object using a Plain load pattern object. The actual force applied to the node in each time step is the product of the load factor indicated in the pattern object, the additional load factor included in the timeSeries object, and the value found in the file, velocityHistory.out, at that time step. The load factor included in the timeSeries object is used to create a force history from the velocity history found in the namesake file.\nThe same items that are recorded during the gravity analysis are recorded here, the only difference is the file names are different so that the two analyses are recorded separately. The recorder time step is set as twice the analysis time step to reduce the size of the output files.\nFor improved success in completing the analysis in a timely manner, a convergence loop is included in the input file. If convergence is not reached, the time step is reduced in half and the analysis continues. The loop is set such that this process can occur twice before the analysis is deemed over. If the user encounters a problem where two reductions in the initial time step do not create a time step small enough for convergence, it is recommended that a smaller initial time step be set.\nThe remaining details of the analysis are very similar to those discussed in the Total Stress Site Response Analysis of a Layered Soil Column and Effective Stress Site Response Analysis of a Layered Soil Column examples.\nPost-Processing of Results in GiD Visualization of the results of a 2D analysis, such as that presented in this article, can be accomplished using the GiD tool. Any quantity that is recorded at a node (e.g. displacement) or a Gauss point (e.g. stress) can be read into GiD as post-process results. GiD is then able to produce various plots and animations with which to evaluate the results of the analysis. Information on how to use the post-processing capabilities of GiD for this purpose can be found in the GiD manuals.\nFor the purposes of efficiency, the post-processing in GiD is conducted under the assumption that the data corresponds to four node quadrilateral elements. The nine node quadrilateral elements used in this example only have pore pressure degrees of freedom at the corner nodes. In order to visualize contour plots of pore pressure in GiD for nine node elements, it is required that pore pressure values be assigned to every node in the element. It is not difficult to map the pore pressures to the interior nodes using the values at the corner nodes, however, there are many elements and many time steps, and this process would become very expensive computationally. Instead of taking this approach, only the recorded nodal quantities at the corner nodes and the recorded elemental quantities at the corner Gauss points are used for post-process visualizations. This is accomplished by creating a post-process mesh which shares the geometry of the original mesh, but for which the elements only have four nodes. While this approach somewhat alters the resolution of the data as recorded from the nine node elements, it is sufficient for the purpose of visualization.\nSeveral Matlab scripts have been provided which sort the output from the OpenSees recorders into a format that can be read into GiD. These files, flaviaWriter.m, dispFlavia.m, porePressFlavia.m, ppRatioFlavia.m, and stressFlavia.m, are available for download with the rest of the files for this example here. This series of files creates a GiD post-process results file given the default name renameMe.flavia.res by running the main file, flaviaWriter.m in Matlab. The individual quantities such as displacement, pore pressure, and stress are handled by separate functions, allowing the user to only write a results file for quantities of interest. The flaviaWriter.m function requires several input arguments. In order, these are the material type as a string ('elastic' for elasticIsotropic material, 'PDMY' for pressureDependMultiYield or pressureDependMultiYield02, 'PIMY' for pressureIndependMultiYield, or 'J2' for J2Plasticity), the analysis time step, and the number of gravity steps used in the analysis. These arguments ensure that the results are correctly integrated into the post-process results file.\nA post-process mesh file is generated automatically by the input file for the slope analysis as generated by the UWnineQuad2Dup problemtype discussed in the GiD ProblemTypes for 2D Slope Analysis Input File Generation example. This file simply lists the nodes with their locations and the elements with their nodal connectivities. The post-process mesh file which is created is given the default name renameMe.flavia.msh.\nTo visualize the results in GiD, perform the following steps:\nRun the analysis in OpenSees. Generate the post-process results file using the supplied Matlab scripts. Save a blank project in GiD with any desired name (e.g. slopeAnalysis.gid). Place the post-process mesh and results files (renameMe.flavia.msh and renameMe.flavia.res) in the GiD project directory. Change the names to match the project name (e.g. slopeAnalysis.flavia.msh and slopeAnalysis.flavia.res). Open the project and enter post-process mode. Representative Results The slope analysis of this example was intended to evaluate the stability of the slope after the development of cyclic mobility in the loose sand layer. The ability of the model to capture the development of this cyclic mobility is demonstrated here for three purposes: (1) to demonstrate the ability of OpenSees to model this type of behavior, (2) to demonstrate the post-processing capabilities of GiD, and (3) as a means to verify the proper download and implementation of the example files.\nFig. 4 shows the shear stress-strain response for the center Gauss point of two elements from the loose sand layer of the model. One of the elements is located just in front of the toe of the slope, and the other is located somewhat below the top of the slope. As shown, it appears that cyclic mobility occurs at the slope toe location, as the shear strains become very large and plastic behavior is clearly visible, while it does not appear to occur at the other location, where the response remains largely elastic. For verification purposes, the two elements in these plots are elements 458 (slope top) and 729 (slope toe). Fig. 4: Shear stress-strain response in loose sand layer for two locations: a point below the top of the slope, and a point below and slightly in front of the toe of the slope. Fig. 6: Contour plot of pore pressure ratios on deformed shape of a segment of the slope mesh during the strongest portion of the applied motion. To verify the presence of cyclic mobility in the model, the pore pressure ratios, taken as the ratio of the excess pore pressure to the initial vertical effective stress, at several locations in the loose sand layer are examined. Fig. 5 shows these computed ratios. As shown, at the two locations in front of the slope toe, the pore pressure ratios reach 1.0, indicating the initiation of initial liquefaction. The observed pore pressure behavior corresponds well with the behavior observed in the shear stress strain response. The considered locations range between the middle of the slope to in front of the toe of the slope. For verification purposes, these nodes are numbers 747, 914, 996, and 1079. Fig. 6 shows a contour plot of the slope region during the strongest portion of the applied ground motions. As shown, the largest pore pressure ratios develop in front of the slope toe where the vertical effective stress is at a minimum for this layer.\nFig. 7: Comparison of recorded displacement histories at several points in the loose sand layer. The solid lines indicate an analysis where cyclic mobility occurs, and the dashed lines indicate an analysis without cyclic mobility. To demonstrate how the observed initiation of liquefaction affects the stability of the slope, a second analysis was conducted in which the permeabilities of the layers were increased. In this analysis, large excess pore pressures do not develop and cyclic mobility is not observed. A comparison of the displacement histories of several nodes inside the loose sand layer in each analysis is shown in Fig. 7. In this plot, the original analysis (with cyclic mobility) is represented as solid lines, while the second analysis (without cyclic mobility) is represented using dashed lines. As shown, for all of the locations the displacements which develop for the case where liquefaction occurred are larger. The response of the node which is to the left of the slope is only slightly different, however, the period-elongating effects of the liquefaction can be observed. For verification purposes, the plotted nodes are numbers 1009, 1301, 1755, and 2713.\nReferences Joyner, W.B. and Chen, A.T.F. (1975). \"Calculation of nonlinear ground response in earthquakes,\" Bulletin of the Seismological Society of America, Vol. 65, No. 5, pp. 1315-1336, October 1975. Kramer, S.L. (1996). Geotechnical Earthquake Engineering. Prentice Hall, Upper Saddle River, NJ. Lysmer, J. (1978). \"Analytical procedures in soil dynamics,\" Report No. UCB/EERC-78/29, University of California at Berkeley, Earthquake Engineering Research Center, Richmond, CA. Lysmer, J. and Kuhlemeyer, A.M. (1969). \"Finite dynamic model for infinite media,\" Journal of the Engineering Mechanics Division, ASCE, 95, 859-877. Example prepared by: Christopher McGann and Pedro Arduino, University of Washington\n","title":"Dynamic 2D Effective Stress Analysis of Slope","uri":"/opensees-gallery/community/slopeanalysis2d/"},{"content":"This example demonstrates how to perform a dynamic analysis in OpenSees using a 2-story, 1-bay steel moment resisting frame. The structure is subjected to the Canoga Park record from the 1994 Northridge earthquake. The nonlinear behavior is represented using the concentrated plasticity concept with rotational springs. The rotational behavior of the plastic regions follows a bilinear hysteretic response based on the Modified Ibarra Krawinkler Deterioration Model (Ibarra et al. 2005, Lignos and Krawinkler 2009, 2010). For this example, all modes of cyclic deterioration are neglected. A leaning column carrying gravity loads is linked to the frame to simulate P-Delta effects.\nThe files needed to analyze this structure in OpenSees are included here:\nThe main file: MRF_2Story_Concentrated.tcl (last update: 10 Oct 2013) Supporting procedure files\nRotSpring2DModIKModel.tcl - creates a bilinear rotational spring that follows the Modified Ibarra Krawinkler Deterioration Model (used in the concentrated model) RotLeaningCol.tcl - creates a low-stiffness rotational spring used in a leaning column The acceleration history for the Canoga Park record\nNR94cnp.tcl - contains acceleration history in units of g All files are available in a compressed format here: dynamic_example_10Oct2013.zip (last update: 10 Oct 2013)\nThe rest of this example describes the model and shows the analysis results.\nModel Description Figure 1. Schematic representation of concentrated plasticity OpenSees model with element number labels and [node number] labels. Note: The springs are zeroLength elements, but their sizes are greatly exaggerated in this figure for clarity. The 2-story, 1-bay steel moment resisting frame is modeled with elastic beam-column elements connected by ZeroLength elements which serve as rotational springs to represent the structure’s nonlinear behavior. The springs follow a bilinear hysteretic response based on the Modified Ibarra Krawinkler Deterioration Model. A leaning column with gravity loads is linked to the frame by truss elements to simulate P-Delta effects. An idealized schematic of the model is presented in Figure 1.\nTo simplify this model, panel zone contributions are neglected, plastic hinges form at the beam-column joints, and centerline dimensions are used. For an example that explicitly models the panel zone shear distortions and includes reduced beam sections (RBS), see Pushover and Dynamic Analyses of 2-Story Moment Frame with Panel Zones and RBS.\nFor a detailed description of this model, see Pushover Analysis of 2-Story Moment Frame. The units of the model are kips, inches, and seconds.\nDamping and the Rayleigh Command This model uses Rayleigh damping which formulates the damping matrix as a linear combination of the mass matrix and stiffness matrix: c = a0m + a1k, where a0 is the mass proportional damping coefficient and a1 is the stiffness proportional damping coefficient. A damping ratio of 2%, which is a typical value for steel buildings, is assigned to the first two modes of the structure. The rayleigh command allows the user to specify whether the initial, current, or last committed stiffness matrix is used in the damping matrix formulation. In this example, only the initial stiffness matrix is used, which is accomplished by assigning values of 0.0 to the other stiffness matrix coefficients.\nTo properly model the structure, stiffness proportional damping is applied only to the frame elements and not to the highly rigid truss elements that link the frame and leaning column, nor to the leaning column itself. OpenSees does not apply stiffness proportional damping to zeroLength elements. In order to apply damping to only certain elements, the rayleigh command is used in combination with the region command. As noted in the region command documentation, the region cannot be defined by BOTH elements and nodes. Because mass proportional damping assigns damping to nodes with mass, OpenSees will ignore any mass proportional damping that is assigned using the rayleigh command in combination with the region command for a region of elements. Therefore, if using the region command to assign damping, the mass proportional damping and stiffness proportional damping must be assigned in separate steps.\nModifications to the Stiffness Proportional Damping Coefficient As described in the “Stiffness Modifications to Elastic Frame Elements” section of Pushover Analysis of 2-Story Moment Frame, the stiffness of the elastic frame elements has been modified. As explained in Ibarra and Krawinkler (2005) and Zareian and Medina (2010), the stiffness proportional damping coefficient that is used with these elements must also be modified. As the stiffness of the elastic elements was made “(n+1)/n” times greater than the stiffness of the actual frame member, the stiffness proportional damping coefficient of these elements must also be made “(n+1)/n” times greater than the traditional stiffness proportional damping coefficient.\nDynamic Analysis Recorders The recorders used in this example include:\nThe drift recorder to track the story and roof drift histories The node recorder to track the floor displacement and base shear reaction histories The element recorder to track the element forces in the first story columns as well as the moment and rotation histories of the springs in the concentrated plasticity model For the element recorder, the region command was used to assign all column springs to one group and all beam springs to a separate group.\nIt is important to note that the recorders only record information for analyze commands that are called after the recorder commands are called. In this example, the recorders are placed after the gravity analysis so that the steps of the gravity analysis do not appear in the output files.\nAnalysis The structure is analyzed under gravity loads before the dynamic analysis is conducted. The gravity loads are applied using a load-controlled static analysis with 10 steps. So that the gravity loads remain on the structure for all subsequent analyses, the loadConst command is used after the gravity analysis is completed. This command is also used to reset the time to zero so that the dynamic analysis starts from time zero.\nFor the dynamic analysis, the structure is subjected to the Canoga Park record from the 1994 Northridge earthquake. To apply the ground motion to the structure, the uniform excitation pattern is used. The name of the file containing the acceleration record, timestep of the ground motion, scale factor applied to the ground motion, and the direction in which the motion is to be applied must all be specified as part of the uniform excitation pattern command.\nTo execute the dynamic analysis, the analyze command is used with the specified number of analysis steps and the timestep of the analysis. The timestep used in the analysis should be less than or equal to the timestep of the input ground motion.\nResults Figure 2. Floor Displacement History The floor displacement histories from the dynamic analysis are shown in Figure 2. The top graph shows the ground acceleration history while the middle and bottom graphs show the displacement time histories of the 3rd floor (roof) and 2nd floor, respectively.\nReferences Ibarra, L. F., and Krawinkler, H. (2005). “Global collapse of frame structures under seismic excitations,” Technical Report 152, The John A. Blume Earthquake Engineering Research Center, Department of Civil Engineering, Stanford University, Stanford, CA. [electronic version: https://blume.stanford.edu/tech_reports] Ibarra, L. F., Medina, R. A., and Krawinkler, H. (2005). “Hysteretic models that incorporate strength and stiffness deterioration,” Earthquake Engineering and Structural Dynamics, Vol. 34, 12, pp. 1489-1511. Lignos, D. G., and Krawinkler, H. (2009). “Sidesway Collapse of Deteriorating Structural Systems under Seismic Excitations,” Technical Report 172, The John A. Blume Earthquake Engineering Research Center, Department of Civil Engineering, Stanford University, Stanford, CA. Lignos, D. G., and Krawinkler, H. (2011). “Deterioration Modeling of Steel Beams and Columns in Support to Collapse Prediction of Steel Moment Frames,” ASCE, Journal of Structural Engineering, Vol. 137 (11), 1291-1302. Zareian, F. and Medina, R. A. (2010). “A practical method for proper modeling of structural damping in inelastic plane structural systems,” Computers \u0026 Structures, Vol. 88, 1-2, pp. 45-53. Example posted by: Laura Eads, Stanford University; Modified: Filipe Ribeiro, Andre Barbosa (09/03/2013) ","title":"Dynamic Analysis of 2-Story Moment Frame","uri":"/opensees-gallery/examples/mrf_concentrated/"},{"content":"This example is of an elastic frame structure, as shown in the figure, subject to static loads.\nHere is the file: ElasticFrame.tcl\nElasticFrame.png NOTE:\nThe lines in the dashed boxes are lines that appear in the input file. all lines that begin with # are comments, they are ignored by the program (interpreter) but are useful for documenting the code. When creating your own input scripts you are highly encouraged to use comments. For brevity it is possible to put the comment after the command by using the ; to signify end of a command. The printing of info to the screen makes this example more complicated than it needs to be. If you don't understand it, you can ignore it for now. Parameters Before we build the model we are going to set some parameters using tcl variables and expression evaluation. We are going to set variables for PI, the gravtational constant g, and variables for each of our floor masses. We are using the tcl set and expr commands.\nset PI [expr 2.0 * asin(1.0)] set g 386.4 set ft 12.0 set m1 [expr 1185.0/(4*$g)]; # 4 nodes per floor set m2 [expr 1185.0/(4*$g)] set m3 [expr 970.0/(4*$g)] set w1 [expr 1185.0/(90*$ft)] set w2 [expr 1185.0/(90*$ft)] set w3 [expr 970.0/(90*$ft)] Model The model consists of sixteen nodes, twenty one elastic beam-column elements, a single load pattern with distributed loads, and constraints totally fixing the nodes at the base of the building. There are no material objects associated with the elastic elements, but there are geometric transformations. For this example all the columns have a PDelta transformation, and all the beams a linear transformation.\n\u003cli\u003eUnits: kips, in, sec\u003c/li\u003e \u003cli\u003eRemove existing model\u003c/li\u003e \u003c/ol\u003e \u003cp\u003ewipe\u003c/p\u003e \u003col\u003e \u003cli\u003eCreate ModelBuilder (with two-dimensions and 3 DOF/node)\u003c/li\u003e \u003c/ol\u003e \u003cp\u003emodel BasicBuilder -ndm 2 -ndf 3\u003c/p\u003e \u003col\u003e \u003cli\u003eCreate nodes \u0026amp; add to Domain -\u003c/li\u003e \u003cli\u003ecommand: node nodeId xCrd yCrd \u003c-mass $massX $massY $massRz\u003e\u003c/li\u003e \u003cli\u003eNOTE: mass is optional\u003c/li\u003e node 1 0.0 0.0 node 2 360.0 0.0 node 3 720.0 0.0 node 4 1080.0 0.0 node 5 0.0 162.0 -mass $m1 $m1 0.0 node 6 360.0 162.0 -mass $m1 $m1 0.0 node 7 720.0 162.0 -mass $m1 $m1 0.0 node 8 1080.0 162.0 -mass $m1 $m1 0.0 node 9 0.0 324.0 -mass $m2 $m2 0.0 node 10 360.0 324.0 -mass $m2 $m2 0.0 node 11 720.0 324.0 -mass $m2 $m2 0.0 node 12 1080.0 324.0 -mass $m2 $m2 0.0 node 13 0.0 486.0 -mass $m3 $m3 0.0 node 14 360.0 486.0 -mass $m3 $m3 0.0 node 15 720.0 486.0 -mass $m3 $m3 0.0 node 16 1080.0 486.0 -mass $m3 $m3 0.0 \u003col\u003e # Set the boundary conditions - command: fix nodeID xResrnt? yRestrnt? rZRestrnt? fix 1 1 1 1 fix 2 1 1 1 fix 3 1 1 1 fix 4 1 1 1 # Define geometric transformations for beam-column elements geomTransf Linear 1; # beams geomTransf PDelta 2; # columns \u003cli\u003eDefine elements\u003c/li\u003e \u003cli\u003eCreate elastic beam-column elements -\u003c/li\u003e \u003cli\u003ecommand: element elasticBeamColumn eleID node1 node2 A E Iz geomTransfTag\u003c/li\u003e \u003c/ol\u003e # Define the Columns element elasticBeamColumn 1 1 5 75.6 29000.0 3400.0 2; # W14X257 element elasticBeamColumn 2 5 9 75.6 29000.0 3400.0 2; # W14X257 element elasticBeamColumn 3 9 13 75.6 29000.0 3400.0 2; # W14X257 element elasticBeamColumn 4 2 6 91.4 29000.0 4330.0 2; # W14X311 element elasticBeamColumn 5 6 10 91.4 29000.0 4330.0 2; # W14X311 element elasticBeamColumn 6 10 14 91.4 29000.0 4330.0 2; # W14X311 element elasticBeamColumn 7 3 7 91.4 29000.0 4330.0 2; # W14X311 element elasticBeamColumn 8 7 11 91.4 29000.0 4330.0 2; # W14X311 element elasticBeamColumn 9 11 15 91.4 29000.0 4330.0 2; # W14X311 element elasticBeamColumn 10 4 8 75.6 29000.0 3400.0 2; # W14X257 element elasticBeamColumn 11 8 12 75.6 29000.0 3400.0 2; # W14X257 element elasticBeamColumn 12 12 16 75.6 29000.0 3400.0 2; # W14X257 # Define the Beams element elasticBeamColumn 13 5 6 34.7 29000.0 5900.0 1; # W33X118 element elasticBeamColumn 14 6 7 34.7 29000.0 5900.0 1; # W33X118 element elasticBeamColumn 15 7 8 34.7 29000.0 5900.0 1; # W33X118 element elasticBeamColumn 16 9 10 34.2 29000.0 4930.0 1; # W30X116 element elasticBeamColumn 17 10 11 34.2 29000.0 4930.0 1; # W30X116 element elasticBeamColumn 18 11 12 34.2 29000.0 4930.0 1; # W30X116 element elasticBeamColumn 19 13 14 20.1 29000.0 1830.0 1; # W24X68 element elasticBeamColumn 20 14 15 20.1 29000.0 1830.0 1; # W24X68 element elasticBeamColumn 21 15 16 20.1 29000.0 1830.0 1; # W24X68\u003c/p\u003e # Create a Plain load pattern with a linear TimeSeries: # command pattern Plain $tag $timeSeriesTag { $loads } pattern Plain 1 1 { eleLoad -ele 13 14 15 -type -beamUniform -$w1 eleLoad -ele 16 17 18 -type -beamUniform -$w2 eleLoad -ele 19 20 21 -type -beamUniform -$w3 } Analysis - Gravity Load We will now show the commands to perform a gravity load analysis. As the model is elastic we will use a Linear solution algorithm and use a single step of load control to get us to the desired load level.\nCreate the system of equation system BandSPD\nCreate the DOF numberer, the reverse Cuthill-McKee algorithm numberer RCM\nCreate the constraint handler, a Plain handler is used as homo constraints constraints Plain\nCreate the integration scheme, the LoadControl scheme using steps of 1.0 integrator LoadControl 1.0\nCreate the solution algorithm, a Linear algorithm is created algorithm Linear\ncreate the analysis object analysis Static Perform The Gravity Analysis After the objects for the model, analysis and output has been defined we now perform the analysis.\nanalyze 1 Print Info to Screen to Allow User to Check Results In addition to using recorders, it is possible to specify output using the print and puts commands. When no file identifiers are provided, these commands will print results to the screen. We use the nodeReaction command to return the reactions at the individual nodes and the tcl lindex command to obtain the values from these lists.\ninvoke command to determine nodal reactions reactions\nset node1Rxn [nodeReaction 1]; # nodeReaction command returns nodal reactions for specified node in a list set node2Rxn [nodeReaction 2] set node3Rxn [nodeReaction 3] set node4Rxn [nodeReaction 4]\nset inputedFy [expr -$Load1-$Load2-$Load3]; # loads added negative Fy direction to ele set computedFx [expr [lindex $node1Rxn 0]+[lindex $node2Rxn 0]+[lindex $node3Rxn 0]+[lindex $node4Rxn 0]] set computedFy [expr [lindex $node1Rxn 1]+[lindex $node2Rxn 1]+[lindex $node3Rxn 1]+[lindex $node4Rxn 1]]\nputs \"\\nEqilibrium Check After Gravity:\" puts \"SumX: Inputed: 0.0 + Computed: $computedFx = [expr 0.0+$computedFx]\" puts \"SumY: Inputed: $inputedFy + Computed: $computedFy = [expr $inputedFy+$computedFy]\" Add Lateral Loads Now we prepare to add our lateral loads to the model. First we need to set the gravity loads acting constant, i.e. we do not want them changing as we apply more loads to the model. Then we will create load pattern with nodal loads to add to the model.\nset gravity loads constant and time in domain to 0.0 loadConst -time 0.0\ntimeSeries Linear 2 pattern Plain 2 2 { load 13 220.0 0.0 0.0 load 9 180.0 0.0 0.0 load 5 90.0 0.0 0.0 } Recorder We will create an element recorder to record the forces at the bottom story columns.\nrecorder Element -file eleForces.out -ele 1 4 7 10 forces Perform The Lateral Load Analysis After the objects for the model, analysis and output has been defined we now perform the analysis.\nanalyze 1 Print Info to Screen to Allow User to Check Results In addition to using recorders, it is possible to specify output using the print and puts commands. When no file identifiers are provided, these commands will print results to the screen.\nreactions\nset node1Rxn [nodeReaction 1]; # nodeReaction command returns nodal reactions for specified node in a list set node2Rxn [nodeReaction 2] set node3Rxn [nodeReaction 3] set node4Rxn [nodeReaction 4]\nset inputedFx [expr 220.0+180.0+90.0] set computedFx [expr [lindex $node1Rxn 0]+[lindex $node2Rxn 0]+[lindex $node3Rxn 0]+[lindex $node4Rxn 0]] set computedFy [expr [lindex $node1Rxn 1]+[lindex $node2Rxn 1]+[lindex $node3Rxn 1]+[lindex $node4Rxn 1]]\nputs \"\\nEqilibrium Check After Lateral Loads:\" puts \"SumX: Inputed: $inputedFx + Computed: $computedFx = [expr $inputedFx+$computedFx]\" puts \"SumY: Inputed: $inputedFy + Computed: $computedFy = [expr $inputedFy+$computedFy]\"\nprint ele information for columns at bottom print ele 1 4 7 19 Finally look at the eigenvalues After the lateral load analysis has completed we will look at the period of the structure. To do this we use the eigenvalue command to obtain the eigenvalues. These are returned in a tcl list. From the list we obtain the eigenvalue for the mode using the tcl lindex command and use the expr command to determine the period.\nset eigenValues [eigen 5] puts \"\\nEigenvalues:\" set eigenValue [lindex $eigenValues 0] puts \"T[expr 0+1] = [expr 2*$PI/sqrt($eigenValue)]\" set eigenValue [lindex $eigenValues 1] puts \"T[expr 1+1] = [expr 2*$PI/sqrt($eigenValue)]\" set eigenValue [lindex $eigenValues 2] puts \"T[expr 2+1] = [expr 2*$PI/sqrt($eigenValue)]\" set eigenValue [lindex $eigenValues 3] puts \"T[expr 3+1] = [expr 2*$PI/sqrt($eigenValue)]\" set eigenValue [lindex $eigenValues 4] puts \"T[expr 4+1] = [expr 2*$PI/sqrt($eigenValue)]\"\u003c/p\u003e # create a recorder to record eigenvalues at all free nodes recorder Node -file eigenvector.out -nodeRange 5 16 -dof 1 2 3 eigen 0 # record the results into the file record Results When you run this script, you should see the following printed to the screen:\nElasticRun.png ","tags":["Steel","Tcl"],"title":"Elastic Frame Example","uri":"/opensees-gallery/examples/steelbuilding2d/"},{"content":"Download (Elastic Response Spectra.ipynb)\nElastic Response Spectra April 2020, By Amir Hossein Namadchi This one deals with an elastic SDOF system subjected to the El Centro ground acceleration, $\\ddot{d_g}$. The aim is to obtain response spectra for the system with various damping values.\nThis notebook is adapted from https://github.com/AmirHosseinNamadchi/OpenSeesPy-Examples/blob/master/Elastic%20Response%20Spectra.ipynb\nimport numpy as np import opensees.openseespy as ops import matplotlib.pyplot as plt # Loading El Centro EQ data (North-south component) el_centro_raw = np.loadtxt('elCentro.txt') plt.figure(figsize=(15,3)) plt.plot(el_centro_raw[:,0], el_centro_raw[:,1], color='k') plt.ylabel('$\\ddot{d_g} (g)$', {'size':14}) plt.xlabel('Time (sec)', {'fontstyle':'italic','size':13}) plt.grid() plt.yticks(fontsize = 14) plt.xticks(fontsize = 14) plt.xlim([0.0, el_centro_raw[-1,0]]); Output:\n\u003cFigure size 1500x300 with 1 Axes\u003e Analysis # Define a period range below T_min = 0.00001 T_max = 5 dT = 0.05 # a list of damping ratios to be included zeta_list = np.array([0.02, 0.03, 0.05]) # Base units cm = 1.0 sec = 1.0 # Gravitational constant g = 981*cm/sec**2 The analyze_SDOF function performs numerical time integration of a damped elastic SDOF system subjected to the previously defined base excitation. Then, it returns the absolute maximum of response parameters as a dict. It should be reminded that, for a given ground motion, the response parameters of the SDOF system depends only on the natural period and its damping ratio, i.e. $T$ and $\\zeta$.\ndef analyze_SDOF(period, damping_ratio): # natural frequency omega = (2*np.pi)/period # stiffness k = omega**2 # Damping c = 2*damping_ratio*omega # Model Definition ops.wipe() ops.model('basic', '-ndm', 1, '-ndf', 1) ops.node(1, 0.0) ops.node(2, 0.0) ops.uniaxialMaterial('Elastic', 1, k) ops.element('zeroLength', 1, *[1, 2], '-mat', 1, '-dir', 1) # unit mass is assumed ops.mass(2, 1.0) ops.rayleigh(c, 0, 0, 0) ops.fix(1, 1) ## Loading dt = 0.02 ops.timeSeries('Path', 1, dt=dt, values=el_centro_raw[:,1]*g, time=el_centro_raw[:,0]) ops.pattern('UniformExcitation', 1, 1, '-accel', 1) ops.constraints('Transformation') ops.numberer('Plain') ops.system('ProfileSPD') ops.algorithm('Linear', False, False, True) ops.integrator('Newmark', 0.5, 0.25) ops.analysis('Transient') results = {'D':[],'V':[], 'A':[]} for i in range(len(el_centro_raw)): ops.analyze(1, dt) results['D'].append(ops.nodeDisp(2, 1)) results['V'].append(ops.nodeVel(2, 1)) results['A'].append(ops.nodeAccel(2, 1)) return {'SD': np.max(np.abs(results['D'])), 'SV': np.max(np.abs(results['V'])), 'SA': np.max(np.abs(results['A']))} Here, I use nested loops to analyse the system for various damping ratios and periods.\ndata_frame = dict() for z in zeta_list: # re-initialization resp = {'T':[0],'SD':[0], 'SV':[0], 'SA':[0]} for T in np.arange(T_min, T_max, dT): SR = analyze_SDOF(T, z) resp['SD'].append(SR['SD']) resp['SV'].append(SR['SV']) resp['SA'].append(SR['SA']) resp['T'].append(T) # Appending keys and values dynamically data_frame[z] = resp print('Done with zeta=', z,'!') Output:\nDone with zeta= 0.02 ! Done with zeta= 0.03 ! Done with zeta= 0.05 ! Visualization # Displacment ----------- plt.figure(figsize=(14,5)) for z in zeta_list: plt.plot(data_frame[z]['T'], data_frame[z]['SD'], label=('$\\zeta$ = '+str(z))) plt.ylabel('Displacement (cm)', {'fontstyle':'italic','size':14}) plt.xlabel('Period (sec)', {'fontstyle':'italic','size':14}) plt.legend() plt.grid() plt.yticks(fontsize = 14) plt.xticks(fontsize = 14) plt.title('Displacement Response Spectrum', {'fontstyle':'italic','size':18}); # Velocity ------------ plt.figure(figsize=(14,5)) for z in zeta_list: plt.plot(data_frame[z]['T'], data_frame[z]['SV'], label=('$\\zeta$ = '+str(z))) plt.ylabel('Velocity (cm/sec)', {'fontstyle':'italic','size':14}) plt.xlabel('Period (sec)', {'fontstyle':'italic','size':14}) plt.legend() plt.grid() plt.yticks(fontsize = 14) plt.xticks(fontsize = 14) plt.title('Veloctiy Response Spectrum', {'fontstyle':'italic','size':18}); # Acceleration ------------ plt.figure(figsize=(14,5)) for z in zeta_list: plt.plot(data_frame[z]['T'], np.array(data_frame[z]['SA'])/g, label=('$\\zeta$ = '+str(z))) plt.ylabel('Acceleration (g)', {'fontstyle':'italic','size':14}) plt.xlabel('Period (sec)', {'fontstyle':'italic','size':14}) plt.legend() plt.grid() plt.yticks(fontsize = 14) plt.xticks(fontsize = 14) plt.title('Acceleration Response Spectrum', {'fontstyle':'italic','size':18}); Output:\n\u003cFigure size 1400x500 with 1 Axes\u003e \u003cFigure size 1400x500 with 1 Axes\u003e \u003cFigure size 1400x500 with 1 Axes\u003e References Chopra, A.K., 2017. Dynamics of structures. theory and applications to. Earthquake Engineering. ","title":"Elastic Response Spectra","uri":"/opensees-gallery/examples/elasticspectra/"},{"content":"This example is adapted from https://github.com/denavit/OpenSees-Examples\n","title":"Euler buckling analysis","uri":"/opensees-gallery/examples/framebuckling/"},{"content":" This example demonstrates how to perform time history analysis of a 2D elastic reinforced concrete cantilever column with a gravity load included in the analysis. The column will be exposed only to horizontal component of ground motion. This example is a tutorial for the slightly modified example Ex1a.Canti2D.EQ.tcl (given in the examples manual) and is intended to help OpenSees beginners get started. Geometry of the cantilever column, node and element numbering are shown in the figure below.\n|- Instructions on how to run this example (for Windows users) To execute this ananlysis in OpenSees the user has to download these files:\nEx1a.Canti2D.EQ.modif.tcl A10000.tcl (ground-motion file) Place Ex1a.Canti2D.EQ.tcl and `A10000.tcl` file in the same folder with the OpenSees.exe. By double clicking on OpenSees.exe the OpenSees interpreter will pop out. To run the analysis the user should type: source Ex1a.Canti2D.EQ.modif.tcl and hit enter.\nCreate the model Before creating the model it is advised to call wipe command to destroy all previously constructed objects, i.e. all previously defined components of the model, all previously defined components of the analysis and all previously defined recorders.\nThe model of a structural system is created in the following way:\nSpatial dimension of the model (NDM) and number of degrees-of-freedom (DOF) at nodes are defined using model command.\nCoordinates of the nodes are defined using node command. At this point the user has to choose basic units (e.g., kip, in., sec) and remain consistent while creating the model. If dynamic (transient) analysis is performed nodal mass is assigned using either node or mass command. A mass has to be assigned to each degree of freedom. The boundary conditions are defined using using single-point constraint command fix. For nodes that have some fixity, constraints have to be defined at all degrees of freedom (0 if unconstrained (or free), 1 if constrained (or fixed)). Completely free nodes do not have to be defined. Before element is defined, the geometric transformation of the element has to be defined using geometric transformation command. This command transforms beam element stiffness and resisting force from the basic system to the global-coordinate system. Three types of geometric transformation are available in OpenSees: Linear Transformation, PDelta Transformation, and Corotational Transformation. In a 2D problem, element orientation does not need to be considered, and can be same for all elements. The elements are to be defined using one of the elements available in OpenSees. For the purpose of this example Elastic Beam Column Element will be used. Different types of elements require different additional commands for their definition. For the given example, steps from 1 to 6 are explained below. The link to command description is provided for each command so that a user can see the definition of all the arguments that the command invokes.\nFirst we have to define the model builder. The cantilever column is a 2D model with 3 DOFs at each node. Thus, spatial dimension of the model (ndm) is 2 and number of degrees-of-freedom (ndf) is 3. This is defined in the following way:\nmodel BasicBuilder -ndm 2 -ndf 3 The column has two nodes, labeled 1 and 2 (as shown in the Figure above). Node 1 has coordinates (0,0) and node 2 has coordinates (0,432) in the global coordinate system (x,y). The basic units chosen to build the model are: kip, in, sec. Note: y coordinate for node 2 is 36*12=432 in. Nodes are defined using the node command:\nnode 1 0. 0. node 2 0. 432. The cantilever column is constrained (fixed) at the node 1 in all three DOFs (two translational and one rotation). This boundary condition is defined with fix command.\nfix 1 1 1 1 Mass is assigned at node 2 using mass command. Since transient analysis is going to be performed for one component of ground motion (horizontal component - x direction) the mass is to be assigned in x direction. The mass is defined as Weight/g=2000/386=5.18. The vertical and rotational mass are set to zero.\nmass 2 5.18 0. 0. The geometric transformation with id tag 1 is defined to be linear.\ngeomTransf Linear 1 The column is defined to be elastic using elasticBeamColumn element. The element with the id tag 1 will connect nodes 1 and 2. Cross-sectional area of the element is (512)(5*12)=3600 in^2, Young’s modulus of elasticity is \\(51000*\\sqrt{4000}/1000=3225\\) ksi (assuming fc’=4000 psi), and the moment of inertia is \\((1/12)*(5*12)^4=1080000\\) in4.\nelement ElasticBeamColumn 1 1 2 3600 3225 1080000 1 Define recorders As a user you have an option of specifying the type of output that will be created following the analysis. The OpenSees recorder command is used to define the analysis output. This command is used to generate a recorder object for a specific type of response that is to be monitored during the analysis and its output.\nFor the considered cantilever column, the displacements of free node, support reactions, lateral drift, end element forces are recorded and stored as text files in “Data” folder.\nThe node recorder is used to output displacements of the free node (node 2) and support reaction of the constrained node (node 1) into files DFree.out and RBase.out, respectively. Both files will have a time stored in the first column. The columns 2-4 of file DFree.out will contain displacements at DOFs 1, 2, and 3. The columns 2-4 of file RBase.out will contain reactions that correspond to DOFs 1, 2, and 3.\nrecorder Node -file Data/DFree.out -time -node 2 -dof 1 2 3 disp recorder Node -file Data/RBase.out -time -node 1 -dof 1 2 3 reaction The drift recorder is used to output lateral drifts into file Drift.out. The first column of the file is the time, and the second column is the lateral drift (relative displacements between nodes 1 and 2).\nrecorder Drift -file Data/Drift.out -time -iNode 1 -jNode 2 -dof 1 -perpDirn 2 The element recorder is used to output global forces of the column into file FCol.out. The first column of the file is the time. The columns 2-7 of the file will contain end node forces (shear, axial, and bending moment); 3 forces at node 1 and 3 forces at node 2. These forces correspond to the global coordinate axes orientation.\nrecorder Element -file Data/FCol.out -time -ele 1 force How to apply the load in OpenSees? Applying load in OpenSees is a three-step process:\nLoads are defined using pattern command;\nAnalysis objects (constraint handler, DOF numberer, numerical solver, type of test for convergence, solution algorithm, integrator, and type of analysis to be performed) are defined next;\nThe loads are applied and the analysis is executed using analyze command.\nGravity load analysis In this example the gravity load is a substructure weight of 2000 kips. It will be applied at node 2 in 10 equal steps in increments of 200kips (0.1*2000). To apply the nodal load incrementally the linear time series with id tag 1 will be used.\ntimeSeries Linear 1 The time series will be assigned to the load pattern with id tag 1. Nodal load command will be used to create nodal load. It is a load at node 2 in negative Y direction of 2000 kips. The load value is a reference load value, it is the time series that provides the load factor. The load factor times the reference value is the load that is actually applied to the node in one time step of analysis.\npattern Plain 1 1 {load 2 0. -2000. 0. } The analysis objects are defined next. To construct Constraint Handler object the constraints command is used. The Constraint Handler object determines how the constraint equations (boundary conditions) are enforced in the analysis. In the case of cantilever column with a total fixity (all DOFs are constrained) at the node 1 plain constraints can be used.\nconstraints Plain DOF Numberer object, that determines the numbering of degrees of freedom (mapping between equation numbers and degrees-of-freedom) is defined next. Since the model is very simple and small plain numberer will be used:\n```tcl numberer Plain ``` To store and solve the system of equations during the analysis BandGeneral solver is used:\nsystem BandGeneral Since the column is elastic the system of equation can be solved in one iteration. Thus, the linear algorithm will be used to solve the system of equations.\nalgorithm Linear Since the analysis is static and specific load (2000 kips) is to be applied, load control integrator will be used in this example. The load factor increment (\\(\\lambda\\) is set to 0.1 since the full load of 2000 kips is to be applied in 10 analysis steps. For the nth step of analysis the load factor is \\(\\lambda_{n} = \\lambda_{n-1} + \\lambda\\) .\nintegrator LoadControl 0.1 The type of analysis is next defined using analysis command. The gravity load is a static type of the load and thus we have:\nanalysis Static With this all analysis objects are defined, so the analysis can be performed. It is performed by invoking the command analyze and by defining the number of analysis steps to be performed (10 for this example).\nanalyze 10 Since the transient analysis is going to be performed next, the gravity load has to be maintained constant for the remainder of the analysis and the time has to be restarted (set to 0.0) so that a time for a new time history can start from 0.0. The loadConst command is used for this.\nloadConst -time 0.0 The dynamic ground motion analysis The load pattern for a time history analysis has to be defined first. The load pattern consists of defining an acceleration record of a ground motion that will be applied at the support (node 1). The ground motion used for the analysis is acceleration record from Loma Prieta earthquake (LOMAP) at station CDMG 58373 APEEL 10 - Skyline1 component A10000. This acceleration record is provided at the beginning of this tutorial. The time interval between the points found in the record (dt) is 0.005 and number of data points found in the record (nPts) is 7990. The Path TimeSeries with id tag 2 is used to define the ground motion time series. The acceleration time history of the recorded ground motion is in units of \\(G\\) and it is thus factored with \\(G = 386\\) in2/sec. timeSeries Path 2 -dt 0.005 -filePath A10000.acc -factor $G The uniform exciatation pattern with id tag 2 will be used to apply this time series (with id tag 2) to a model in x direction (direction 1).\npattern UniformExcitation 2 1 -accel 2 Damping will be assigned to the model using rayleigh command. Rayleigh damping is mass and stiffness proportional. In OpenSees there are three different stiffness matrices available for use: the current stiffness matrix (at each iteration of a time step), the initial stiffness matrix, and the committed stiffness matrix (at the last committed step of analysis). For the linear elastic type of analysis the three matrices are identical. In this example damping is specified to be only stiffness proportional and equal to 2*(damping ratio)/(fundamental frequency). The fundamental frequency is calculated from the first eigenvalue. The damping ratio is set to 0.02.\nset freq [expr [eigen -fullGenLapack 1]**0.5] set dampRatio 0.02 rayleigh 0. 0. 0. [expr 2*$dampRatio/$freq] The dynamic ground motion analysis is transient type of analysis and therefore some of the analysis components have to be redefined. In order to define new analysis objects the previously defined analysis objects have to be destroyed. For this we will use wipeAnalysis command:\nwipeAnalysis The analysis objects that correspond to transient analysis are defined next. Constraint handler, DOF numberer, numerical solver, and algorithm will be the same as for the static (gravity) analysis.\nconstraints Plain numberer Plain system BandGeneral algorithm Linear The integrator and the analysis type are different. Numerical evaluation of the dynamic response will be performed using Newmark method of integration. The parameters \\(\\gamma\\) and \\(\\beta\\) will be set to 0.5 and 0.25, respectively. This choice of \\(\\gamma\\) and \\(\\beta\\) leads to constant average acceleration over a time step. The type of analysis is transient.\nintegrator Newmark 0.5 0.25 analysis Transient With this all analysis objects are defined, so the analysis can be performed. It is performed by invoking the command analyze and by defining the number of analysis steps to be performed and by defining the analysis increments. The number of analysis steps is set to 3995 (nPts/2) and the analysis increment is set to 0.01 (2*dt). Thus every second point in the record will be skipped during the analysis.\nanalyze 3995 0.01 Example Provided by: Vesna Terzic, UC Berkeley\n","tags":["2D","Frame"],"title":"Ex1: Time History Analysis of a 2D Elastic Cantilever Column","uri":"/opensees-gallery/examples/ex1/"},{"content":"Introduction This is a great example! To all the demonstrations that Example 3 has done, Example 4 adds the use of previously-defined Tcl procedures (a procedure is a Tcl command that is created by the proc command) or scripts. This example also introduces new kinds of static and dynamic analyses. Input Model Building The following tasks are performed when building the model define units define model define recorders for output define \u0026 apply gravity Elastic Element Files Ex4.Portal2D.build.ElasticElement.tcl LibUnits.tcl Notes Effective axial and flexural stiffnesses are defined at the element level elasticBeamColumn elements Distributed Plasticity Element, Uniaxial Section Files Ex4.Portal2D.build.InelasticSection.tcl LibUnits.tcl Notes Axial and flexural stiffnesses/strength are defined independently at the section level uniaxial inelastic section (moment-curvature) nonlinear beam-column elements Distributed Plasticity Element, Fiber Section Files Ex4.Portal2D.build.InelasticFiberSection.tcl LibUnits.tcl Notes The section is broken down into fibers where uniaxial materials are defined independently. The program calculates flexural and axial stiffnesses/strength by integrating strains across the section. fiber section nonlinear beam-column elements Lateral-Load Analysis The following tasks are performed in the analysis define lateral-load parameters analyze Static Static Pushover Files Ex4.Portal2D.analyze.Static.Push.tcl LibAnalysisStaticParameters.tcl Notes One-directional monotonic displacement-controlled static loading Static Reversed Cyclic Files Ex4.Portal2D.analyze.Static.Cycle.tcl LibAnalysisStaticParameters.tcl LibGeneratePeaks.tcl Notes One-directional displacement-controlled static loading Displacement cycles are imposed in positive and negative direction Dynamic EQ Ground Motion Dynamic Uniform Sine-Wave Ground Motion Files Ex4.Portal2D.analyze.Dynamic.sine.Uniform.tcl LibAnalysisDynamicParameters.tcl Notes Sine-wave acceleration input Same acceleration input at all nodes restrained in specified direction Dynamic Uniform Earthquake Ground Motion (typical) Files Ex4.Portal2D.analyze.Dynamic.EQ.Uniform.tcl LibAnalysisDynamicParameters.tcl ReadSMDFile.tcl H-E12140.AT2 Notes Earthquake (from file) acceleration input Same acceleration input at all nodes restrained in specified direction Dynamic Multiple-Support Sine-Wave Ground Motion Files Ex4.Portal2D.analyze.Dynamic.sine.multipleSupport.tcl (this file may need to be corrected for displacement input) LibAnalysisDynamicParameters.tcl Notes Sine-wave displacement input Different displacements are specified at particular nodes in specified directions Dynamic Multiple-Support Earthquake Ground Motion Files Ex4.Portal2D.analyze.Dynamic.EQ.multipleSupport.tcl (this file needs to be corrected for displacement input) LibAnalysisDynamicParameters.tcl ReadSMDFile.tcl H-E12140.DT2 (Displacement recording) Notes Earthquake (from file) displacement input Different displacements are specified at particular nodes in specified directions Dynamic Bidirectional Earthquake Ground Motion (typical) Files Ex4.Portal2D.analyze.Dynamic.EQ.bidirect.tcl LibAnalysisDynamicParameters.tcl ReadSMDFile.tcl (need to modify ReadSMDFile.tcl for displacement data) H-E12140.AT2 H-E01140.AT2 (acceleration recording in perpendicular direction) Notes Earthquake (from file) acceleration input Different ground motion in two directions Same acceleration input at all nodes restrained in specified direction Run The model and analysis combinations for this example are numerous. The following are an small subset, for demonstration purposes: To run Elastic Mode, Static Pushover Analysis: puts \" -------------Elastic Model -------------\" puts \" -------------Static Pushover Analysis -------------\" source Ex4.Portal2D.build.ElasticElement.tcl source Ex4.Portal2D.analyze.Static.Push.tcl To run Uniaxial Inelastic Section, Nonlinear Model, Uniform Earthquake Excitation puts \" -------------Uniaxial Inelastic Section, Nonlinear Model -------------\" puts \" -------------Uniform Earthquake Excitation -------------\" source Ex4.Portal2D.build.InelasticSection.tcl source Ex4.Portal2D.analyze.Dynamic.EQ.Uniform.tcl To run Uniaxial Inelastic Material, Fiber Section, Nonlinear Model, Dynamic Bidirectional Earthquake Ground Motion puts \" -------------Uniaxial Inelastic Material, Fiber Section, Nonlinear Model -------------\" puts \" -------------Dynamic Bidirectional Earthquake Ground Motion -------------\" source Ex4.Portal2D.build.InelasticFiberSection.tcl source Ex4.Portal2D.analyze.Dynamic.EQ.bidirect.tcl ","title":"Ex4 - Portal Frame","uri":"/opensees-gallery/examples/ex4/"},{"content":"Introduction This examples demonstrates how to build a 3-story,3-bay frame. The nodes and elements are specified one by one. Input Model Building The following tasks are performed when building the model define units define model define recorders for output define \u0026 apply gravity Card title This is a wider card with supporting text below as a natural lead-in to additional content. This content is a little bit longer.\nLast updated 3 mins ago\nCard title This is a wider card with supporting text below as a natural lead-in to additional content. This content is a little bit longer.\nLast updated 3 mins ago\nElastic Element Files Ex5.Frame2D.build.ElasticSection.tcl LibUnits.tcl Notes Effective axial and flexural stiffnesses are defined at the element level elasticBeamColumn elements Distributed Plasticity Element, Uniaxial Section Files Ex5.Frame2D.build.InelasticSection.tcl LibUnits.tcl Notes Axial and flexural stiffnesses/strength are defined independently at the section level uniaxial inelastic section (moment-curvature) nonlinear beam-column elements Distributed Plasticity Element, Fiber Section FiberSection -- Standard AISC W-Section Files Ex5.Frame2D.build.InelasticFiberWSection.tcl LibUnits.tcl Wsection.tcl Notes The section is broken down into fibers where uniaxial materials are defined independently. The program calculates flexural and axial stiffnesses/strength by integrating strains across the section. Standard AISC W-section FiberSection -- Reinforced Concrete Section Files Ex5.Frame2D.build.InelasticFiberRCSection.tcl LibUnits.tcl LibMaterialsRC.tcl BuildRCrectSection.tcl Notes The section is broken down into fibers where uniaxial materials are defined independently. The program calculates flexural and axial stiffnesses/strength by integrating strains across the section. Rectangular Reinforced-Concrete Section Lateral-Load Analysis The following tasks are performed in the analysis define lateral-load parameters analyze Static Static Pushover Files Ex5.Frame2D.analyze.Static.Push.tcl LibAnalysisStaticParameters.tcl Notes One-directional monotonic displacement-controlled static loading Static Reversed Cyclic Files Ex5.Frame2D.analyze.Static.Cycle.tcl LibAnalysisStaticParameters.tcl LibGeneratePeaks.tcl Notes One-directional displacement-controlled static loading Displacement cycles are imposed in positive and negative direction Dynamic EQ Ground Motion Dynamic Uniform Sine-Wave Ground Motion Files Ex5.Frame2D.analyze.Dynamic.sine.Uniform.tcl LibAnalysisDynamicParameters.tcl Notes Sine-wave acceleration input Same acceleration input at all nodes restrained in specified direction Dynamic Uniform Earthquake Ground Motion (typical) Files Ex5.Frame2D.analyze.Dynamic.EQ.Uniform.tcl LibAnalysisDynamicParameters.tcl ReadSMDFile.tcl H-E12140.AT2 Notes Earthquake (from file) acceleration input Same acceleration input at all nodes restrained in specified direction Dynamic Multiple-Support Sine-Wave Ground Motion Files Ex5.Frame2D.analyze.Dynamic.sine.multipleSupport.tcl (this file may need to be corrected for displacement input) LibAnalysisDynamicParameters.tcl Notes Sine-wave displacement input Different displacements are specified at particular nodes in specified directions Dynamic Multiple-Support Earthquake Ground Motion Files Ex5.Frame2D.analyze.Dynamic.EQ.multipleSupport.tcl (this file needs to be corrected for displacement input) LibAnalysisDynamicParameters.tcl ReadSMDFile.tcl H-E12140.DT2 (Displacement recording) Notes Earthquake (from file) displacement input Different displacements are specified at particular nodes in specified directions Dynamic Bidirectional Earthquake Ground Motion (typical) Files Ex5.Frame2D.analyze.Dynamic.EQ.bidirect.tcl LibAnalysisDynamicParameters.tcl ReadSMDFile.tcl (need to modify ReadSMDFile.tcl for displacement data) H-E12140.AT2 H-E01140.AT2 (acceleration recording in perpendicular direction) Notes Earthquake (from file) acceleration input Different ground motion in two directions Same acceleration input at all nodes restrained in specified direction Run The model and analysis combinations for this example are numerous. The following are an small subset, for demonstration purposes: To run Elastic Mode, Static Pushover Analysis: puts \" -------------Elastic Model -------------\" puts \" -------------Static Pushover Analysis -------------\" source Ex5.Frame2D.build.ElasticSection.tcl source Ex5.Frame2D.analyze.Static.Push.tcl To run Uniaxial Inelastic Section, Nonlinear Model, Uniform Earthquake Excitation puts \" -------------Uniaxial Inelastic Section, Nonlinear Model -------------\" puts \" -------------Uniform Earthquake Excitation -------------\" source Ex5.Frame2D.build.InelasticSection.tcl source Ex5.Frame2D.analyze.Dynamic.EQ.Uniform.tcl To run Uniaxial Inelastic Material, Fiber Section, Nonlinear Model, Dynamic Bidirectional Earthquake Ground Motion puts \" -------------Uniaxial Inelastic Material, Fiber Section, Nonlinear Model -------------\" puts \" -------------Dynamic Bidirectional Earthquake Ground Motion -------------\" source Ex5.Frame2D.build.InelasticFiberSection.tcl source Ex5.Frame2D.analyze.Dynamic.EQ.bidirect.tcl Notes Return to OpenSees Examples Manual -- Structural Models \u0026 Analyses Return to OpenSees User ","title":"Ex5 - 2D Frame, 3-story 3-bay, Reinforced-Concrete Section \u0026 Steel W-Section","uri":"/opensees-gallery/examples/ex5/"},{"content":"The first example is a simple truss structure. The purpose of this example is to show that model generation in OpenSees can resemble typical finite element analysis programs with the definition of nodes, materials, elements, loads and constraints. The example also demonstrates how an analysis object is ‘built’ from component objects.\nExample 1.1 – Linear elasticity This example is of a linear-elastic three bar truss, as shown in the figure below, subject to static loads.\nExample1.1.tcl Example1.1.py The model consists of four nodes, three truss elements, a single load pattern with a nodal load acting at node 4, and constraints at the three support nodes. Since the truss elements have the same elastic material, a single Elastic material object is created.\n# Create nodes \u0026 add to Domain - command: node nodeId xCrd yCrd node 1 0.0 0.0 node 2 144.0 0.0 node 3 168.0 0.0 node 4 72.0 96.0 # Set the boundary conditions - command: fix nodeID xResrnt? yRestrnt? fix 1 1 1 fix 2 1 1 fix 3 1 1 Next the materials are defined:\n# Create Elastic material prototype - command: uniaxialMaterial Elastic matID E uniaxialMaterial Elastic 1 3000 section Elastic 1 3000 5.0 10000 Finally, define the elements:\nelement $eleType 1 1 4 10.0 1 element $eleType 2 2 4 5.0 1 element $eleType 3 3 4 1 The model is linear, so we use a solution Algorithm of type Linear.\nPython Tcl model.algorithm(\"Linear\") algorithm Linear Even though the solution is linear, we have to select a procedure for applying the load, which is called an Integrator. For this problem, a LoadControl integrator advances the solution.\nThe equations are formed using a banded system, so the System is BandSPD (banded, symmetric positive definite). This is a good choice for most moderate size models. The equations have to be numbered, so typically an RCM numberer object is used (for Reverse Cuthill-McKee). The constraints are most easily represented with a Plain constraint handler.\nOnce all the components of an analysis are defined, the Analysis object itself is created. For this problem a Static Analysis object is used.\nWhen the analysis is complete the state of node 4 and all three elements will be printed to the screen. Nothing is recorded for later use.\nThe Tcl script for the example is shown below. A comment is indicated by a # symbol. In the comments below, the syntax for important commands are given.\nTcl source # OpenSees Example 1.1 # OpenSees Primer # # Units: kips, in, sec # ------------------------------ # Start of model generation # ------------------------------ # Create ModelBuilder (with two-dimensions and 2 DOF/node) model BasicBuilder -ndm 2 -ndf 2 # Create nodes # ------------ # Create nodes \u0026 add to Domain - command: node nodeId xCrd yCrd node 1 0.0 0.0 node 2 144.0 0.0 node 3 168.0 0.0 node 4 72.0 96.0 # Set the boundary conditions - command: fix nodeID xResrnt? yRestrnt? fix 1 1 1 fix 2 1 1 fix 3 1 1 # Define materials for truss elements # ----------------------------------- # Create Elastic material prototype - command: uniaxialMaterial Elastic matID E uniaxialMaterial Elastic 1 3000 # Define elements # --------------- # Create truss elements - command: element truss trussID node1 node2 A matID element truss 1 1 4 10.0 1 element truss 2 2 4 5.0 1 element truss 3 3 4 5.0 1 # Define loads # ------------ # Create a Plain load pattern with a linear TimeSeries pattern Plain 1 \"Linear\" { # Create the nodal load - command: load nodeID xForce yForce load 4 100 -50 } # End of model generation # ------------------------------ # ------------------------------ # Start of analysis generation # ------------------------------ # Create the system of equation, a SPD using a band storage scheme system BandSPD # Create the DOF numberer, the reverse Cuthill-McKee algorithm numberer RCM # Create the constraint handler, a Plain handler is used as homo constraints constraints Plain # Create the integration scheme, the LoadControl scheme using steps of 1.0 integrator LoadControl 1.0 # Create the solution algorithm, a Linear algorithm is created algorithm Linear # create the analysis object analysis Static # End of analysis generation # ------------------------------ # ------------------------------ # Start of recorder generation # ------------------------------ # create a Recorder object for the nodal displacements at node 4 recorder Node -file example.out -load -node 4 -dof 1 2 disp # -------------------------------- # End of recorder generation # --------------------------------- # ------------------------------ # Finally perform the analysis # ------------------------------ # Perform the analysis analyze 1 # Print the current state at node 4 and at all elements print node 4 print ele Node: 4 Coordinates : 72 96 commitDisps: 0.530093 -0.177894 unbalanced Load: 100 -50 Element: 1 type: Truss iNode: 1 jNode: 4 Area: 10 Total Mass: 0 strain: 0.00146451 axial load: 43.9352 unbalanced load: -26.3611 -35.1482 26.3611 35.1482 Material: Elastic tag: 1 E: 3000 eta: 0 Element: 2 type: Truss iNode: 2 jNode: 4 Area: 5 Total Mass: 0 strain: -0.00383642 axial load: -57.5463 unbalanced load: -34.5278 46.0371 34.5278 -46.0371 Material: Elastic tag: 1 E: 3000 eta: 0 Element: 3 type: Truss iNode: 3 jNode: 4 Area: 5 Total Mass: 0 strain: -0.00368743 axial load: -55.3114 unbalanced load: -39.1111 39.1111 39.1111 -39.1111 Material: Elastic tag: 1 E: 3000 eta: 0 For the node, displacements and loads are given. For the truss elements, the axial strain and force are provided along with the resisting forces in the global coordinate system.\nThe file example.out, specified in the recorder command, provides the nodal displacements for the x and y directions of node 4. The file consists of a single line of code:\n1.0 0.530093 -0.177894 The $1.0$ corresponds to the load factor (pseudo time) in the model at which point the recorder was invoked. The $0.530093$ and $-0.177894$ correspond to the response at node $4$ for the 1 and 2 degree-of-freedom. Note that if more analysis steps had been peformed, the line would contain a line for every analysis step that completed successfully.\n","tags":["Truss","Python","Tcl"],"title":"Example 1: Simple Truss","uri":"/opensees-gallery/examples/example1/"},{"categories":["Basic"],"content":"This example covers the moment-curvature analysis of a reinforced concrete section. The zero-length element with a fiber discretization of the cross section is used in the model. In addition, Tcl language features such as variable and command substitution, expression evaluation, and procedures are demonstrated.\nExample 2.1 In this example, a moment-curvature analysis of the fiber section is undertaken. The figure below shows the fiber discretization for the section.\nExample2.1.tcl\nMomentCurvature.tcl\nOr, for Python:\nExample2.1.py The model consists of two nodes and a ZeroLengthSection element. A depiction of the element geometry is shown in figure zerolength. The drawing on the left of figure zerolength shows an edge view of the element where the local z-axis, as seen on the right side of the figure and in figure rcsection0, is coming out of the page. Node 1 is completely restrained, while the applied loads act on node 2. A compressive axial load, \\(P\\), of 180 kips is applied to the section during the moment-curvature analysis.\nNote in Python you must pass the section tag when calling patch and layer\nPython Tcl model.section(\"Fiber\", 1) # Create the concrete core fibers model.patch(\"rect\", 1, 10, 1, cover-y1, cover-z1, y1-cover, z1-cover, section=1) # Create the concrete cover fibers (top, bottom, left, right, section=1) model.patch(\"rect\", 2, 10, 1, -y1, z1-cover, y1, z1, section=1) model.patch(\"rect\", 2, 10, 1, -y1, -z1, y1, cover-z1, section=1) model.patch(\"rect\", 2, 2, 1, -y1, cover-z1, cover-y1, z1-cover, section=1) model.patch(\"rect\", 2, 2, 1, y1-cover, cover-z1, y1, z1-cover, section=1) # Create the reinforcing fibers (left, middle, right, section=1) model.layer(\"straight\", 3, 3, As, y1-cover, z1-cover, y1-cover, cover-z1, section=1) model.layer(\"straight\", 3, 2, As, 0.0, z1-cover, 0.0, cover-z1, section=1) model.layer(\"straight\", 3, 3, As, cover-y1, z1-cover, cover-y1, cover-z1, section=1) section Fiber 1 { # Create the concrete core fibers patch rect 1 10 1 [expr $cover-$y1] [expr $cover-$z1] [expr $y1-$cover] [expr $z1-$cover] # Create the concrete cover fibers (top, bottom, left, right) patch rect 2 10 1 [expr -$y1] [expr $z1-$cover] $y1 $z1 patch rect 2 10 1 [expr -$y1] [expr -$z1] $y1 [expr $cover-$z1] patch rect 2 2 1 [expr -$y1] [expr $cover-$z1] [expr $cover-$y1] [expr $z1-$cover] patch rect 2 2 1 [expr $y1-$cover] [expr $cover-$z1] $y1 [expr $z1-$cover] # Create the reinforcing fibers (left, middle, right) layer straight 3 3 $As [expr $y1-$cover] [expr $z1-$cover] [expr $y1-$cover] [expr $cover-$z1] layer straight 3 2 $As 0.0 [expr $z1-$cover] 0.0 [expr $cover-$z1] layer straight 3 3 $As [expr $cover-$y1] [expr $z1-$cover] [expr $cover-$y1] [expr $cover-$z1] } For the zero length element, a section discretized by concrete and steel is created to represent the resultant behavior. UniaxialMaterial objects are created to define the fiber stress-strain relationships: confined concrete in the column core, unconfined concrete in the column cover, and reinforcing steel.\nThe dimensions of the fiber section are shown in figure rcsection0. The section depth is 24 inches, the width is 15 inches, and there are 1.5 inches of cover around the entire section. Strong axis bending is about the section z-axis. In fact, the section z-axis is the strong axis of bending for all fiber sections in planar problems. The section is separated into confined and unconfined concrete regions, for which separate fiber discretizations will be generated. Reinforcing steel bars will be placed around the boundary of the confined and unconfined regions. The fiber discretization for the section is shown in figure rcsection4.\n{#fig:rcsection0} {#fig:rcsection4}\nThe section analysis is performed by the Tcl procedure MomentCurvature defined in the file MomentCurvature.tcl. The arguments to the procedure are the tag of the section to be analyzed, the axial load applied to the section, the maximum curvature, and the number of displacement increments to reach the maximum curvature.\nThe output for the moment-curvature analysis will be the section forces and deformations, stored in the file section1.out. In addition, an estimate of the section yield curvature is printed to the screen.\n# OpenSees Example 2.1 # OpenSees Primer # # Units: kips, in, sec # Define model builder # -------------------- model BasicBuilder -ndm 2 -ndf 3 # Define materials for nonlinear columns # ------------------------------------------ # CONCRETE tag f'c ec0 f'cu ecu # Core concrete (confined) uniaxialMaterial Concrete01 1 -6.0 -0.004 -5.0 -0.014 # Cover concrete (unconfined) uniaxialMaterial Concrete01 2 -5.0 -0.002 0.0 -0.006 # STEEL # Reinforcing steel set fy 60.0; # Yield stress set E 30000.0; # Young's modulus # tag fy E0 b uniaxialMaterial Steel01 3 $fy $E 0.01 # Define cross-section for nonlinear columns # ------------------------------------------ # set some parameters set colWidth 15 set colDepth 24 set cover 1.5 set As 0.60; # area of no. 7 bars # some variables derived from the parameters set y1 [expr $colDepth/2.0] set z1 [expr $colWidth/2.0] section Fiber 1 { # Create the concrete core fibers patch rect 1 10 1 [expr $cover-$y1] [expr $cover-$z1] [expr $y1-$cover] [expr $z1-$cover] # Create the concrete cover fibers (top, bottom, left, right) patch rect 2 10 1 [expr -$y1] [expr $z1-$cover] $y1 $z1 patch rect 2 10 1 [expr -$y1] [expr -$z1] $y1 [expr $cover-$z1] patch rect 2 2 1 [expr -$y1] [expr $cover-$z1] [expr $cover-$y1] [expr $z1-$cover] patch rect 2 2 1 [expr $y1-$cover] [expr $cover-$z1] $y1 [expr $z1-$cover] # Create the reinforcing fibers (left, middle, right) layer straight 3 3 $As [expr $y1-$cover] [expr $z1-$cover] [expr $y1-$cover] [expr $cover-$z1] layer straight 3 2 $As 0.0 [expr $z1-$cover] 0.0 [expr $cover-$z1] layer straight 3 3 $As [expr $cover-$y1] [expr $z1-$cover] [expr $cover-$y1] [expr $cover-$z1] } # Estimate yield curvature # (Assuming no axial load and only top and bottom steel) set d [expr $colDepth-$cover] ;# d -- from cover to rebar set epsy [expr $fy/$E] ;# steel yield strain set Ky [expr $epsy/(0.7*$d)] # Print estimate to standard output puts \"Estimated yield curvature: $Ky\" # Set axial load set P -180 set mu 15; # Target ductility for analysis set numIncr 100; # Number of analysis increments # Call the section analysis procedure source MomentCurvature.tcl MomentCurvature 1 $P [expr $Ky*$mu] $numIncr The Tcl procedure to perform the moment-curvature analysis follows. In this procedure, the nodes are defined to be at the same geometric location and the ZeroLengthSection element is used. A single load step is performed for the axial load, then the integrator is changed to DisplacementControl to impose nodal displacements, which map directly to section deformations. A reference moment of 1.0 is defined in a Linear time series. For this reference moment, the DisplacementControl integrator will determine the load factor needed to apply the imposed displacement. A node recorder is defined to track the moment-curvature results. The load factor is the moment, and the nodal rotation is in fact the curvature of the element with zero thickness.\nThe expected output is:\nEstimated yield curvature: 0.000126984126984 The file section1.out contains for each committed state a line with the load factor and the rotation at node 3. This can be used to plot the moment-curvature relationship as shown in figure momcurv.\n","tags":["Fiber","Concrete","Python","Tcl"],"title":"Example 2: Moment-Curvature","uri":"/opensees-gallery/examples/example2/"},{"categories":["Basic"],"content":"\nThis set of examples covers the nonlinear analysis of a reinforced concrete frame. The nonlinear beam column element with a fiber discretization of the cross section is used in the model. In addition,\nThis example is of a reinforced concrete portal frame, as shown in the figure below, subject to gravity loads.\nExample3.1.tcl A nonlinear model of the portal frame shown in the figure below is created. The model consists of four nodes, two nonlinear beam-column elements, 1 and 2, to model the columns and an elastic beam element, 3, to model the beam. For the column elements a section, identical to the section used in Example 2, is created using steel and concrete fibers.\n3.1 - gravity_analysis A single load pattern with a linear time series, two vertical nodal loads acting at nodes 3 and 4, and single point constraints to constrain nodes 1 and 2 are created.\nThe model contains material non-linearities, so a solution algorithm of type Newton is used. The solution algorithm uses a ConvergenceTest which tests convergence of the equilibrium solution with the norm of the displacement increment vector. For this nonlinear problem, the gravity loads are applied incrementally until the full load is applied. To achieve this, a LoadControl integrator which advances the solution with an increment of 0.1 at each load step is used. The equations are formed using a banded storage scheme, so the System is BandGeneral. The equations are numbered using an RCM (reverse Cuthill-McKee) numberer. The constraints are enforced with a Plain constraint handler.\nOnce all the components of an analysis are defined, the Analysis object itself is created. For this problem a Static Analysis object is used. To achieve the full gravity load, 10 load steps are performed.\nAt end of analysis, the state at nodes 3 and 4 is output. The state of element 1 is also output.\nFor the two nodes, displacements and loads are given. For the beam-column elements, the element end forces in the local system are provided.\nThe nodeGravity.out file contains ten lines, each line containing 7 entries. The first entry is time in the domain at end of the load step. The next 3 entries are the displacements at node 3, and the final 3 entries the displacements at node 4.\n3.2 - pushover_analysis In this example the nonlinear reinforced concrete portal frame which has undergone the gravity load analysis of Example 3.1 is now subjected to a pushover analysis.\nExample3.2.tcl\nExample3.1.tcl\nAfter performing the gravity load analysis on the model, the time in the domain is reset to 0.0 and the current value of all loads acting are held constant. A new load pattern with a linear time series and horizontal loads acting at nodes 3 and 4 is then added to the model.\nThe static analysis used to perform the gravity load analysis is modified to take a new DisplacementControl integrator. At each new step in the analysis the integrator will determine the load increment necessary to increment the horizontal displacement at node 3 by 0.1 in. 60 analysis steps are performed in this new analysis.\nFor this analysis the nodal displacements at nodes 3 and 4 will be stored in the file nodePushover.out for post-processing. In addition, the end forces in the local coordinate system for elements 1 and 2 will be stored in the file elePushover.out. At the end of the analysis, the state of node 3 is printed to the screen.\nIn addition to what is displayed on the screen, the file node32.out and ele32.out have been created by the script. Each line of node32.out contains the time, DX, DY and RZ for node 3 and DX, DY and RZ for node 4 at the end of an iteration. Each line of eleForce.out contains the time, and the element end forces in the local coordinate system. A plot of the load-displacement relationship at node 3 is shown in the figure below.\n3.3 - Transient Analysis In this example the reinforced concrete portal frame which has undergone the gravity load analysis of Example 3.1 is now subjected to a uniform earthquake excitation.\nExample3.3.tcl\nExample3.1.tcl\nReadSMDFile.tcl\nAfter performing the gravity load analysis, the time in the domain is reset to 0.0 and the current value of all active loads is set to constant. Mass terms are added to nodes 3 and 4. A new uniform excitation load pattern is created. The excitation acts in the horizontal direction and reads the acceleration record and time interval from the file ARL360.g3. The file ARL360.g3 is created from the PEER Strong Motion Database (http://peer.berkeley.edu/smcat/) record ARL360.at2 using the Tcl procedure ReadSMDFile contained in the file ReadSMDFile.tcl.\nThe static analysis object and its components are first deleted so that a new transient analysis object can be created.\nA new solution Algorithm of type Newton is then created. The solution algorithm uses a ConvergenceTest which tests convergence on the norm of the displacement increment vector. The integrator for this analysis will be of type Newmark with a \\(\\gamma = 0.25\\) and \\(\\beta = 0.5\\).\nThe integrator will add some stiffness proportional damping to the system, the damping term will be based on the last committed stifness of the elements, i.e. \\(C = a_c K_{\\text{commit}}\\) with \\(a_c = 0.000625\\).\nThe equations are formed using a banded storage scheme, so the System is BandGeneral. The equations are numbered using an RCM (reverse Cuthill-McKee) numberer. The constraints are enforced with a Plain constraint handler.\nOnce all the components of an analysis are defined, the Analysis object itself is created. For this problem a Transient Analysis object is used. 2000 time steps are performed with a time step of 0.01.\nIn addition to the transient analysis, two eigenvalue analysis are performed on the model. The first is performed after the gravity analysis and the second after the transient analysis.\nFor this analysis the nodal displacenments at Nodes 3 and 4 will be stored in the file nodeTransient.out for post-processing. In addition the section forces and deformations for the section at the base of column 1 will also be stored in two seperate files. The results of the eigenvalue analysis will be displayed on the screen.\nGravity load analysis completed eigen values at start of transient: 2.695422e+02 1.750711e+04 Transient analysis completed SUCCESSFULLY eigen values at start of transient: 1.578616e+02 1.658481e+04 Node: 3 Coordinates : 0 144 commitDisps: -0.0464287 -0.0246641 0.000196066 Velocities : -0.733071 1.86329e-05 0.00467983 commitAccels: -9.13525 0.277302 38.2972 unbalanced Load: -3.9475 -180 0 Mass : 0.465839 0 0 0 0.465839 0 0 0 0 Eigenvectors: -1.03587 -0.0482103 -0.00179081 0.00612275 0.00663473 3.21404e-05 The two eigenvalues for the eigenvalue analysis are printed to the screen. The state of node 3 at the end of the analysis is also printed. The information contains the last committed displacements, velocities and accelerations at the node, the unbalanced nodal forces and the nodal masses. In addition, the eigenvector components of the eigenvector pertaining to the node 3 is also displayed.\nIn addition to the contents displayed on the screen, three files have been created. Each line of nodeTransient.out contains the domain time, and DX, DY and RZ for node 3. Plotting the first and second columns of this file the lateral displacement versus time for node 3 can be obtained as shown in the figure below. Each line of the files ele1secForce.out and ele1secDef.out contain the domain time and the forces and deformations for section 1 (the base section) of element 1. These can be used to generate the moment-curvature time history of the base section of column 1 as shown below.\n","description":"Nonlinear analysis of a concrete portal frame.","tags":["Frame","Python","Tcl","Concrete"],"title":"Example 3: Portal Frame Examples","uri":"/opensees-gallery/examples/example3/"},{"categories":["Basic"],"content":"In this example variables and control structures are demonstrated.\nExample 4.1 This example is of a reinforced concrete multibay two story frame, as shown in Figure 1, subject to gravity loads.\nExample4.1.tcl A model of the frame shown in Figure 1 is created. The number of objects in the model is dependent on the parameter numBay. The (numBay + 1)*3 nodes are created, one column line at a time, with the node at the base of the columns fixed in all directions. Three materials are constructed, one for the concrete core, one for the concrete cover and one for the reinforcement steel. Three fiber discretized sections are then built, one for the exterior columns, one for the interior columns and one for the girders. Each of the members in the frame is modelled using nonlinear beam-column elements with 4 (nP) integration points and a linear geometric transformation object.\nFor gravity loads, a single load pattern with a linear time series and two vertical nodal loads acting at the first and second floor nodes of each column line is used. The load at the lower level is twice that of the upper level and the load on the interior columns is twice that of the exterior columns.\nFor the lateral load analysis, a second load pattern with a linear time series is introduced after the gravity load analysis. Associated with this load pattern are two nodal loads acting on nodes 2 and 3, with the load level at node 3 twice that acting at node 2.\nA solution Algorithm of type Newton is created. The solution algorithm uses a ConvergenceTest based on the norm of the displacement increment vector. The integrator for the analysis will be LoadControl with a load step increment of 0.1. The storage for the system of equations is BandGeneral. The equations are numbered using an RCM (reverse Cuthill-McKee) numberer. The constraints are enforced with a Plain constraint handler. Once the components of the analysis have been defined, the analysis object is then created. For this problem a Static analysis object is used and 10 steps are performed to load the model with the desired gravity load.\nAfter the gravity load analysis has been performed, the gravity loads are set to constant and the time in the domain is reset to 0.0. A new LoadControl integrator is now added. The new LoadControl integrator has an initial load step of 1.0, but this can vary between 0.02 and 2.0 depending on the number of iterations required to achieve convergence at each load step. 100 steps are then performed.\nFor the pushover analysis the lateral displacements at nodes 2 and 3 will be stored in the file Node41.out for post-processing. In addition, if the variable displayMode is set to “displayON” the load-displacement curve for horizontal displacements at node 3 will be displayed in a window on the user’s terminal.\nThe output consists of the file Node41.out containing a line for each step of the lateral load analysis. Each line contains the load factor, the lateral displacements at nodes 2 and 3. A plot of the load-displacement curve for the frame is given in Figure 2.\n","tags":["Frame","2D","Tcl","Python"],"title":"Example 4: Multibay Two Story Frame","uri":"/opensees-gallery/examples/example4/"},{"categories":["Basic"],"content":"Example 5.1 A three-dimensional reinforced concrete rigid frame, is subjected to bi-directional earthquake ground motion.\nExample5.1.tcl RCsection.tcl Or for Python:\nExample5.1.py RCsection.py In both cases, the following ground motion records are required: 3. tabasFN.txt 4. tabasFP.txt\nA model of the rigid frame shown in the figure below is created. The model consists of three stories and one bay in each direction. Rigid diaphragm multi-point constraints are used to enforce the rigid in-plane stiffness assumption for the floors. Gravity loads are applied to the structure and the 1978 Tabas acceleration records are the uniform earthquake excitations.\nNonlinear beam column elements are used for all members in the structure. The beam sections are elastic while the column sections are discretized by fibers of concrete and steel. Elastic beam column elements may have been used for the beam members; but, it is useful to see that section models other than fiber sections may be used in the nonlinear beam column element.\nA solution Algorithm of type Newton is used for the nonlinear problem. The solution algorithm uses a ConvergenceTest which tests convergence on the norm of the energy increment vector. The integrator for this analysis will be of type Newmark with a $\\gamma$ of 0.25 and a $\\beta$ of 0.5. Due to the presence of the multi-point constraints, a Transformation constraint handler is used. The equations are formed using a sparse storage scheme which will perform pivoting during the equation solving, so the System is SparseGeneral. As SparseGeneral will perform it’s own internal numbering of the equations, a Plain numberer is used which simply assigns equation numbers to the degrees-of-freedom.\nOnce all the components of an analysis are defined, the Analysis object itself is created. For this problem a Transient Analysis object is used. 2000 steps are performed with a time step of 0.01.\nThe nodal displacements at nodes 9, 14, and 19 (the retained nodes for the rigid diaphragms) will be stored in the file node51.out for post-processing.\nThe results consist of the file node.out, which contains a line for every time step. Each line contains the time and the horizontal and vertical displacements at the diaphragm retained nodes (9, 14 and 19) i.e. time Dx9 Dy9 Dx14 Dy14 Dx19 Dy19. The horizontal displacement time history of the first floor diaphragm node 9 is shown in figure [example4disp{reference-type=“ref” reference=“example4disp”}. Notice the increase in period after about 10 seconds of earthquake excitation, when the large pulse in the ground motion propogates through the structure. The displacement profile over the three stories shows a soft-story mechanism has formed in the first floor columns. The numerical solution converges even though the drift is $\\approx 20 \\%$. The inclusion of P-Delta effects shows structural collapse under such large drifts.\n","description":"A three-dimensional reinforced concrete rigid frame,\nis subjected to bi-directional earthquake ground motion.\n","tags":["3D","Concrete","Frame","Python","Tcl","Dynamic"],"title":"Example 5: Rigid 3D Frame","uri":"/opensees-gallery/examples/example5/"},{"categories":["Basic"],"content":"In this example a simple problem in solid dynamics is considered. The structure is a simply supported beam modelled with two dimensional solid elements.\nExample6.1.tcl Example6.1.py For two dimensional analysis, a typical solid element is defined as a volume in two dimensional space. Each node of the analysis has two displacement degrees of freedom. Thus the model is defined with ndm := 2 and ndf := 2.\nFor this model, a mesh is generated using the block2D command. The number of nodes in the local \\(x\\)-direction of the block is $nx$ and the number of nodes in the local \\(y\\)-direction of the block is $ny$. The block2D generation nodes {1,2,3,4} are prescribed to define the two dimensional domain of the beam, which is of size \\(40\\times10\\).\nThree possible quadrilateral elements can be used for the analysis. These may be created using the terms \"BbarQuad\", \"EnhancedQuad\" or \"Quad\". This is a plane strain problem. An elastic isotropic material is used.\nFor initial gravity load analysis, a single load pattern with a linear time series and two vertical nodal loads are used.\nA solution algorithm of type Newton is used for the problem. The solution algorithm uses a ConvergenceTest which tests convergence on the norm of the energy increment vector. Ten static load steps are performed.\nSubsequent to the static analysis, the wipeAnalysis and remove loadPatern commands are used to remove the nodal loads and create a new analysis. The nodal displacements have not changed. However, with the external loads removed the structure is no longer in static equilibrium.\nThe integrator for the dynamic analysis if of type GeneralizedMidpoint with \\(\\alpha = 0.5\\). This choice is uconditionally stable and energy conserving for linear problems. Additionally, this integrator conserves linear and angular momentum for both linear and non-linear problems. The dynamic analysis is performed using \\(100\\) time increments with a time step \\(\\Delta t = 0.50\\).\nThe results consist of the file Node.out, which contains a line for every time step. Each line contains the time and the vertical displacement at the bottom center of the beam. The time history is shown in Figure 1.\n","tags":["Plane","Python","Tcl"],"title":"Example 6: Simply Supported Beam","uri":"/opensees-gallery/examples/example6/"},{"categories":["Basic"],"content":"In this example a simple problem in shell dynamics is considered. The structure is a curved hoop shell structure that looks like the roof of a Safeway.\nExample7.1.tcl For shell analysis, a typical shell element is defined as a surface in three dimensional space. Each node of a shell analysis has six degrees of freedom, three displacements and three rotations. Thus the model is defined with $ndm := 3$ and $ndf := 6$.\nFor this model, a mesh is generated using the “block2D” command. The number of nodes in the local x-direction of the block is nx and the number of nodes in the local y-direction of the block is ny. The block2D generation nodes {1,2,3,4, 5,7,9} are defined such that the structure is curved in three dimensional space.\nThe OpenSees shell element is constructed using the command ShellMITC4. An elastic membrane-plate material section model, appropriate for shell analysis, is constructed using the “ElasticMembranePlateSection” command. In this case, the elastic modulus \\(E := 3.0e3\\), Poisson’s ratio \\(\\nu := 0.25\\), the thickness \\(h = 1.175\\) and the mass density per unit volume \\(\\rho := 1.27\\)\nFor initial gravity load analysis, a single load pattern with a linear time series and three vertical nodal loads are used.\nBoundary conditions are applied using the fixZ command. In this case, all the nodes whose z-coordiate is $0.0$ have the boundary condition {1,1,1, 0,1,1}. All degrees-of-freedom are fixed except rotation about the x-axis, which is free. The same boundary conditions are applied where the z-coordinate is \\(40.0\\).\nA solution algorithm of type Newton is used for the problem. The solution algorithm uses a ConvergenceTest which tests convergence on the norm of the energy increment vector. Five static load steps are performed.\nSubsequent to the static analysis, the wipeAnalysis and remove loadPatern commands are used to remove the nodal loads and create a new analysis. The nodal displacements have not changed. However, with the external loads removed the structure is no longer in static equilibrium.\nThe integrator for the dynamic analysis if of type GeneralizedMidpoint with \\(\\alpha := 0.5\\). This choice is uconditionally stable and energy conserving for linear problems. Additionally, this integrator conserves linear and angular momentum for both linear and non-linear problems. The dynamic analysis is performed using $250$ time increments with a time step \\(\\Delta t := 0.50\\).\nThe results consist of the file Node.out, which contains a line for every time step. Each line contains the time and the vertical displacement at the upper center of the hoop structure. The time history is shown in figure shelldisp{reference-type=“ref” reference=“shelldisp”}.\n","tags":["Shell","Dynamic","Python","Tcl"],"title":"Example 7: Dynamic Shell Analysis","uri":"/opensees-gallery/examples/example7/"},{"categories":["Basic"],"content":"In this example a simple problem in solid dynamics is considered. The structure is a cantilever beam modelled with three dimensional solid elements.\nExample8.1.tcl For three dimensional analysis, a typical solid element is defined as a volume in three dimensional space. Each node of the analysis has three displacement degrees of freedom. Thus the model is defined with ndm = 3 and ndf = 3.\nFor this model, a mesh is generated using the “block3D” command. The number of nodes in the local x-direction of the block is nx, the number of nodes in the local y-direction of the block is ny and the number of nodes in the local z-direction of the block is nz. The block3D generation nodes {1,2,3,4,5,6,7,8} are prescribed to define the three dimensional domain of the beam, which is of size \\(2 \\times 2 \\times 10\\).\nTwo possible brick elements can be used for the analysis. These may be created using the terms StdBrick or BbarBrick. An elastic isotropic material is used.\nFor initial gravity load analysis, a single load pattern with a linear time series and a single nodal loads is used.\nBoundary conditions are applied using the fixZ command. In this case, all the nodes whose z-coordiate is $0.0$ have the boundary condition {1,1,1}, fully fixed.\nA solution algorithm of type Newton is used for the problem. The solution algorithm uses a ConvergenceTest which tests convergence on the norm of the energy increment vector. Five static load steps are performed.\nSubsequent to the static analysis, the wipeAnalysis and remove loadPatern commands are used to remove the nodal loads and create a new analysis. The nodal displacements have not changed. However, with the external loads removed the structure is no longer in static equilibrium.\nThe integrator for the dynamic analysis if of type GeneralizedMidpoint with \\(\\alpha = 0.5\\). This choice is uconditionally stable and energy conserving for linear problems. Additionally, this integrator conserves linear and angular momentum for both linear and non-linear problems. The dynamic analysis is performed using $100$ time increments with a time step \\(\\Delta t = 2.0\\).\nThe results consist of the file cantilever.out, which contains a line for every time step. Each line contains the time and the horizontal displacement at the upper right corner the beam. The time history is as plotted on the screen.\nfigure cantileverdisp{reference-type=“ref” reference=“cantileverdisp”}.\n","tags":["Solid","Dynamic","Python","Tcl"],"title":"Example 8: Cantilever Beam","uri":"/opensees-gallery/examples/example8/"},{"content":"This article describes the simulation of an excavation supported by a cantilevered sheet pile wall using OpenSees. The model considers plane strain conditions in two-dimensions, using quadrilateral elements with a pressure dependent constitutive model to simulate cohesionless soil, and beam-column elements to simulate a unit width of sheet pile wall. Beam-solid contact elements are used to model a frictional interface between the linear beam elements and the quadrilateral soil elements.\nThe input file used for this example is available to view and/or download here.\nExcavation.tcl The pre- and post-process visualization tool GiD was used to generate this example. Further information on how GiD can be used for geotechnical simulations in OpenSees can be found in previous practical examples posted on this wiki. The GiD tool can be downloaded from http://gid.cimne.upc.es/download.\nModel Description Fig. 1: Undeformed FE mesh for the excavation model. Fig. 2: Deformed FE mesh after completion of excavation. The analysis described in this example uses the finite element mesh shown in Fig. 1. The soil domain is 10 m tall and 10.5 m wide. The sheet pile wall considered in this example is 0.5 m wide and has a height of 10.5 m. Beam contact elements are used to create a frictional interface between the beam and solid elements that accounts for the full kinematics of the beam elements and allows the constant width of the wall to be represented in the model. To represent the 0.5 m width of the wall, the beam contact elements (described further below) maintain a constant distance between the wall centerline and the surrounding soil elements of 0.25 m, resulting in the gap between the blue beam elements and the green solid elements shown in Fig. 1.\nThe excavation is simulated by incrementally removing layers of solid elements from one side of the sheet pile wall. After each removal, the model is analyzed for a sufficient number of steps such that equilibrium is reached prior to the removal of the next layer of elements. The removal process continues until an excavation depth of 5 m is achieved. The deformed configuration of the mesh after the completion of the excavation analysis is shown in Fig. 2. As shown, the removal of material from one side of the sheet pile wall allows the wall to be pushed laterally by the remaining soil on the other side. In this figure, the displacement magnitudes are magnified 25 times in order to clearly display the deformation pattern.\nBoundary Conditions The nodes for the solid elements, created with two translational degrees of freedom, are fixed against lateral translation on the left and right hand boundaries, and fixed against vertical translation along the lower boundary. The remaining solid element nodes are left free. The lateral extents of the soil domain were set at ten times the wall thickness on either side of the wall-soil interface to reduce the effects of the boundaries on the behavior of the wall-soil system.\nThe nodes for the beam elements, created with three degrees of freedom (two translational, one rotational), are all left free with the exception of the node at the base of the wall, which is fixed against vertical translation only.\nMaterial and Element Definitions The model used in this excavation analysis contains three types of elements, solid quadrilateral elements for the soil domain, displacement-based beam elements for the sheet pile wall, and beam contact elements to define the frictional wall-soil interface. Three constitutive models (one per element type) are used to define the material behavior of the various components in this model.\nSoil Elements and Material Four-node quad elements are used to model the soil using the plane strain formulation of the quad element. A unit thickness is defined for these elements, indicating that the soil domain in this plane strain model represents a 1 m thick slice of a three-dimensional soil domain. The self-weight of the soil is considered as a body force acting on each element with a magnitude equal to the soil unit weight.\nFor simplicity, this example considers a homogenous cohesionless soil domain, therefore, a single material object is used for the soil elements. The PressureDependMultiYield02 nDMaterial object is used, as this constitutive model captures the pressure dependent strength critical to modeling a cohesionless soil.\nThe InitialStateAnalysisWrapper nDMaterial enables the use of the InitialStateAnalysis feature when defining the initial conditions for the soil model. The initial state analysis procedure, and the role of the InitialStateAnalysisWrapper material object in this procedure, is discussed further in the following sections of this article.\nSheet Pile Wall The sheet pile wall is modeled using the displacement-based beam-column elements with elastic sections used to define the constitutive behavior. The beam elements are placed along the neutral axis of the sheet pile wall, and to ensure the best behavior for the beam contact elements, the beam elements are defined such that their nodes are centered vertically between the nodes of the adjacent soil elements. The beam elements extend beyond the boundaries of the soil domain to allow the elements at the ends of the wall to be in contact with the soil.\nThe beam-solid contact approach used in this example allows for the use of beam-column elements to model the sheet pile wall, enabling the results to be interpreted in the context of traditional beam theory, i.e. it is simple to extract shear and moment diagrams from the recorded data. Figs. 3 and 4 show the types of visualizations that can be realized using this approach in concert with GiD, showing the evolution of the bending moment and shear force demands in the sheet pile wall during the excavation, respectively.\nFig. 3: Evolution of wall bending moment demand during the excavation analysis. Soil-Wall Interface Fig. 5: Contact forces after completion of initial state analysis. Fig. 6: Contact forces in final excavated configuration. The interface between the sheet pile wall and the surrounding soil domain is defined using two-dimensional beam-solid contact elements. The BeamContact2D elements link two master nodes (from the beam element), to a slave node (from an adjacent soil element), and work best when the initial position of the slave node is nearly centered vertically between the two beam nodes, though this node need only be between the beam nodes for the contact to be maintained. These elements use Lagrange multipliers to enforce the contact condition, therefore an additional node is required. In the example input file, the Lagrange multiplier nodes are numbered 1001 to 1042 and are clearly labeled with comments.\nThe constitutive behavior of the interface is defined using the ContactMaterial2D nDMaterial object. This constitutive model uses a regularized Coulomb frictional law allowing for sticking and frictional slip. In this example, a friction coefficient of 0.1 is defined, this coefficient defines the magnitude of the frictional force that develops during the slip condition. The second parameter, set at 1000 in this example, is the interface stiffness which exists during the stick condition.\nThe beam-solid elements readily provide the contact forces acting on the interface, allowing the evolution of these forces during the excavation procedure to be tracked. Examples of the visualizations possible for these elements are shown in Figs. 5 and 6, which show the contact state after the completion of the initial state analysis, and after the completion of the excavation, respectively. Fig. 12, in the Representative Results section of this article, shows the full evolution of the contact forces acting on the interface during the excavation analysis.\nRecorders The large number of recorders defined for this model is necessary to capture information from each of the layers of elements (and associated nodes) which are removed at some point during the analysis. When the elements and nodes for these layers are removed, the associated recorder objects must also be removed. For each of the 10 excavation lifts in the analysis, there is a set of recorders designated here. Each of these sets of recorders are active during all analysis steps prior to the removal of their associated set of elements and nodes. There is an additional set of recorders for those nodes and elements which are never removed, and these recorders remain active for the entire analysis.\nThe recorders are removed using their individual recorder tags. Unlike objects such as nodes and elements, where the tag is specified in the input file, the recorders are assigned tags based upon the order that they appear in the input file. The tags start at 1 and end at the total number of recorder objects. For example, the first recorder defined for excavation lift 1 is the eleventh recorder defined in the input file, therefore, it's associated recorder tag is 11.\nInitial State Analysis Phase For numerical analysis of geotechnical problems, it is important to begin with the appropriate initial conditions. Use of the InitialStateAnalysis feature allows for the initial state of stress an strain in the soil due to the application of gravitational forces to be achieved without any associated nodal deformation. The initiation of this feature is designated by the command InitialStateAnalysis on After this has been designated, the gravitational analysis is conducted. In this example, the soil constitutive model is set to consider only linear elastic behavior for the first 4 analysis steps, then is updated to consider elastoplastic behavior for the remainder of the analysis. These updates are performed using the updateMaterialStage command. The beam-contact elements are updated to ignore friction during the gravity analysis. This is done because the application of gravity loads in the model results in differential vertical displacements between the beam and solid elements. If friction was considered during this process, frictional forces be generated which do not exist in an actual setting. The contact elements are updated to consider frictional behavior after the conclusion of the initial state analysis phase. Updates of these elements are performed using the setParameter command. For example, the elements are updated to consider frictional response using, setParameter -value 1 -eleRange 1001 1042 friction Once the gravitational analysis is complete, the conclusion of the initial state analysis feature is designated by the command InitialStateAnalysis off When this command is called, all displacements which had occurred during the application of gravity are reset to zero while the InitialStateAnalysisWrapper object stores the strain which existed at the end of the gravity analysis as an initial strain. This initial strain is then added to all subsequent strains which are computed in the model. In the first step after switching off the initial state analysis flag, the model is in it's original undeformed configuration, however, the strains and stresses in the soil elements are those that were computed during the gravitational analysis phase. In all subsequent analysis steps, the stresses and strains which are computed will be relative to this initial state, even though the displacements are no longer directly associated with the computed strains.\nExcavation Analysis Phase The excavation of material is simulated in this model by removing layers of solid elements and nodes on one side of the sheet pile wall. After each removal, the model is allowed to reach equilibrium under the new configuration over four analysis steps. The gravitational body forces of the solid elements are the only loads which are applied to the model. Removing sets of elements from one side of the wall results in an unbalanced application of forces to the wall and the associated deformation of the wall and surrounding soil.\nThe removal process for each excavation lift begins with the removal of the associated recorder objects. Failure to remove the recorders associated with removed elements and nodes will result in a segmentation fault, so it is important to include this step. The soil elements are removed next, followed by the contact element and Lagrange multiplier node connected to the removed layer, and then by the nodes along the upper boundary of the removed layer. The full removal and analysis process for the first excavation lift is provided here\n# remove objects associated with lift # ----------------------------------- # recorders set recCount 10 for {set k 0} {$k \u003c= 8} {incr k 1} { remove recorder [expr $recCount + $k] } set recCount [expr $recCount + $k] # soil elements for {set k 1} {$k \u003c= 10} {incr k 1} { remove element [expr 190+$k] } # contact element remove element 1042 # lagrange multiplier node remove node 1042 # soil nodes remove node 430 remove node 437 remove node 446 remove node 455 remove node 461 remove node 468 remove node 473 remove node 476 remove node 480 remove node 482 remove node 484 # run analysis after object removal analyze 4 There are a total of ten excavation lifts in the example analysis, representing the soil on the right-hand side of the sheet pile wall up to a depth of 5 m. Due to the use of GiD to create the input file, the nodes are not numbered in a useful order, therefore, loops are not employed in their removal.\nRepresentative Results Several sets of results are provided in this section of the article for the purposes of verifying the proper download and implementation of the example by the user, as well as to demonstrate some of the post-processing capabilities of GiD. The simplest means of verification for this example is the wall bending moment and shear force diagrams shown in Figs. 7 and 8. These diagrams are representative of the end of the excavation analysis.\nFigs. 9 and 10 show the distributions of vertical and shear stresses at the end of the excavation process, respectively. These figures show the expected concentration of stresses which occurs near the base of the sheet pile wall, and also indicate that the level of mesh refinement in this example is rather coarse, though it it sufficient for the purposes of this example.\nFig. 11 is an animation of the full excavation analysis, showing the nodal deformations (magnified 25 times) with the contours indicating the magnitude of the displacements which occur. Fig. 12 shows the evolution of the wall-soil interface contact forces as elements are removed from the model. As shown, these force vectors do not remain horizontal, indicating the generation of frictional forces on the interface.\nExample prepared by: Christopher McGann and Pedro Arduino, University of Washington\n","title":"Excavation Supported by Cantilevered Sheet Pile Wall","uri":"/opensees-gallery/community/excavation/"},{"content":"","title":"Fatigue Material","uri":"/opensees-gallery/material/fatiguematerial/"},{"content":"Investigate the two most commonly used OpenSees elements for modeling beam-column elements: the force-based element (FBE) and displacement-based element (DBE).\nAlthough the OpenSees command for defining these two elements has the same arguments, a beam-column element needs to be modeled differently using these two elements to achieve a comparable level of accuracy. The intent of this seminar is to show users how to properly model beam-column elements with both FBE and DBE. The theory behind these two elements along with two examples will be presented to users to enhance their understanding of the elements and assure their correct application. This seminar covers:\nModel Generation:\nThe column is modeled using finite elements, with either force-based or displacement-based elements. The column height (HCol) is 96 inches, and the diameter (DCol) is 24 inches. The clear cover of concrete (clearCover) is 0.75 inches. The column is divided into finite elements, each with a height of HEle. The area of the column cross-section (ACol) is calculated based on the diameter. Boundary Conditions:\nNode 1 is fixed in both horizontal and vertical directions. Coordinate transformation is applied using the Corotational method. Materials:\nLongitudinal reinforcement: Bar area (barArea) is 0.31 square inches (for bar #5). Bar diameter (db) is 0.625 inches. Yield strength (fy) of longitudinal bars is 70 ksi. Modulus of elasticity (Es) of steel is 29,000 ksi. Tangent at initial strain hardening (Esf) is calibrated from coupon tests. Transverse reinforcement: Spiral diameter (dh) is 0.25 inches. Number of hoops (NoHoops) is 1. Area of transverse reinforcement bar (Asp1) is 0.0491 square inches. Centerline distance between spirals (stran) is 1.25 inches. Yield strength of the hoop (fyh) is 96.6 ksi. Steel Model:\nThe Menegotto-Pinto uniaxial steel model is used with specific coefficients. MinMax limits are set for the steel model. Concrete Model:\nUnconfined concrete: Compressive strength (fc) is 4.4 ksi. Strain corresponding to fc is eps0. Ultimate strain for unconfined concrete is epss. Elastic modulus (Ec) is calculated based on ACI building code. Confined concrete: Compressive strength and strain are determined using Mander’s equations. PPT presentation of the seminar can be found here:\nFBE vs. DBE Video of the seminar can be found here:\nFBE vs. DBE OpenSees files used to demonstrate the effect of rigid constraints can be found here:\nThe main file that is to be sourced from the OpenSees interpreter: ConventionalColumn_Cyclic.tcl Supporting files to be stored in the same folder with the main file: LibUnits.tcl (define system of units) SingleCycle.tcl (procedure for writing one cycle of displacement history) leh415.xls (experimental force-displacement response) ","tags":["Frame"],"title":"Force-based Element vs. Displacement-based Element","uri":"/opensees-gallery/examples/frameformulations/"},{"content":"This example demonstrates how to use the viscous damper material within a simple single story shear frame.\nThe files needed to analyze this structure in OpenSees are included here:\nThe main file: Supporting files\nTakY.th - uses the JR Takatori record from the Kobe 1995 earthquake (available in the zip file below) All files are available in a compressed format here: Viscous_Damper_Example.zip\nThe rest of this example describes the model and shows the analysis results.\nModel Description Figure 1. Schematic representation of a viscous damper installed in the single story moment resisting frame. The viscous damper is modeled with a Two Node Link Element. This element follows a Viscous damper hysteretic response. An idealized schematic of the model is presented in Figure 1.\nThe units of the model are mm, kN, and seconds.\nBasic Geometry The single bay single story frame shown in Figure 1 has 5000mm bay width and 3000mm story height (centerline). The period of the system is 0.7sec. Columns and beams of the frame are modeled with elastic beam-column elements.\nDamper Links A Two Node Link Element is used to link the two nodes that define the geometry of the viscous damper.\nConstraints the Nodes at the base of the frame are fixed. The beam (element 3 in Figure 1) is considered to be rigid.\nViscous Damper Material To model the viscous damper the ViscousDamper is used. The input parameters that are selected for the damper example are as follows: Axial Stiffness K = 25 kN/mm, Damping Coefficient Cd=20.74 kN(s/mm)\u003csup\u003e0.35\u003c/sup\u003e and exponent a=0.35.\nLoading The single story frame with viscous damper is subjected to the 50% JR Takatori record from the Kobe 1995 earthquake in Japan.\nRecorders The recorders used in this example include:\nThe Element recorder to track the damper axial force and axial displacement. The Node recorder to track the Frame displacement history at its roof. Analysis A uniform excitation option is selected with application of ground acceleration history as the imposed motion. The Newmark integration scheme is selected for integration of the equations of motion with a time step dt = 0.001sec. Two percent mass proportional damping is used.\nResults Simulation Results for the 50% JR Takatori Record Figure 2. Displacement history at the roof of the single story MRF The force - displacement relationship from the viscous damper are shown in Figure 3. A comparison with results from a SAP2000 model is also shown in Figure 3. Results are nearly identical between the two models. Figure 3. Force - displacement relationship of the viscous damper and comparison with identical model in SAP2000 Example posted by: Sarven Akcelyan and Prof. Dimitrios G. Lignos (McGill University)\n","description":"This example demonstrates how to use the viscous damper material within a simple single story shear frame.","title":"Frame with Viscous Dampers","uri":"/opensees-gallery/examples/viscousdamper/"},{"content":"","tags":["Tcl"],"title":"Hayward Bridge","uri":"/opensees-gallery/gallery/haywardbridge/"},{"content":"\n","tags":["Solid","Python"],"title":"Igloo","uri":"/opensees-gallery/gallery/igloo/"},{"content":"Download (CantileverTransient2D.ipynb)\nIn order to execute this notebook, go to the menu bar and click Run/Run all cells. You can also run individual cells by selecting the cell (a blue bar will appear to the left of the active cell, then pressing Shift+Enter.\nNOTE Before running this notebook, you must install the external dependencies. To to this, uncomment the following cell by removing the leading # character, execute the cell, then put the # character back to prevent it from running again, thereby “commenting it out”. Once everything is installed you may re-run the commented-out cell to hide the text generated by the installation.\n# !pip install -Ur requirements.txt # Linear algebra library import numpy as np # Plotting library import matplotlib.pyplot as plt # The next two lines set reasonable plot style defaults import scienceplots plt.style.use('science') ## Configure units # Units are based on inch-kip-seconds import opensees.units.iks as units pi = units.pi; ft = units.ft; ksi = units.ksi; inch = units.inch; ## Distributed Inelasticity 2d Beam-Column Element # fiber section Set up basic model geometry\n# import the openseespy interface which contains the \"Model\" class import opensees.openseespy as ops # generate Model data structure model = ops.Model(ndm=2, ndf=3) # Length of cantilever column L = 8*ft; # specify node coordinates model.node(1, 0, 0 ); # first node model.node(2, 0, L ); # second node # boundary conditions model.fix(1, 1, 1, 1 ) ## specify mass model.mass(2, 2.0, 1e-8, 1e-8) ## Element name: 2d nonlinear frame element with distributed inelasticity # Create material and add to Model mat_tag = 1 # identifier that will be assigned to the new material E = 29000*ksi fy = 60*ksi Hkin = 0 Hiso = 0 model.uniaxialMaterial(\"Steel01\", mat_tag, fy, E, 0.01) # model.uniaxialMaterial(\"ElasticPP\", mat_tag, E, fy/E) # model.uniaxialMaterial(\"UniaxialJ2Plasticity\", mat_tag, E, fy, Hkin, Hiso) Create a section import opensees.section # Load cross section geometry and add to Model sec_tag = 1 # identifier that will be assigned to the new section SecData = {} SecData[\"nft\"] = 4 # no of layers in flange SecData[\"nwl\"] = 8 # no of layers in web SecData[\"IntTyp\"] = \"Midpoint\"; SecData[\"FlgOpt\"] = True section = opensees.section.from_aisc(\"Fiber\", \"W24x131\", # \"W14x426\", sec_tag, tag=mat_tag, mesh=SecData, ndm=2, units=units) import sees.section sees.section.render(section); Output:\n\u003cFigure size 350x262.5 with 1 Axes\u003e Printing the fiber section will display the effective cross-sectional properties which result from quadrature over the cross section fibers:\nprint(section) Output:\nSectionGeometry area: 38.42890000000003 ixc: 4013.509824163335 iyc: 343.8869259102087 Create an element cmd = opensees.tcl.dumps(section, skip_int_refs=True) model.eval(cmd) # Create element integration scheme nIP = 4 int_tag = 1 model.beamIntegration(\"Lobatto\", int_tag, sec_tag, nIP) # Create element geometric transformation model.geomTransf(\"Linear\", 1) # Finally, create the element # CONN Geom Int model.element(\"ForceBeamColumn\", 1, (1, 2), 1, int_tag) Analysis Eigenvalue Analysis # State = Initialize_State (Model,ElemData) # State = Structure('stif',Model,ElemData,State) # Initialize the analysis state for transient analysis model.analysis(\"Transient\") # Form stiffness and mass matrices Kf = model.getTangent(k=1.0) # free DOF stiffness matrix Kf for initial State Mf = model.getTangent(m=1.0) # free DOF mass matrix Ml print(\"Kf:\", Kf, sep=\"\\n\") print(\"Mf:\", Mf, sep=\"\\n\") Output:\nKf: [[ 1.57505061e+03 0.00000000e+00 7.56024291e+04] [ 0.00000000e+00 1.16087302e+04 -1.21265960e-12] [ 7.56024291e+04 -1.21265960e-12 4.83855547e+06]] Mf: [[2.e+00 0.e+00 0.e+00] [0.e+00 1.e-08 0.e+00] [0.e+00 0.e+00 1.e-08]] Solve dynamic eigenvalue problem with scipy function eig\nimport scipy.linalg omega,Ueig = scipy.linalg.eig(Kf,Mf) # echo eigenmode periods print(' The three lowest eigenmode periods are') T = 2*pi/np.sqrt(omega) print(T) Output:\nThe three lowest eigenmode periods are [4.47793313e-01+0.j 2.85641961e-07+0.j 5.83159707e-06+0.j] In general the eigen function should be used, which takes advantage of sparsity in the system\nfor w in model.eigen(2): print(2*pi/np.sqrt(w)) Output:\n0.44779331340120765 5.8315970735940395e-06 Configure ground motion # Apply damping in the first mode zeta = 0.02 model.modalDamping(zeta) # alphaM, betaK = 0.01, 0.01 # model.rayleigh(alphaM, betaK, 0, 0) # State = Add_Damping2State('Modal',Model,State,zeta) # Deltat = 0.02 # AccHst = np.loadtxt(\"tabasFN.txt\") import quakeio Event = quakeio.read(\"TAK000.AT2\") AccHst = Event.data Deltat = Event[\"time_step\"] load_tag = 1 model.timeSeries('Path', load_tag, dt=Deltat, factor=1.0, values=units.gravity*AccHst) model.pattern('UniformExcitation', 1, 1, accel=load_tag) Configure integration method ## initialize data for solution strategy # gam bet model.integrator(\"Newmark\", 1/2, 1/4, form=\"d\") Perform integration nt = len(AccHst) Uplt = np.zeros(nt) Vplt = np.zeros(nt) Aplt = np.zeros(nt) Pplt = np.zeros(nt) # Defo = zeros(np,1) # Forc = zeros(np,1) for k in range(nt): if model.analyze(1, Deltat) != 0: print(\"Analysis failed\") break # extract values for plotting from response history Uplt[k] = model.nodeDisp (2, 1) Vplt[k] = model.nodeVel (2, 1) Aplt[k] = model.nodeAccel(2, 1) # Pplt[k] = Post[k].Pr[Pdof,:]; # Defo(k) = Post(k).Elem{1}.v; # Forc(k) = Post(k).Elem{1}.q; Post-processing Displacement History t = np.arange(nt)*Deltat; Xp = t Yp = (Uplt/L)*100 FigHndl, AxHndl = plt.subplots() AxHndl.set_xlabel('Time (sec)') AxHndl.set_ylabel('Drift in X (\\\\%)') AxHndl.plot(Xp,Yp,'b') FigHndl.savefig(\"drift.png\") Output:\n\u003cFigure size 350x262.5 with 1 Axes\u003e Shear force-displacement history Xp = (Uplt/L)*100 Yp = Pplt FigHndl, AxHndl = plt.subplots() AxHndl.set_xlabel('Lateral Drift (\\#)') AxHndl.set_ylabel('Lateral Force $P$') AxHndl.plot(Xp, Yp, 'b') plt.show() Output:\n\u003cFigure size 350x262.5 with 1 Axes\u003e ","description":"A plane cantilever column is shaken by an earthquake. Material nonlinearity\nis accounted for using the force formulation and fiber-discretized cross\nsections\n","tags":["Python","Static","Notebook","Fiber"],"title":"Inelastic Cantilever","uri":"/opensees-gallery/examples/cantilevertransient/"},{"content":"Download (Elastoplastic SDOF system.ipynb)\nElastoplastic SDOF system March 2020, By Amir Hossein Namadchi This is an OpenSeesPy simulation of a simple SDOF system with elastoplastic behavior mentioned in Dynamics of Structures book by Ray W. Clough and J. Penzien. This example has been solved in the book, so the result obtained here can be compared with the reference.\nThis notebook is adapted from https://github.com/AmirHosseinNamadchi/OpenSeesPy-Examples/blob/master/Elastoplastic%20SDOF%20system.ipynb\nimport numpy as np import opensees.openseespy as ops import matplotlib.pyplot as plt ## Units inch = 1 # inches kips = 1 # KiloPounds sec = 1 # Seconds lb = kips*(sec**2)/inch # mass unit (derived) Model specifications are defined as follows:\nm = 0.1*lb # Mass k = 5.0*(kips/inch) # Stiffness c = 0.2*(kips*sec/inch) # Damping dy_p = 1.2*inch # Plastic state displacment alpha_m = c/m # Rayleigh damping ratio # Variation of p(t) in tabular form load_history = np.array([[0, 0], [0.1, 5], [0.2, 8], [0.3, 7], [0.4, 5], [0.5, 3], [0.6, 2], [0.7, 1], [0.8, 0]]) # Dynamic Analysis Parameters dt = 0.01 time = 1.0 Analysis Let’s wrap the whole part in a function so that different material behavior could be passed to the function:\ndef do_analysis(dt, time, material_params): model = ops.Model(ndm=1, ndf=1) time_domain = np.arange(0, time, dt) # Nodes model.node(1,0.0,0.0) model.node(2,0.0,0.0) model.uniaxialMaterial(*material_params) model.element('zeroLength', 1, *[1,2], '-mat', 1, '-dir', 1) model.mass(2, m) model.rayleigh(alpha_m, 0.0, 0.0, 0.0) model.fix(1,1) model.timeSeries('Path', 1, values=load_history[:,1], time=load_history[:,0]) model.pattern('Plain', 1, 1) model.load(2, 1) # Analysis model.constraints('Plain') model.numberer('Plain') model.system('ProfileSPD') model.test('NormUnbalance', 0.0000001, 100) model.algorithm('ModifiedNewton') model.integrator('Newmark', 0.5, 0.25) model.analysis('Transient') time_lst =[0] # list to hold time stations for plotting response = [0] # response params of node 2 for i in range(len(time_domain)): model.analyze(1, dt) time_lst.append(model.getTime()) response.append(model.nodeDisp(2,1)) print('Done with ', material_params,'!') return {'time_list':np.array(time_lst), 'd': np.array(response)} For comparison (similar to the book), elastic analysis is also inculded:\nepp = do_analysis(dt, time, ['ElasticPP', 1, k, dy_p]) # Elastic-Perfectly Plastic els = do_analysis(dt, time, ['Elastic', 1, k]) # Elastic Output:\nDone with ['ElasticPP', 1, 5.0, 1.2] ! Done with ['Elastic', 1, 5.0] ! Visualization plt.figure(figsize=(7,5)) plt.plot(epp['time_list'], epp['d'], color = '#fe4a49', linewidth=1.75, label = 'Nonlinear (EPP)') plt.plot(els['time_list'], els['d'], color = '#2ab7ca', linewidth=1.75, label = 'Linear (Elastic)') plt.ylabel('Displacement (inch)', {'fontstyle':'italic','size':14}) plt.xlabel('Time (sec)', {'fontstyle':'italic','size':14}) plt.xlim([0.0, time]) plt.legend() plt.grid() plt.yticks(fontsize = 14) plt.xticks(fontsize = 14); Output:\n\u003cFigure size 700x500 with 1 Axes\u003e Closure Results obtained here with the OpenSeesPy, totally agree with the ones in the book.\nReferences Clough, R.W. and Penzien, J., 2003. Dynamics of structures. Berkeley. CA: Computers and Structures, Inc. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 import sdof import numpy as np # import openseespy.opensees as op import opensees.openseespy as op FREE = 0 FIXED = 1 X, Y, RZ = 1, 2, 3 def plastic_sdof(mass, k_spring, f_yield, motion, dt, xi=0.05, r_post=0.0): \"\"\" Run seismic analysis of a nonlinear SDOF :param mass: mass :param k_spring: spring stiffness :param f_yield: yield strength :param motion: list, acceleration values :param dt: float, time step of acceleration values :param xi: damping ratio :param r_post: post-yield stiffness :return: \"\"\" op.wipe() op.model('basic', '-ndm', 2, '-ndf', 3) # 2 dimensions, 3 dof per node # Establish nodes bot_node = 1 top_node = 2 op.node(bot_node, 0., 0.) op.node(top_node, 0., 0.) # Fix bottom node op.fix(top_node, FREE, FIXED, FIXED) op.fix(bot_node, FIXED, FIXED, FIXED) # Set out-of-plane DOFs to be slaved op.equalDOF(1, 2, *[2, 3]) # nodal mass (weight / g): op.mass(top_node, mass, 0., 0.) # Define material bilinear_mat_tag = 1 mat_type = \"Steel01\" mat_props = [f_yield, k_spring, r_post] op.uniaxialMaterial(mat_type, bilinear_mat_tag, *mat_props) # Assign zero length element beam_tag = 1 op.element('zeroLength', beam_tag, bot_node, top_node, \"-mat\", bilinear_mat_tag, \"-dir\", 1, '-doRayleigh', 1) # Define the dynamic analysis load_tag_dynamic = 1 pattern_tag_dynamic = 1 values = list(-1 * motion) # should be negative # op.timeSeries('Path', load_tag_dynamic, dt=dt, values=values) op.timeSeries('Path', load_tag_dynamic, \"-dt\", dt, \"-values\", *values) # op.pattern('UniformExcitation', pattern_tag_dynamic, X, accel=load_tag_dynamic) op.pattern('UniformExcitation', pattern_tag_dynamic, X, \"-accel\", load_tag_dynamic) # set damping based on first eigen mode eig = op.eigen('-fullGenLapack', 1) try: angular_freq = eig**0.5 except: angular_freq = eig[0]**0.5 alpha_m = 0.0 beta_k = 2 * xi / angular_freq beta_k_comm = 0.0 beta_k_init = 0.0 op.rayleigh(alpha_m, beta_k, beta_k_init, beta_k_comm) # Run the dynamic analysis # op.wipeAnalysis() op.algorithm('Newton') # op.system('SparseGeneral') op.numberer('RCM') op.constraints('Transformation') op.integrator('Newmark', 0.5, 0.25) op.analysis('Transient') tol = 1.0e-10 iterations = 10 op.test('EnergyIncr', tol, iterations, 0, 2) analysis_time = (len(values) - 1) * dt analysis_dt = 0.001 outputs = { \"time\": [], \"rel_disp\": [], \"rel_accel\": [], \"rel_vel\": [], \"force\": [] } while op.getTime() \u003c analysis_time: curr_time = op.getTime() if op.analyze(1, analysis_dt) != 0: print(f\"Failed at time {op.getTime()}\") break outputs[\"time\"].append(curr_time) outputs[\"rel_disp\"].append(op.nodeDisp(top_node, 1)) outputs[\"rel_vel\"].append(op.nodeVel(top_node, 1)) outputs[\"rel_accel\"].append(op.nodeAccel(top_node, 1)) op.reactions() outputs[\"force\"].append(-op.nodeReaction(bot_node, 1)) # Negative since diff node op.wipe() for item in outputs: outputs[item] = np.array(outputs[item]) return outputs def show_single_comparison(): \"\"\" Create a plot of an elastic analysis, nonlinear analysis and closed form elastic :return: \"\"\" import eqsig import matplotlib.pyplot as plt record_filename = 'test_motion_dt0p01.txt' motion_step = 0.01 rec = np.loadtxt(record_filename) acc_signal = eqsig.AccSignal(rec, motion_step) period = 1.0 xi = 0.05 mass = 1.0 f_yield = 1.5 # Reduce this to make it nonlinear r_post = 0.0 periods = np.array([period]) k_spring = 4 * np.pi ** 2 * mass / period ** 2 outputs = plastic_sdof(mass, k_spring, f_yield, rec, motion_step, xi=xi, r_post=r_post) outputs_elastic = plastic_sdof(mass, k_spring, f_yield * 100, rec, motion_step, xi=xi, r_post=r_post) ux_opensees = outputs[\"rel_disp\"] ux_opensees_elastic = outputs_elastic[\"rel_disp\"] print(outputs) bf, sps = plt.subplots(nrows=2) sps[0].plot(outputs[\"time\"], ux_opensees, label=\"OpenSees fy=%.3gN\" % f_yield, ls=\"-\") sps[0].plot(outputs[\"time\"], ux_opensees_elastic, label=\"OpenSees fy=%.3gN\" % (f_yield * 100), ls=\"--\") time = acc_signal.time acc_opensees_elastic = np.interp(time, outputs_elastic[\"time\"], outputs_elastic[\"rel_accel\"]) - rec resp_u, resp_v, resp_a = sdof.integrate(rec, motion_step, k_spring, 2*xi*mass*np.sqrt(k_spring/mass), mass, fy=f_yield) sps[0].plot(acc_signal.time, resp_u, label=\"sdof\") sps[1].plot(acc_signal.time, resp_a, label=\"sdof\") # resp_u, resp_v, resp_a = duhamels.response_series(motion=rec, dt=motion_step, periods=periods, xi=xi) # sps[0].plot(acc_signal.time, resp_u[0], label=\"Eqsig\") # sps[1].plot(acc_signal.time, resp_a[0], label=\"Eqsig\") # Elastic solution # print(\"diff\", sum(acc_opensees_elastic - resp_a[0])) sps[1].plot(time, acc_opensees_elastic, label=\"Opensees fy=%.2gN\" % (f_yield * 100), ls=\"--\") sps[0].legend() sps[1].legend() plt.show() if __name__ == '__main__': show_single_comparison() ","description":"Integration of an inelastic single-degree-of-freedom (SDOF) system.","tags":["Dynamic","Python"],"title":"Inelastic SDOF","uri":"/opensees-gallery/examples/inelasticsdof/"},{"content":" source\nThis article describes the commands for modeling an infill wall element which considers in-plane and out-of-plane interaction and for removal of the element during nonlinear time history simulation in OpenSees. In addition, the infill wall model and element removal algorithm are briefly described. Interested readers can refer to the mentioned references for more information. Questions or comments can be directed to selimgunay [at] berkeley . edu or mosalam [at] ce . berkeley . edu\nModeling of the Infill Wall The described infill wall model is a model which considers the interaction of in-plane (IP) and out-of-plane (OOP) effects. Modeling of the infill wall is performed by using the available OpenSees materials, sections, elements and tcl commands. The infill wall model is comprised of two equal size diagonal beamWithhinges elements and a midspan node with OOP mass (Figure 1). The inelastic fiber section assigned to the ends of the elements connected to the midspan node is discretized as explained in the following paragraph. Elastic sections with very small moment of inertia (to simulate moment release) are assigned to the ends attached to the surrounding frame. The hinge length near the midspan node is selected as short as possible in order to produce a relatively sharp yield point for the element, while at the same time providing a numerically stable solution. 1/10 of the total length of the diagonal is a suitable value for the total hinge length (sum of the lengths of the hinges on both sides of the node). The hinge length on the other end can be selected as small as possible without losing numerical stability.\nFigure1.jpg Discretization of Inelastic Fiber Section and Calculation of OOP mass The inelastic fiber section of the beamWithhinges element is modeled by strategically locating a collection of nonlinear fiber elements[1,2]. The fibers are located along a line in the OOP direction (Z-direction in Figure 1). By this way, the beam-column element acts as a truss element and a flexural element in the IP and OOP directions, respectively. The discretization of the cross section is shown in Figure 2a. In this figure, the vector used to define the local-coordinate system in OpenSees, vecxz, is (0 0 -1) corresponding to the global axes shown in Figure 1. Each fiber is defined with the area \\(\\mathrm{A_i}\\) , \\(z\\)-coordinate \\(\\mathrm{z_i}\\) and a bilinear stress-strain relationship. The strain hardening slope is chosen to be very small, hence the yield stress \\(\\mathrm{f_{yi}}\\) and the yield strain \\(\\mathrm{{\\epsilon}_{yi}}\\) define the stress-strain relationship of the \\(\\mathrm{i_{th}}\\) fiber. Since only one diagonal is utilized in the model, it has both tension and compression strengths. Therefore, the fibers are considered to have the same absolute value for the tensile and compression yield strengths.\nFigure2-1.jpg The parameters defining a fiber section (\\(\\mathrm{A_i}\\), \\(\\mathrm{z_i}\\), $\\mathrm{f_{yi}}$ , and $\\mathrm{{\\epsilon}_{yi}}$ ) are set such that the intended strength interaction (Figure 2b) and the IP axial and OOP bending stiffness values of the diagonal infill wall element are properly simulated. In the current formulation, FEMA-356[3] or ASCE-41[4] equations are used for calculating the axial stiffness and unidirectional strength in the IP direction. However, any other relationships that the user considers as suitable can also be employed. The OOP mass, stiffness and unidirectional bending strength are calculated such that the model has the same natural frequency as the original infill wall, it should produce the same support reactions where it is attached to the surrounding frame for a given support motion (story acceleration), and it should exhibit initial yielding at the same level of support motion that causes the original infill wall to yield. Discretization of the inelastic fiber section is explained below. In the explanation, equations of FEMA-356 are referred to rather than ASCE-41 equations, since FEMA-356 document is accessible from FEMA website. However, Equations of FEMA-356 and ASCE-41 are very similar and ASCE-41 equations may be replaced with FEMA-356 equations.\nCalculate the IP axial force capacity of the equivalent diagonal element ($\\mathrm{P_{IP0}}$, Equation 1. \\[ P_{I P O}=\\frac{Q_{C E}}{\\cos \\theta} \\quad Q_{C E}=A_{\\text {ni }} f_{\\text {vie }} \\] In Equation 1, $\\mathrm{\\Theta}$ is the angle of the equivalent diagonal element with the horizontal. $\\mathrm{Q_{CE}}$ is the expected infill shear strength, $\\mathrm{A_{ni}}$ is the area of net mortared/grouted section across infill panel and $\\mathrm{f_{ive}}$ is the expected shear strength of masonry infill. Second part of Equation 1 corresponds to Equation 7-15 in FEMA-356.\nCalculate the OOP moment capacity under zero IP axial force (MOOP0) for the equivalent diagonal element, Equation 2. \\[ \\begin{aligned} \u0026 \\mathrm{M}_{\\text {OOp0 }}=1.570 \\frac{\\mathrm{L}_{\\text {diag }}}{\\mathrm{h}_{\\text {inf }}} \\mathrm{M}_{\\mathrm{y}} \\\\ \u0026 \\mathrm{M}_{\\mathrm{y}}=\\frac{\\mathrm{q}_{\\mathrm{in}} \\mathrm{L}_{\\mathrm{inf}} \\mathrm{h}_{\\mathrm{inf}}{ }^2}{8} \\\\ \u0026 \\mathrm{q}_{\\mathrm{in}}=\\frac{0.7 \\mathrm{f}_{\\mathrm{m}} \\lambda_2}{\\left(\\mathrm{~h}_{\\mathrm{inf}} / \\mathrm{t}_{\\mathrm{inf}}\\right)} \\end{aligned} \\] In Equation 2, $\\mathrm{L_{diag}}$ is the length of the equivalent diagonal element and $\\mathrm{h_{inf}}$, $\\mathrm{L_{inf}}$ and $\\mathrm{t_{inf}}$ are the height, length and thickness of the infill wall panel, respectively. $\\mathrm{q_{in}}$ is the OOP strength of the infill wall panel, $\\mathrm{f_{m}}$ is the expected value of masonry compressive strength and $\\mathrm{{\\lambda}_2}$ is a slenderness parameter defined in Table 7-11 of FEMA-356. Equation 2c corresponds to Equation 7-21 in FEMA-356.\nEquation 2 is based on the assumption that the yield moment in the equivalent diagonal element is reached when the support spectral acceleration equals the yield spectral acceleration of the original infill wall. Derivation of Equation 2 can be found in Appendix D of reference [1].\nConstruct the IP axial and OOP bending strength interaction curve accepted as a 3/2-power curve[1, 2] represented with Equation 3. The 3/2 power curve is based on the OOP and IP capacity points obtained from the analyses of a nonlinear finite element (FE) model of an infill panel[3]. In Equation 3, $\\mathrm{P_{IP}}$ is the IP axial strength in the presence of OOP force, $\\mathrm{P_{IP0}}$ , which is calculated in step 1, is the IP axial strength without OOP force, $\\mathrm{M_{OOP}}$ is the OOP bending strength in the presence of IP force, and $\\mathrm{M_{OOP0}}$ , which is calculated in step 2, is the OOP bending strength without IP force.\nEq3.jpg It should be noted that steps 1, 2 and 3 consist of the construction of the IP axial and OOP bending strength interaction based on the explained methodology. The user is free to use any other interaction curve which might be based on experimental data or FE simulations, as long as the chosen interaction curve is not concave, since the equations used for calculation of the fiber locations are not suitable for concave diagrams. However, this limitation is not considered to be serious, since a concave interaction diagram is rarely encountered. The interaction diagram should be discretized at N pairs (N pairs including the (\\(\\mathrm{M_{OOP0}}\\), 0) and (0, $\\mathrm{P_{IP0}}$ ) pairs), where 2(N-1) is the total number of fibers in the section (N-1 fibers are placed at one side of the y-axis and N-1 fibers on the other side symmetrically as shown in Figure 2). Typically, 10 fibers along the section could be sufficient which corresponds to 6 data pairs on the interaction diagram.\nCalculate the equivalent strut width “a” using Equation 4, which corresponds to Equation 7-14 in FEMA-356. Then, cross-sectional area of the diagonal element becomes tinf×a. The user is free to use any other relationship to calculate the area of the equivalent diagonal element or the equivalent width.\nEq4.jpg where $\\mathrm{h_{col}}$ is the height of the column of the surrounding frame, $\\mathrm{E_{m}}$ and $\\mathrm{E_{f}}$ are the elasticity moduli of the infill and frame materials, respectively. Equation 4 is unit dependent where force is in kips and displacement is in inches.\nCalculate the equivalent moment of inertia of the diagonal element in the OOP direction, $\\mathrm{I_{eq}}$. Considering that the model has the same natural frequency as the original infill wall and it should produce the same support reactions where it is attached to the frame for a given story acceleration, $\\mathrm{I_{eq}}$ is calculated with Equation 5.\nEq5.jpg where $\\mathrm{\\kappa}$ is a factor which represents the reduction in moment of inertia due to cracking. Calculate the distance of the $\\mathrm{i^{th}}$ fiber to the centroid ($\\mathrm{z_{i}}$, Equation 6.\nEq6.jpg where M and P represent the OOP bending moment and IP axial force capacities in the interaction diagram (Figure 3). i=1 corresponds to the fiber farthest from the centroid and the point of pure compression on the P−M diagram. The index i increases sequentially in the section as progressing inward to the y-axis and in the interaction diagram in the direction of decreasing P as shown in Figure 3. It should be noted that the coordinates of the points ($\\mathrm{z_{i}}$ on one side of the y axis (positive z) are calculated with Equation 6 but coordinates of the points on the other side are calculated as the negative of the values calculated with Equation 6. Equation 6 is obtained from the consideration of the changes in the plastic axial force and moment that occur as the plastic neutral axis is “swept through” the section. Derivation of this equation is explained in reference [2]. Figure3.jpg Area of each fiber is calculated such that the sum of the areas of the fibers is equal to the cross sectional area of the equivalent diagonal element (\\(\\mathrm{t_{inf}}\\) ×a) calculated in step 4 and sum of the second moment of the fibers is equal to the equivalent moment of inertia in OOP direction ($\\mathrm{I_{eq}}$ calculated in step 5.\nEq7a.jpg In order to have a unique solution of Equation 7a, the relationship between $\\mathrm{A_{i}}$ and $\\mathrm{z_{i}}$ is assumed to be represented with Equation 7b. Eq7b.jpg since $\\mathrm{z_{i}}$ values are known from Equation 6, $\\mathrm{\\gamma}$ and $\\mathrm{\\eta}$ can be determined from Equation 7. Then, the area of each fiber is calculated using Equation 7b. Calculate yield stress and yield strain for each fiber, Equations 8 and 9.\nEq89-2.jpg Equation 8b is obtained from the consideration of the change in the plastic axial force that occurs as the plastic neutral axis (PNA in Figure 2) is “swept through” the section. Derivation of this equation is explained in reference [2]. In addition to the fibers along z direction, a dummy fiber (a fiber with a very small area) should be located at an arbitrary point along the y-axis (Figure 2) to supply a very small IP moment of inertia.\nThe inelastic fiber section is discretized following the above nine steps. Cross sectional area obtained in step 4 and moment of inertia in OOP direction obtained in step 5 are used as area and moment of inertia about the local axis corresponding to the OOP direction for the interior elastic part of the beamWithhinges element. A very small number is input for the moment of inertia about the other sectional local axis.\nCalculation of OOP Mass at the Midspan Node As stated previously, the described infill wall element is comprised of two equal size diagonal beamWithhinges elements and a midspan node with OOP mass. This mass at the midspan node is calculated as 0.81M, where M is the total mass of the infill wall panel. This value is the first mode effective mass of the infill wall panel when it is defined as a beam spanning vertically with distributed mass and with simple supports at the ends. Theoretical derivation can be found in reference [1].\nImplementation of Infill Wall Removal in OpenSees A progressive collapse algorithm is developed [4-6], the different applications of which can be found in references [7-10]. This algorithm is developed using element removal based on dynamic equilibrium and resulting transient change in system kinematics, the underlying theory of which can be found in the above references. The progressive collapse algorithm is implemented for automated removal of collapsed elements during an ongoing simulation (Figure 4). The implementation is carried out as a new OpenSees module, designed so that it is called by the main analysis module after each converged load step to check each element for possible violation of its respective removal criteria. A violation of any pre-defined removal criterion triggers the activation of the element removal algorithm on the violating element before returning to the main analysis module. Activation of the element removal algorithm includes updating nodal masses, checking if the removal of the collapsed element results in leaving behind dangling nodes or floating elements, which must be removed as well (Figure 5), and removing all associated element and nodal forces, imposed displacements, and constraints.\nFigure4-2.jpg Figure5.jpg Other than the aforementioned infill wall element, removal criteria are defined for force- and displacement-based distributed plasticity fiber elements and lumped plasticity beam-column elements with fiber-discretized plastic hinges. These criteria are based on material-level damage indices for a newly developed confined RC cross-section model [11-13]. The removal of the latter elements are not considered in the current version of OpenSees. However, they will be available in near future. Current version considers only the removal of the infill wall model described in the first section.\nImplementation of the removal of the elements representing the aforementioned infill wall analytical model in the progressive collapse algorithm is performed through defining a removal criterion for the beam-column elements of this model. This criterion is based on the interaction between the IP and OOP displacements. IP displacement is the relative horizontal displacement between the top and bottom nodes of the diagonal element. OOP displacement is that of the middle node (where the OOP mass is attached) with respect to the chord which connects the top and bottom nodes. The user is free to choose any interaction relationship between IP and OOP displacements. In the recent studies conducted with the introduced infill wall element [14, 15], same equation used for the strength interaction is considered for the displacement interaction, where IP and OOP displacement capacities in the presence of zero load in the other direction are obtained from FEMA-356 for collapse prevention level. During the nonlinear time history simulation, when the mentioned combination of displacements from the analysis exceeds the interaction curve (Figure 6), the two beam-column elements and the middle node, representing the unreinforced masonry infill wall, are removed. The procedure for the removal of an infill wall is presented in Figure 7.\nFigure6.jpg Figure7-2.jpg New Command in OpenSees Interpreter The only new tcl command in the OpenSees interpreter with respect to the infill wall removal is the collapse recorder. Three collapse recorders (the syntax of which are indicated below) are needed for the consideration of the removal of an infill wall. These collapse recorders should be defined individually for each infill wall that the user would like to be considered for removal.\nrecorder Collapse -ele $ele1 -time -crit INFILLWALL -file $filename \\ -file_infill $filenameinf -global_gravaxis $globgrav -checknodes $nodebot $nodemid $nodetop recorder Collapse -ele $ele2 -time -crit INFILLWALL -file_infill \\ $filenameinf -global_gravaxis $globgrav -checknodes $nodebot $nodemid $nodetop recorder Collapse -ele $ele1 $ele2 -node $nodemid $ele1, $ele2, $nodebot, $nodemid, and $nodetop are shown in Figure 8. Element objects store the identities of their associated Node objects in the data structures of OpenSees. Therefore, it might seem that node inputs are unnecessary. However, when there are shear springs in the model, $nodetop and $nodebot should be the nodes of the springs which connect to the beams, since the shear spring deformation contributes to the IP displacement of the infill wall. These nodes are not the nodes of the diagonal element. Therefore, it is necessary to input these nodes. $filename is the file name for element removal log. Only one log file is constructed for all collapse recorder commands (i.e. for all removals). The first file name input to a collapse recorder command is used and any subsequent file names are ignored. $filenameinf is the file used to input the displacement interaction curve. Two columns of data are input in this file where only positive values are input. First column is the OOP displacement in ascending order and second column is the corresponding IP displacement. Full interaction should be defined. In other words, first value of OOP displacement and last value of IP displacement should be zero. -crit INFILLWALL is used to state that the removal is for the infill wall, because there will be options for removal of other elements in the next versions of OpenSees as mentioned previously. $globgrav is the global axis of the model in the direction of gravity. 1, 2 and 3 should be input for X, Y and Z axes, respectively. For example, it is equal to 2 in Figure 1.\nFigure8.jpg Example Files related to the example can be downloaded from the links below. This example is based on “Example 8. generic 3D Frame, NStory NBayX NBayZ, Reinforced-Concrete Section” which is available in OpenSees Examples Manual. Main file is “Model_IR.tcl”. Lines 326-469 in this file are related to the infill wall model and element removal. File which conducts time history analysis is NRHA_IR.tcl. Ground motion files (PUL194.tcl, PUL104.tcl) should be located under a directory named “GMFiles”. Calculation of the infill wall parameters are summarized in the file Calculations.pdf. This file is created using Mathcad originally by Stephen Kadysiewski. Interested users can request the Mathcad file by sending email to selimgunay [at] berkeley . edu or mosalam [at] ce . berkeley . edu\nFiles Model_IR.tcl NRHA_IR.tcl ReadSMDFile_IR.tcl LibAnalysisDynamicParameters_IR.tcl DisplayModel3D_IR.tcl DisplayPlane_IR.tcl BuildRCrectSection_IR.tcl LibMaterialsRC_IR.tcl LibUnits_IR.tcl Dispwall1-cg.tcl PUL194.tcl PUL104.tcl Calculations.pdf References Kadysiewski, S. and Mosalam, K.M. (2009), “Modeling of Unreinforced Masonry Infill Walls Considering In-plane and Out-of-Plane Interaction”, Pacific Earthquake Engineering Research Center, PEER 2008/102.\nKadysiewski, S. and Mosalam, K.M. (2009), “Modelling of Unreinforced Masonry Infill Walls Considering In-Plane and Out-of-Plane Interaction”, Proceedings of the 11th Canadian Masonry Symposium, Toronto, Ontario, May 31-June 6.\nHashemi, S.A. and Mosalam, K.M. (2007), “Seismic Evaluation of Reinforced Concrete Buildings Including Effects of Infill Masonry Walls”, Pacific Earthquake Engineering Research Center, PEER 2007/100.\nTalaat, M. and Mosalam, K.M. (2008), “Computational Modeling of Progressive Collapse in Reinforced Concrete Frame Structures”, Pacific Earthquake Engineering Research Center, PEER 2007/10.\nTalaat, M. and Mosalam, K.M. (2009), “Modeling Progressive Collapse in Reinforced Concrete Buildings Using Direct Element Removal”, Earthquake Engineering and Structural Dynamics, 38(5): 609-634.\nTalaat, M. and K. M. Mosalam, K.M. (2009), Chapter20: How to Simulate Column Collapse and Removal in As-built and Retrofitted Building Structures?, in Seismic Risk Assessment and Retrofitting - with special emphasis on existing low-rise structures, Ilki, A, Karadogan, F, Pala, S \u0026 Yuksel, E (Eds), ISBN 978-90-481-2680-4, Springer.\nTalaat, M. and Mosalam, K.M. (2006), “Progressive Collapse Modeling of Reinforced Concrete Framed Structures Containing Masonry Infill Walls”, Proceedings of the 2nd NEES/E-Defense Workshop on Collapse Simulation of Reinforced Concrete Building Structures, Kobe, Japan.\nTalaat, M. and Mosalam, K.M. (2007), “Towards Modeling Progressive Collapse in Reinforced Concrete Buildings”, Proceedings of SEI-ASCE 2007 Structures Congress, Long Beach, California, USA.\nMosalam, K.M., Talaat, M., and Park, S. (2008), “Modeling Progressive Collapse in Reinforced Concrete Framed Structures”, Proceedings of the 14th World Conference on Earthquake Engineering, Beijing, China, October 12-17, Paper S15-018.\nMosalam, K.M., Park, S., Günay, M.S. (2009), “Evaluation of an Element Removal Algorithm for Reinforced Concrete Structures Using Shake Table Experiments,” Proceedings of the 2nd International Conference on Computational Methods in structural Dynamics and Earthquake Engineering (COMPDYN 2009), Island of Rhodes, Greece, June 22-24.\nBinici, B. and Mosalam, K.M. (2007), “Analysis of Reinforced Concrete Columns Retrofitted With Fiber Reinforced Polymer Lamina,” Composites Part B: Engineering, 38(2): 265-276.\nMosalam, K.M., Talaat, M., and Binici, B. (2007), “A Computational Model for Reinforced Concrete Members Confined with Fiber Reinforced Polymer Lamina: Implementation and Experimental Validation,” Composites Part B: Engineering, 38(5-6): 598-613.\nMosalam, K.M., Talaat, M., and Binici, B. (2007), “Computational Model for FRP-Confined RC Members”, Proceedings of the 8th International Symposium on Fiber Reinforced Polymer Reinforcement for Concrete Structures (FRPRCS-8), University of Patras, Patras, Greece.\nMosalam, K.M., and Günay, S. (2010), Chapter 33: Seismic Retrofit of Non-Ductile Reinforced Concrete Frames Using Infill Walls as a Rocking Spine, in Advances in Performance-Based Earthquake Engineering, Geotechnical, Geological, and Earthquake Engineering, Fardis, M.N. (Ed.), Springer.\nGünay, S., Korolyk, M., Mar D., Mosalam, K.M., and Rodgers, J. (2009), “Infill Walls as a Spine to Enhance the Seismic Performance of Non-Ductile Reinforced Concrete Frames,” Proceedings of the ATC\u0026SEI Conference on Improving the Seismic Performance of Existing Buildings and Other Structures, December 9-11, San Francisco, California.\nM. Selim Gunay and Khalid M. Mosalam, University of California, Berkeley\n","tags":["seismic"],"title":"Infill Wall Model and Element Removal","uri":"/opensees-gallery/community/infillwall/"},{"content":" Examples element KikuchiBearing 1 1 2 -shape round -size 1.016 0.320 -nMSS 8 \\ -matMSS 1 -nMNS 30 -matMNS 2 KikuchiBearing_Sample.tcl, KikuchiBearing_input_Z.tcl, KikuchiBearing_input_X.tcl\ncase 1: P-Delta effect not considered (use -noPDInput -noTilt option)\ncase 2: P-Delta effect considered, uniform distribution of compression modulus\ncase 3: P-Delta effect considered (use -lambda option)\n            References M. Kikuchi , I. D. Aiken and A. Kasalanati , \"Simulation analysis for the ultimate behavior of full-scale lead-rubber seismic isolation bearings\", 15th World Conference on Earthquake Engineering, No. 1688, 2012.\nCode Developed by: mkiku ","tags":["Other"],"title":"Kikuchi Bearing","uri":"/opensees-gallery/community/kikuchibearing/"},{"content":"This example explores the uniaxial KikuchiAikenHDR material. This material model produces nonlinear hysteretic curves of high damping rubber bearings (HDRs).\nuniaxialMaterial KikuchiAikenHDR $matTag $tp $ar $hr \u003c -coGHU $cg $ch $cu \u003e \u003c -coMSS $rs $rf \u003e matTag integer tag identifying material\ntp rubber type (see note 1)\nar area of rubber [unit: m^2] (see note 2)\nhr total thickness of rubber [unit: m] (see note 2)\ncg ch cu\ncorrection coefficients for equivalent shear modulus (cg), equivalent viscous daming ratio (ch), ratio of shear force at zero displacement (cu).\n`rs` `rf`\nreduction rate for stiffness (rs) and force (rf) (see note 3)\nNotes Following rubber types for tp are available:\nX0.6\nBridgestone X0.6, standard compressive stress, up to 400% shear strain\nX0.6-0MPa\nBridgestone X0.6, zero compressive stress, up to 400% shear strain\nX0.4\nBridgestone X0.4, standard compressive stress, up to 400% shear strain\nX0.4-0MPa\nBridgestone X0.4, zero compressive stress, up to 400% shear strain\nX0.3\nBridgestone X0.3, standard compressive stress, up to 400% shear strain\nX0.3-0MPa\nBridgestone X0.3, zero compressive stress, up to 400% shear strain\nThis material uses SI unit in calculation formula. ar and hr must be converted into [m^2] and [m], respectively.\nrs and rf are　available if this material is applied to multipleShearSpring (MSS) element. Recommended values are rs=1/sum(i=0,n-1){ sin(pii/n)^2} and rf=1/sum(i=0,n-1){sin(pii/n)}, where n is the number of springs in the MSS. For example, when n=8, rs=0.2500, rf=0.1989.\nExamples KikuchiAikenHDR_sample.tcl\nKikuchiAikenHDR_StressStrain.png Code Developed by: mkiku ","title":"KikuchiAikenHDR","uri":"/opensees-gallery/community/kikuchiaikenhdr/"},{"content":"This article describes the OpenSees implementation of a simple laterally-loaded pile example. The problem is modeled as a beam on a nonlinear Winkler foundation (BNWF), utilizing displacement-based beam elements for the pile and nonlinear spring elements which represent the vertical and lateral response of the surrounding soil. This example considers a static analysis only.\nProvided with this article are the files needed to execute this analysis in OpenSees;\nthe main input file, staticBNWFpile.tcl three procedures to define the soil constitutive behavior, Get_pyParam.tcl, Get_tzParam.tcl, and Get_qzParam.tcl a file to define the pile section behavior, ElasticPileSection.tcl Download them all in a compressed file: staticBNWFanalysis.zip\nTo run this example, the user must download each of the above files and place them in a single directory. Once this has been done, the user can then type source staticBNWFpile.tcl into the interpreter of the OpenSees.exe application to run the analysis. Representative results are presented in this article to verify the correct implementation of this example. Additionally, the pile response obtained from this analysis is compared to a similar analysis conducted using the commercial program LPile (http://www.ensoftinc.com) to provide verification the results of the OpenSees analysis.\nModel Description Fig 1. Schematic representation of the BNWF model. The BNWF model simulates the laterally-loaded pile problem using displacement-based beam elements to represent the pile and a series of nonlinear springs to represent the soil. The soil springs are generated using zero-length elements assigned separate uniaxial material objects in the lateral and vertical directions. An idealized schematic of the laterally-loaded pile model is provided in Fig. 1.\nThe pile axis is oriented in the z-coordinate direction, and all of the nodes are initially located on the z-axis (x- and y- coordinates are zero). Node numbering for each set of nodes begins at the bottom of the pile. The model is created with three separate sets of nodes:\nfixed spring nodes (numbers 1-85 in example) slave spring nodes (numbers 101-185 in example) pile nodes (numbers 201-285 in example) Geometry and Mesh The geometry is rather simple in this example. There is only a single layer of cohesionless soil, and the groundwater table is assumed to be well below the tip of the pile. The pile geometry controls the meshing of the problem. The user can specify the length of the pile head (above the ground surface), L1, and the embedded pile length (below the ground surface), L2. The default values in staticBNWFpile.tcl are L1 = 1 m, and L2 = 20 m. The pile is also assigned a diameter of 1 m. This value is used in the soil constitutive modeling.\nThe mesh is defined by the number of elements specified in the pile. The default value in this example is 84 elements (85 nodes). For the default pile geometry, this results in 80 elements over the embedded length and 4 elements above the ground surface. Note: The input file is only set up to handle up to 100 nodes. Modifications would need to be made to the node numbering scheme to accommodate a larger number of nodes.\nSpring Nodes The spring nodes are created with three dimensions and three translational degrees-of-freedom. The input file is set up to automatically generate the necessary spring nodes and elements based upon the input geometry (pile head length, `$L1`, embedded length, `$L2`, and number of pile elements, `$nElePile`). Spring nodes are only created over the embedded length of pile. Since zero-length elements are used for the springs, the two sets of nodes share the same set of locations. One set of spring nodes, the fixed-nodes, are initially fixed in all three degrees-of-freedom. The other set of nodes, the slave nodes, are initially fixed in only two degrees-of-freedom, and are later given equal degrees-of-freedom with the pile nodes.\nSpring Constitutive Behavior The constitutive behavior of the springs is defined such that the springs oriented in the lateral direction represent p-y springs, and the vertically-oriented springs represent t-z and Q-z springs for the pile shaft and tip, respectively. Three procedures are used to properly define the p-y/t-z/Q-z behavior with depth, get_pyParam.tcl, get_tzParam.tcl, and get_qzParam.tcl\nSeveral input soil properties are necessary to define these springs:\nsoil unit weight, `$gamma` soil internal friction angle, `$phi` soil shear modulus, `$Gsoil` The default values are set at $gamma = 17 kN/m^3, $phi = 36 degrees, and $Gsoil = 150000 kPa.\nThe procedure get_pyParam.tcl, which defines the p-y springs, has several options which must be selected.\nThe first switch, `$puSwitch`, specifies the variation in ultimate lateral resistance with depth. The default, `$puSwitch` = 1, uses the recommendations of the American Petroleum Institute (API) (1993). The alternative method is that of Brinch Hansen (1961). The second switch, `$kSwitch`, specifies the variation in initial stiffness with depth. The default, `$kSwitch` = 1, specifies a linear variation of initial stiffness with depth (API 1993). The alternative uses a modified version of the API stiffness which varies parabolically with depth after Boulanger et al. (2003). The presence of groundwater can be accounted for in the initial stiffness using the third switch, `$gwtSwitch`. Default, `$gwtSwitch` = 1, is for no groundwater. The other procedures, get_tzParam.tcl and get_qzParam.tcl, have no input options in this example. The t-z springs have behavior defined using the work of Mosher (1984) and Kulhawy (1991). The Q-z behavior is based on the work of Meyerhof (1976), Vijayvergiya (1977), and Kulhawy and Mayne (1990).\nThe p-y spring constitutive behavior is obtained using the PySimple1 uniaxial material object. The t-z and Q-z springs are defined using the TzSimple1 and QzSimple1 uniaxial materials, respectively. The main input file is set up to automatically generate the required spring material objects based upon the input geometry and soil properties.\nSpring Elements Zero-length elements are used for the soil springs using the element zeroLength. These elements connect the fixed and slave spring nodes. The the PySimple1 material objects are incorporated in the x-direction (direction of loading), while the TzSimple1, and at the pile tip, the QzSimple1, material objects are incorporated in the z-direction (vertical direction).\nPile Nodes The pile nodes are created with three dimensions and six degrees-of-freedom (3 translational, 3 rotational). The input file is set up to automatically generate the necessary pile nodes and elements based upon the input geometry. A linear coordinate-transformation object is specified for the orientation of the pile in this example. With the exemption of the uppermost pile head node, the pile nodes are fixed against translation in the y-direction and rotations about the x- and z- axes. The pile head node, where the load is applied, is separated to allow the user to specify a free-head (no rotational fixity) or fixed-head (full rotational fixity) condition at the loading point.\nThe pile nodes over the embedded length of the pile are use linked with the slave spring nodes using the equalDOF command. The pile nodes are the master nodes in this example. These two sets of nodes share equal degrees-of-freedom in the x- and z- translational directions only.\nPile Constitutive Behavior and Elements In this example, the pile is given elastic behavior for simplicity. Instead of using the elasticBeamColumn element, this is done using an elastic section object in conjunction with the displacement-based beam element, dispBeamColumn. This was done to facilitate future incorporation of elastoplastic pile section behavior using fiber section models by the user.\nThe properties of the elastic section for this example are defined in the file, elasticPileSection.tcl. The pile is defined with appropriately computed values for the cross-sectional area and the moments of inertia for its 1 m diameter, and is assigned a modulus of elasticity, E = 25000000, and shear modulus, G = 9615385.\nRecorders Several recorders are defined for this model.\nThe displacements at the pile nodes in all three translational dof are recorded for use in extracting the displaced shape of the pile. The reaction forces in the p-y springs are recorded for use in visualizing the lateral soil response. The element forces in the pile elements are recorded in order to obtain shear and moment diagrams for the pile. The recorders are set up to only record values at 0.5 second increments of pseudo-time during the analysis to facilitate the use of smaller load steps. This is done with the variable $timeStep.\nA display recorder is included in the input file to allow the user to visualize the deformation of the pile in “real time” during the analysis. The parameters are set up for the orientation of the pile in this example.\nLoading This example considers a 3500 kN load applied in the positive x-direction at the head of the pile (uppermost pile node). This is accomplished in the model using a plain pattern with optional time-series parameters. The load increases linearly from 0 kN to 3500 kN over a 10 second increment of pseudo-time (between 10 and 20 seconds) and is then held constant after the loading period. Setting up the loading object in this manner allows for more control over the analysis.\nAnalysis The analysis is conducted using the load-controlled integrator with a loading step of 0.05. This value is selected based on the 10 second interval specified in the loading object. 200 steps with a loading step of 0.05 will put the last step exactly at 10 seconds of pseudo-time. 201 steps are used in this example to make sure that the last recorded step is at the full loading magnitude. The variables $startT and $endT are used to print the cpu time needed to complete the analysis in the standard output or the OpenSees interpreter. The remaining analysis commands are well-documented in the OpenSees command manual.\nRepresentative Results Fig. 2 Lateral soil response after application of full lateral load. A user can verify their downloaded files by running the main input file, StaticBNWFpile.tcl, in OpenSees and comparing the recorded results to some representative results included here. The simplest verification is to use the spring reaction forces recorded in the file reaction.out. A plot of the recorded spring reaction forces vs. depth in the final recorded pseudo-time step (20.05) should create something similar to that shown in Fig. 2. The response is negative from the ground surface to about 7.5 m deep, then transitions to positive until about 13 m deep, has a second smaller negative section, and then is nearly zero near the tip of the pile.\nThis verification plot can be made fairly simply using spreadsheet software. For those who prefer Matlab (http://www.mathworks.com/), the following lines will extract the desired information when pasted into an m-file.\n% create depth vector depth = linspace(-20,1,85); % load data react = load('reaction.out'); % remove pseudo-time information react(:,1) = []; % create plotting variable (divide by tributary area of pile to get force/length) reactPlot = react(end,:)/0.25; plot(reactPlot,depth) The shear and moment diagram plots in the following section can also be used for verification purposes.\nComparison of OpenSees Results with LPile Fig. 3 Comparison of OpenSees and LPile analyses for free-head case. Fig. 4 Comparison of OpenSees and LPile analyses for fixed-head case. The commercial pile analysis program LPile (http://www.ensoftinc.com) is used to verify the results obtained using the OpenSees laterally-loaded pile model. The LPile analysis used the same geometric and constitutive parameters defined in the OpenSees analysis, and two cases were considered:\nA free-head case where there is no rotational fixity about the y-axis at the pile head A fixed-head case where full rotational fixity is enforced at the pile head. The two analysis methods are compared via the recorded pile and soil responses. Figs. 3 and 4 present these comparisons for the free-head and fixed-head cases, respectively. Shown in these figures are the shear and moment diagrams, displaced pile shapes, and the lateral soil response recorded from each analysis. As shown, the LPile and OpenSees results are fairly similar, especially for the free-head case.\nThe main reason for the differences shown in Figs. 3 and 4 is that the p-y curves used in LPile are not the same as those used in the OpenSees analysis. The LPile curves are defined using the method of Reese et al. (1974), while the backbone of the p-y curves for the PySimple1 uniaxial material approximate the API (1993) recommendations. These two sets of curves are similar, and in fact have identical initial and ultimate responses, however, they vary in form over intermediate displacements.\nThis is shown in Fig. 5, which plots the actual p-y response obtained in the OpenSees simulation alongside the p-y curves used by LPile for several depths. As shown, the hyperbolic tangent curves recommended by the API do not match those used by LPile, especially for displacements between approximately 0.001 and 0.037 m. The force returned by the PySimple1 material object for displacements in this range will therefore be greater than corresponding forces used by LPile. This is confirmed by the soil response comparison plots in Figs. 3 and 4. Where the pile displacements are large, the LPile and OpenSees soil reactions are nearly identical, but as the displacements become smaller with increasing depth, the recorded soil reactions begin to differ. This difference in lateral soil response is the main reason behind the small variability observed in the recorded shear and moment diagrams and displaced shapes.\nFig. 5 Comparison of p-y curves for LPile and OpenSees analyses. Overall, the agreement between the OpenSees and LPile analyses verifies that the BNWF model implemented in OpenSees is capable of returning sensible results for laterally-loaded pile simulations. There are differences between the results, however, these are relatively minor. The OpenSees simulation predicts maximum pile shear, moment, and deflection demands which are similar to those obtained from LPile, and the discrepancies are attributable to known differences between the two analysis methods.\nReferences American Petroleum Institute (API) (1987). Recommended Practice for Planning, Designing and Constructing Fixed Offshore Platforms. API Recommended Practice 2A(RP-2A), Washington D.C, 17th edition. Brinch Hansen, J. (1961). “The ultimate resistance of rigid piles against transversal forces.” Bulletin No. 12, Geoteknisk Institute, Copenhagen, 59. Boulanger, R. W., Kutter, B. L., Brandenberg, S. J., Singh, P., and Chang, D. (2003). Pile Foundations in liquefied and laterally spreading ground during earthquakes: Centrifuge experiments and analyses. Center for Geotechnical Modeling, University of California at Davis, Davis, CA. Rep. UCD/CGM-03/01. Kulhawy, F.H. (1991). “Drilled shaft foundations.” Foundation engineering handbook, 2nd Ed., Chap 14, H.-Y. Fang ed., Van Nostrand Reinhold, New York. Kulhawy, F.H. and Mayne, P.W. (1990). Manual on Estimating Soil Properties for Foundation Design. Electrical Power Research Institute. EPRI EL-6800, Project 1493-6 Final Report. Meyerhof G.G. (1976). “Bearing capacity and settlement of pile foundations.” J. Geotech. Eng. Div., ASCE, 102(3), 195-228. Mosher, R.L. (1984). “Load transfer criteria for numerical analysis of axial loaded piles in sand.” U.S. Army Engineering and Waterways Experimental Station, Automatic Data Processing Center, Vicksburg, Miss. Reese, L.C. and Van Impe, W.F. (2001), Single Piles and Pile Groups Under Lateral Loading. A.A. Balkema, Rotterdam, Netherlands. Vijayvergiya, V.N. (1977). “Load-movement characteristics of piles.” Proc., Ports 77 Conf., ASCE, New York. Example prepared by: Christopher McGann and Pedro Arduino, University of Washington\n","tags":["piles"],"title":"Laterally-Loaded Pile Foundation","uri":"/opensees-gallery/community/staticbnwfpile/"},{"content":"Application of a limit state material is demonstrated on an example of a column modeled with force-based beam-column element. Three types of analysis are performed on a same column:\npushover analysis cyclic analysis time history analysis Static analyses: pushover and cyclic\nMain file to source to perform pushover analysis is:\nCenterCol_basicModel_Pushover.tcl Main file to source to perform cyclic analysis is:\nCenterCol_basicModel_Cyclic.tcl Supporting files to be stored in the same folder with the main file:\nCenterColAxialSpring.tcl CenterColShearSpring.tcl CenterColSecFiber.tcl tags.tcl Time history analysis\nMain file to source to perform time history analysis is:\nCenterCol_basicModel_Dynamic.tcl Supporting files to be stored in the same folder with the main file:\nCenterColAxialSpring.tcl CenterColShearSpring.tcl CenterColSecFiber.tcl tags.tcl Dynamic.EQ.Uniform_LimitState.tcl LibAnalysisDynamicParameters_LimitState.tcl ReadSMDFile.tcl DisplayModel2D.tcl DisplayPlane.tcl TCU047-N.tcl Original code debugged and extended to include time history analysis by: Mohammad Reza Azadi Kakavand, College of Engineering, University of Tehran, Iran ","title":"Limit State Material Example","uri":"/opensees-gallery/community/limitstatematerial/"},{"content":"This command is used to construct a multipleShearSpring (MSS) element object, which is defined by two nodes. This element consists of a series of identical shear springs arranged radially to represent the isotropic behavior in the local $y$-$z$ plane.\nelement multipleShearSpring $eleTag $iNode $jNode $nSpring -mat $matTag \u003c -lim $dsp \u003e \u003c -orient \u003c $x1 $x2 $x3 \u003e $yp1 $yp2 $yp3 \u003e \u003c -mass $m \u003e eleTag unique element object tag\ninode jnode\nend nodes\nnSpring number of springs\nmatTag tag associated with previously-defined UniaxialMaterial object\ndsp minimum deformation to calculate equivalent coefficient (see note 1)\nx1 x2 x3\nvector components in global coordinates defining local x-axis\nyp1 yp2 yp3\nvector components in global coordinates defining vector `yp` which lies in the local $x$-$y$ plane for the element\nm element mass\nNOTES:\n1. If dsp is positive and the shear deformation of MSS exceeds dsp, this element calculates equivalent coefficient to adjust force and stiffness of MSS. The adjusted MSS force and stiffness reproduce the behavior of the previously defined uniaxial material under monotonic loading in every direction. If dsp is zero, the element does not calculate the equivalent coefficient.\n2. The valid queries to a multipleShearSpring element when creating an ElementRecorder object are `globalForce`, `localForce`, `basicForce`, `localDisplacement` and `basicDeformation`.\nExamples MultipleShearSpring_Model.png element multipleShearSpring 1 1 2 16 -mat 1 MultipleShearSpring_Sample.tcl, MultipleShearSpring_input_X.tcl, MultipleShearSpring_input_Y.tcl\n\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; References Wada. A. and Hirose K. , \"Building Frames Subjected to 2D Earthquake Motion\", Seismic Engineering: Research and Practice, American Society of Civil Engineers, 388-397, 1989.\nCode developed by: mkiku ","title":"MultipleShearSpring","uri":"/opensees-gallery/community/multipleshearspring/"},{"content":"This example is sourced from https://openseespydoc.readthedocs.io/en/latest/src/ThreeStorySteel.html\n","tags":["Python","Steel"],"title":"Plane Steel Frame","uri":"/opensees-gallery/examples/steelframe2d/"},{"content":"This example demonstrates how to perform a pushover (nonlinear static) analysis in OpenSees using a 2-story, 1-bay steel moment resisting frame. In the first model, the nonlinear behavior is represented using the concentrated plasticity concept with rotational springs. In the second model, the nonlinear behavior is represented using the distributed plasticity concept where the plastic behavior occurs over a finite length. The rotational behavior of the plastic regions in both models follows a bilinear hysteretic response based on the Modified Ibarra Krawinkler Deterioration Model (Ibarra et al. 2005, Lignos and Krawinkler 2009, 2010). For this example, all modes of cyclic deterioration are neglected. A leaning column carrying gravity loads is linked to the frame to simulate \\(P-\\Delta\\) effects.\nThe files needed to analyze this structure in OpenSees are included here:\nThe main files: pushover_concentrated.tcl and pushover_distributed.tcl Supporting procedure files\nrotSpring2DModIKModel.tcl - creates a bilinear rotational spring that follows the Modified Ibarra Krawinkler Deterioration Model (used in the concentrated model) rotSect2DModIKModel.tcl - creates a section with bilinear rotational response that follows the Modified Ibarra Krawinkler Deterioration Model and an elastic axial response (used in the distributed model) rotLeaningCol.tcl - creates a low-stiffness rotational spring used in a leaning column All files are available in a compressed format here: pushover_example.zip\nThe rest of this example describes the models and compares their analysis results. The OpenSees models are also compared to an equivalent model built and analyzed using the commercial program SAP2000 (http://www.csiberkeley.com/products_SAP.html).\nModel Description Figure 1. Schematic representation of concentrated plasticity OpenSees model with element number labels and [node number] labels. Note: The springs are zeroLength elements, but their sizes are greatly exaggerated in this figure for clarity. Concentrated Plasticity Model Overview The 2-story, 1-bay steel moment resisting frame is modeled with elastic beam-column elements connected by zeroLength elements which serve as rotational springs to represent the structure’s nonlinear behavior. The springs follow a bilinear hysteretic response based on the Modified Ibarra Krawinkler Deterioration Model. A leaning column with gravity loads is linked to the frame by truss elements to simulate P-Delta effects. An idealized schematic of the model is presented in Figure 1.\nFigure 2. Schematic representation of distributed plasticity OpenSees model with element number labels and [node number] labels. Note: The springs are zeroLength elements, but their sizes are greatly exaggerated in this figure for clarity. Distributed Plasticity Model Overview The 2-story, 1-bay steel moment resisting frame is modeled using \"beam with hinges\" elements. Plastic hinge regions are assigned to the ends of these elements. The plastic regions have an elastic axial response and a bilinear rotational response based on the Modified Ibarra Krawinkler Deterioration Model. An idealized schematic of the model is presented in Figure 2.\nFeatures Common to Both Models A leaning column with gravity loads is linked to the frame by truss elements to simulate P-Delta effects.\nTo simplify this model, panel zone contributions are neglected and plastic hinges form at the beam-column joints, i.e., centerline dimensions are used. For an example that explicitly models the panel zone shear distortions and includes reduced beam sections (RBS), see Pushover and Dynamic Analyses of 2-Story Moment Frame with Panel Zones and RBS.\nThe units of the model are kips, inches, and seconds.\nBasic Geometry The basic geometry of the frame is defined by input variables for the bay width, height of the first story, and height of a typical (i.e. not the first) story. These values are set as WBay = 360”, HStory1 = 180”, and HStoryTyp = 144”. The leaning column line is located one bay width away from the frame. In addition to the nine beam-column joint nodes, there is one additional node for each spring, which connects the spring to the elastic element. This makes a total of 24 nodes in the structure for the concentrated plasticity model compared to 12 nodes in the distributed plasticity model.\nLeaning Columns and Frame Links The leaning columns are modeled as elastic beam-column elements. These columns have moments of inertia and areas about two orders of magnitude larger than the frame columns in order to represent aggregate effect of all the gravity columns (A\u003csub\u003eleaning column\u003c/sub\u003e = 1,000.0 in\u003csup\u003e2\u003c/sup\u003e and I\u003csub\u003eleaning column\u003c/sub\u003e = 100,000.0 in\u003csup\u003e4\u003c/sup\u003e). The columns are connected to the beam-column joint by zeroLength rotational spring elements with very small stiffness values so that the columns do not attract significant moments. These springs are created using rotLeaningCol.tcl.\nTruss elements are used to link the frame and leaning columns and transfer the P-Delta effect. The trusses have areas about two orders of magnitude larger than the frame beams in order to represent aggregate effect of all the gravity beams (A\u003csub\u003etruss\u003c/sub\u003e = 1,000.0 in\u003csup\u003e2\u003c/sup\u003e) and can be assumed to be axially rigid.\nRotational Springs (Concentrated Plasticity Model) The rotational springs capture the nonlinear behavior of the frame. As previously mentioned, the springs in the example employ a bilinear hysteretic response based on the Modified Ibarra Krawinkler Deterioration Model. Detailed information about this model and the modes of deterioration it simulates can be found in Ibarra et al. (2005) and Lignos and Krawinkler (2009, 2010).\nIn this example, the zeroLength spring elements connect the elastic frame elements to the beam-column joint nodes. The springs are created using rotSpring2DModIKModel.tcl.\nPlastic Hinge Regions (Distributed Plasticity Model) In this model the plasticity is distributed over a defined length. The axial and flexural responses of each plastic hinge region are defined as separate sections. The axial response is defined by an elastic section while the flexural response is defined by a uniaxial section using the bilinear material based on the Modified Ibarra Krawinkler Deterioration Model. The responses are combined into a single section using the section aggregator command. P-M interactions are neglected in this example as the axial loads are relatively low and are not expected to have a significant influence.\nPlasticity Features Common to Both Models The input parameters for the rotational behavior of the plastic hinges in both models are determined using empirical relationships developed by Lignos and Krawinkler (2010) which are derived from an extensive database of steel component tests. Alternatively, these input parameters can be determined using approaches similar to those described in FEMA 356 (http://www.fema.gov/library/viewRecord.do?id=1427), ATC-72 and ATC-76 (http://www.atcouncil.org/index.php?option=com_content\u0026view=article\u0026id=45\u0026Itemid=54). In order to simplify the model, cyclic deterioration was ignored. This was accomplished by setting all of the “L” deterioration parameter variables to 1000.0, all of the “c” exponent variables to 1.0, and both “D” rate of cyclic deterioration variables to 1.0.\nStiffness Modifications to Elastic Frame Elements (Concentrated Plasticity Model) Since a frame member is modeled as an elastic element connected in series with rotational springs at either end, the stiffness of these components must be modified so that the equivalent stiffness of this assembly is equivalent to the stiffness of the actual frame member. Using the approach described in Appendix B of Ibarra and Krawinkler (2005), the rotational springs are made “n” times stiffer than the rotational stiffness of the elastic element in order to avoid numerical problems and allow all damping to be assigned to the elastic element. To ensure the equivalent stiffness of the assembly is equal to the stiffness of the actual frame member, the stiffness of the elastic element must be “(n+1)/n” times greater than the stiffness of the actual frame member. In this example, this is accomplished by making the elastic element’s moment of inertia “(n+1)/n” times greater than the actual frame member’s moment of inertia.\nStiffness Modifications to the Plastic Hinges (Both Models) In order to make the nonlinear behavior of the assembly match that of the actual frame member, the strain hardening coefficient (the ratio of post-yield stiffness to elastic stiffness) of the plastic hinge must be modified. If the strain hardening coefficient of the actual frame member is denoted $\\alpha$\u003csub\u003es,mem\u003c/sub\u003e and the strain hardening coefficient of the spring (or plastic hinge region) is denoted $\\alpha_\\textrm{s,spring}$ then $\\alpha_\\textrm{s,spring}$ $\\alpha_\\textrm{s,spring}$ $\\alpha_\\textrm{s,spring}$ $\\alpha_\\textrm{s,spring}$ = $\\alpha_\\textrm{s,spring}$ $\\alpha_\\textrm{s,spring}$ \u003cmath\u003e\\alpha\u003c/math\u003e\u003csub\u003es,mem\u003c/sub\u003e / (1 + n*(1 - \u003cmath\u003e\\alpha\u003c/math\u003e\u003csub\u003es,mem\u003c/sub\u003e))\nNote that this is a corrected version of Equation B.5 from Ibarra and Krawinkler (2005).\nConstraints The frame columns are fixed at the base, and the leaning column is pinned at the base. To simulate a rigid diaphragm, the horizontal displacements of all nodes in a given floor are constrained to the leftmost beam-column joint node using the equalDOF command.\nMasses The mass is concentrated at the beam-column joints of the frame, and each floor mass is distributed equally among the frame nodes. The mass is assigned using the node command, but it could also be assigned with the mass command.\nLoading Gravity loads are assigned to the beam-column joint nodes using the nodal load command. Gravity loads tributary to the frame members are assigned to the frame nodes while the remaining gravity loads are applied to the leaning columns. The gravity loads are applied as a plain load pattern with a constant time series since the gravity loads always act on the structure.\nIn this example, lateral loads are distributed to the frame using the methodology of ASCE 7-10 (http://www.asce.org/Product.aspx?id=2147487569). Lateral loads are applied to all the frame nodes in a given floor. A plain load pattern with a linear time series is used for lateral load application so that loads increase with time.\nRecorders The recorders used in this example include:\nThe drift recorder to track the story and roof drift histories The node recorder to track the base shear reaction history The element recorder to track the element forces in the first story columns as well as the moment and rotation histories of the springs in the concentrated plasticity model To record the moment and rotation histories in the springs, the region command was used to assign all column springs to one group and all beam springs to a separate group, and the region was used as an input to the element recorder.\nIt is important to note that the recorders only record information for analyze commands that are called after the recorder commands are called. In this example, the recorders are placed after the gravity analysis so that the steps of the gravity analysis do not appear in the output files.\nAnalysis The structure is first analyzed under gravity loads before the pushover analysis is conducted. The gravity loads are applied using a load-controlled static analysis with 10 steps. So that the gravity loads remain on the structure for all subsequent analyses, the loadConst command is used after the gravity analysis is completed. This command is also used to reset the time to zero so that the pushover starts from time zero.\nThe pushover analysis is performed using a displacement-controlled static analysis. In this example, the structure was pushed to 10% roof drift, or 32.4”. The roof node at Pier 1, node 13 in Figures 1 and 2, was chosen as the control node where the displacement was monitored. Incremental displacement steps of 0.01” were used. This step size was used because it is small enough to capture the progression of hinge formation and generate a smooth backbone curve, but not too small that it makes the analysis time unreasonable.\nResults Comparison of OpenSees Models Figure 3. Pushover Curve: Comparison of OpenSees Models Theoretically, the results of the distributed plasticity model should approach those of the concentrated plasticity model as the length of the plastic hinge regions approaches zero. Because of localized instability due to the stress-strain formulation of the beam with hinges element, the distributed plasticity model does not give reasonable results when the length of the plastic hinge is very small (i.e., 10e\u003csup\u003e-5\u003c/sup\u003e). Therefore, the length of the plastic hinges was increased from 10e\u003csup\u003e-5\u003c/sup\u003e until the results of this model approached those of the concentrated plasticity model. The plastic hinge length that led to agreement between the models was 0.4% of the frame member's total length. The periods of the concentrated and distributed models are very close: T\u003csub\u003e1\u003c/sub\u003e = 0.83 s (con) vs. 0.82 s (dist) and T\u003csub\u003e2\u003c/sub\u003e = 0.22 s (con) vs. 0.21 s (dist).\nThe results of the pushover analyses from the OpenSees models are shown in Figure 3. This figure shows the normalized base shear (base shear divided by the weight of the structure) versus the roof drift (roof displacement divided by the roof elevation). The models are nearly identical until about 2.5% roof drift when their curves begin to diverge. The descending branch of the the concentrated plasticity model is slightly steeper, but the two models agree reasonably well as there is less than 10% percent difference in the base shears at 10% roof drift.\nComparison of OpenSees \u0026 SAP2000 Results Figure 4. Pushover Curve: Comparison OpenSees \u0026 SAP2000 Models The results of the pushover analyses from the concentrated plasticity OpenSees model and the SAP2000 model are shown in Figure 4.The OpenSees and SAP2000 models agree very well as the difference between their base shears at 10% roof drift is only 4%.\nReferences Ibarra, L. F., and Krawinkler, H. (2005). “Global collapse of frame structures under seismic excitations,” Technical Report 152, The John A. Blume Earthquake Engineering Research Center, Department of Civil Engineering, Stanford University, Stanford, CA. [electronic version: https://blume.stanford.edu/tech_reports] Ibarra, L. F., Medina, R. A., and Krawinkler, H. (2005). “Hysteretic models that incorporate strength and stiffness deterioration,” Earthquake Engineering and Structural Dynamics, Vol. 34, 12, pp. 1489-1511. Lignos, D. G., and Krawinkler, H. (2012). “Sidesway Collapse of Deteriorating Structural Systems under Seismic Excitations,” Technical Report 177, The John A. Blume Earthquake Engineering Research Center, Department of Civil Engineering, Stanford University, Stanford, CA. [electronic version: https://blume.stanford.edu/tech_reports] Lignos, D. G., and Krawinkler, H. (2011). “Deterioration Modeling of Steel Beams and Columns in Support to Collapse Prediction of Steel Moment Frames,” ASCE, Journal of Structural Engineering, Vol. 137 (11), 1291-1302. Example posted by: Laura Eads, Stanford University\n","title":"Pushover Analysis of 2-Story Moment Frame","uri":"/opensees-gallery/examples/mrf_pushover/"},{"content":"This example is an extension of the Pushover Analysis of 2-Story Moment Frame and Dynamic Analysis of 2-Story Moment Frame examples which illustrates the explicit modeling of shear distortions in panel zones and uses reduced beam sections (RBS) which are offset from the panel zones. Both pushover and dynamic analyses are performed in this example. The structure is the same 2-story, 1-bay steel moment resisting frame used in the other examples where the nonlinear behavior is represented using the concentrated plasticity concept with rotational springs. The rotational behavior of the plastic regions follows a bilinear hysteretic response based on the Modified Ibarra Krawinkler Deterioration Model (Ibarra et al. 2005, Lignos and Krawinkler 2009, 2010). For this example, all modes of cyclic deterioration are neglected. A leaning column carrying gravity loads is linked to the frame to simulate \\(P-\\Delta\\) effects.\nThe files needed to analyze this structure in OpenSees are included here:\nThe main file: MRF_2Story_Concentrated_PanelZone.tcl Supporting procedure files\nDisplayModel2D.tcl : displays a 2D perspective of the model DisplayPlane.tcl : displays a plane in the model RotSpring2DModIKModel.tcl : creates a bilinear rotational spring that follows the Modified Ibarra Krawinkler Deterioration Model (used in the concentrated model) RotLeaningCol.tcl : creates a low-stiffness rotational spring used in a leaning column RotPanelZone2D.tcl : creates a rotational spring to capture panel zone shear distortions ElemPanelZone2D.tcl - creates eight elastic elements which form a rectangular panel zone The acceleration history for the Canoga Park record\nNR94cnp.txt : contains acceleration history in units of g All files are available in a compressed format here: MRF_PanelZone_example.zip\nThe rest of this example describes the model and presents the analysis results. The OpenSees model is also compared to an equivalent model built and analyzed using the commercial program SAP2000 http://www.csiberkeley.com/products_SAP.html.\nModel Description Figure 1. Schematic representation of concentrated plasticity OpenSees model including explicit modeling of the panel zones. Element number labels and [node number] labels are also shown. A detailed view of a typical panel zone is presented in Figure 2. Note: The springs are zeroLength elements, but their sizes are greatly exaggerated in this figure for clarity. Figure 2. Schematic representation of a typical panel zone with element number labels and [node number] labels shown. Note: The spring is a zeroLength element, but its size is greatly exaggerated in this figure for clarity. The 2-story, 1-bay steel moment resisting frame is modeled with elastic beam-column elements connected by zeroLength elements which serve as rotational springs to represent the structure’s nonlinear behavior. The springs follow a bilinear hysteretic response based on the Modified Ibarra Krawinkler Deterioration Model. The panel zones are explicitly modeled with eight elastic beam-column elements and one zeroLength element which serves as rotational spring to represent shear distortions in the panel zone. A leaning column with gravity loads is linked to the frame by truss elements to simulate \\(P-Delta\\) effects. An idealized schematic of the model is presented in Figure 1.\nA detailed description of this model is provided in Pushover Analysis of 2-Story Moment Frame. This section merely highlights the important differences in this model, namely the inclusion of panel zones and reduced beam sections (RBS) which are offset from the panel zones.\nThe units of the model are kips, inches, and seconds.\nPanel Zones The panel zone is the joint region where beams and columns intersect. In this model it consists of the rectangular area of the column web that lies between the flanges of the connecting beam(s). The panel zone deforms primarily in shear due to the opposing moments in the beams and columns. To capture these deformations, the panel zone is explicitly modeled using the approach of Gupta and Krawinkler (1999) as a rectangle composed of eight very stiff elastic beam-column elements with one zeroLength element which serves as rotational spring to represent shear distortions in the panel zone (see Figure 2). At the three corners of the panel zone without a spring, the elements are joined by a simple pin connection which is achieved by using the equalDOF command to constrain both translational degrees of freedom. The eight elastic beam-column elements each have an area of 1,000.0 in2 and a moment of inertia equal to 10,000.0 in4 in order to give them high axial and flexural stiffness, respectively. The elements are defined in elemPanelZone2D.tcl. The spring has a trilinear backbone which is created with the Hysteretic material in rotPanelZone2D.tcl. This procedure also constrains the translational degrees of freedom at the corners of the panel zone. The spring’s backbone curve is derived using the principle of virtual work applied to a deformed configuration of the panel zone (Gupta and Krawinkler 1999).\nReduced Beam Sections (RBS) Using an RBS which is offset from the beam-column joint ensures that the beam’s plastic hinge forms away from the column and thus protects the column’s integrity. In this model, the decrease in moment of inertia at the RBS is neglected; however, the yield moment at the RBS is calculated based on the reduced section properties. The plastic hinge is modeled by a rotational spring placed at the center of the RBS. An elastic beam-column element is used to connect the spring and the panel zone. Since this element is not part of the spring-elastic element-beam subassembly described in the “Stiffness Modifications to Elastic Frame Elements” section of the Pushover Analysis of 2-Story Moment Frame example, its moment of inertia and stiffness proportional damping coefficient are not modified by an “n” factor.\nApplication Points for Masses and Loading Since loads cannot be applied at the center of the beam-column joint, gravity loads are applied at the top node of the panel zone where it meets the column (node xy7 in Figure 2). Both masses and lateral loads are applied at the centerline of the floor level along the right side of the panel zone (node xy05 in Figure 2).\nAnalysis Figure 3. Pushover Curve: Comparison OpenSees \u0026 SAP2000 Models Pushover The pushover analysis is identical to the analysis performed in the Pushover Analysis of 2-Story Moment Frame example where the structure is pushed to 10% roof drift, or 32.4”.\nDynamic The dynamic analysis is identical to the analysis performed in the Dynamic Analysis of 2-Story Moment Frame example where the structure is subjected to the 1994 Northridge Canoga Park record.\nResults The first and second mode periods of the structure obtained from an eigenvalue analysis are T1 = 0.81 s and T2 = 0.18 s, respectively. These values agree with the SAP2000 model which had periods of T1 = 0.81 s and T2 = 0.20 s.\nThe periods of this OpenSees model are slightly smaller than the periods of the structure used in Pushover Analysis of 2-Story Moment Frame which had periods of T1 = 0.83 s and T2 = 0.22 s. This is expected because the including the panel zone regions makes the structure stiffer.\nPushover Results Figure 4. Acceleration and Floor Displacement Histories A comparison of the pushover results from the OpenSees and SAP2000 models is shown in Figure 3. As demonstrated by this figure, the results are nearly identical.\nDynamic Results The floor displacement histories from the dynamic analysis are shown in Figure 4. The top graph shows the ground acceleration history while the middle and bottom graphs show the displacement time histories of the 3rd floor (roof) and 2nd floor, respectively\nReferences Gupta, A., and Krawinkler, H. (1999). \"Seismic Demands for Performance Evaluation of Steel Moment Resisting Frame Structures,\" Technical Report 132, The John A. Blume Earthquake Engineering Research Center, Department of Civil Engineering, Stanford University, Stanford, CA. [electronic version: https://blume.stanford.edu/tech_reports] Ibarra, L. F., and Krawinkler, H. (2005). “Global collapse of frame structures under seismic excitations,” Technical Report 152, The John A. Blume Earthquake Engineering Research Center, Department of Civil Engineering, Stanford University, Stanford, CA. [electronic version: https://blume.stanford.edu/tech_reports] Ibarra, L. F., Medina, R. A., and Krawinkler, H. (2005). “Hysteretic models that incorporate strength and stiffness deterioration,” Earthquake Engineering and Structural Dynamics, Vol. 34, 12, pp. 1489-1511. Lignos, D. G., and Krawinkler, H. (2009). “Sidesway Collapse of Deteriorating Structural Systems under Seismic Excitations,” Technical Report 172, The John A. Blume Earthquake Engineering Research Center, Department of Civil Engineering, Stanford University, Stanford, CA. Lignos, D. G., and Krawinkler, H. (2011). “Deterioration Modeling of Steel Components in Support of Collapse Prediction of Steel Moment Frames under Earthquake Loading\", ASCE, Journal of Structural Engineering, Vol. 137 (11), 1291-1302. Example posted by: Laura Eads, Stanford University\n","title":"Pushover and Dynamic Analyses of 2-Story Moment Frame with Panel Zones and RBS","uri":"/opensees-gallery/examples/mrf_panelzone/"},{"content":" For the case of the uniaxial section, moment-curvature and axial force-deformation curves are defined independently, and numerically.\nFor the case of the fiber sections (steel and RC), uniaxial materials are defined numerically (stress-strain relationship) and are combined into a fiber section where moment-curvature and axial force-deformation characteristics and their interaction are calculated computationally.\n2D vs. 3D While this distinction does not affect the section definition itself, it affects the degree-of-freedom associated with moment and curvature in the subsequent analysis. There are two differences between the two models:\nThe space defined with the model command (Defining the model builder, ndm=#dimension ndf=#dofs) In the 3D model, torsional stiffness needs to be aggregated to the section. Uniaxial Section NotesFlexure and axial behavior are uncoupled in this type of section Fiber Section: AISC Standard W Section NotesCoupled biaxial flexure and axial behavior Fiber Section: Reinforced Concrete Section -- Rectangular Symmetric Section, Unconfined Concrete NotesCoupled biaxial flexure and axial behavior Fiber Section: Reinforced Concrete Section -- Rectangular Symmetric Section, Confined Concrete Core NotesCoupled biaxial flexure and axial behavior Fiber Section: Reinforced Concrete Section -- Rectangular Section NotesCoupled biaxial flexure and axial behavior generic rectangular section Fiber Section: Reinforced Concrete Section -- Circular Section, Confined Core NotesCoupled biaxial flexure and axial behavior generic circular section Fiber Section: Reinforced Concrete Hollow Section -- Symmetric Section, Confined Concrete NotesCoupled biaxial flexure and axial behavior Moment-Curvature Analysis This example introduces the moment-curvature procedures for sections in 2D or 3D space, as built in the previous section. (the only difference between them is the degree-of-freedom corresponding to curvature). The moment-curvature analysis of a section is by creating a zero-length rotational-spring element. This section is subjected to a user-defined constant axial load and to a linearly-increasing moment to a user-defined maximum curvature. 2D Moment-Curvature Analysis FilesEx9.analyze.MomentCurvature2D.tcl MomentCurvature2D.tcl Notes 3D Moment-Curvature Analysis FilesEx9.analyze.MomentCurvature3D.tcl MomentCurvature3D.tcl Run The model and analysis combinations for this example are numerous. The following are an small subset, for demonstration purposes: To run Uniaxial-Section Model, 2D puts \" --------------------------------- 2D Model ---------------\" puts \" a. Uniaxial Section\" source Ex9a.build.UniaxialSection2D.tcl source Ex9.analyze.MomentCurvature2D.tcl To run RC Section: Rectangular, Confined, Symmetric Model, 3D puts \" --------------------------------- 3D Model ---------------\" puts \" d. RC Section: Rectangular, Confined, Symmetric\" source Ex9d.build.RCSection.RectConfinedSymm3D.tcl source Ex9.analyze.MomentCurvature3D.tcl ","tags":["Fiber"],"title":"Rectilinear Cross Sections","uri":"/opensees-gallery/examples/ex9/"},{"content":"The source code is adapted from the example by Jawad Fayaz from University of California-Irvine at https://openseespydoc.readthedocs.io/en/latest/src/exampleRotDSpectra.html\n","tags":["Python","Dynamics"],"title":"RotD Spectrum","uri":"/opensees-gallery/examples/spectrum/"},{"content":" ","title":"Sather Tower","uri":"/opensees-gallery/gallery/sathertower/"},{"content":"Download (Double-Layer Shallow Dome.ipynb)\nDouble-Layer Shallow Dome March 2020, Amir Hossein Namadchi This is an OpenSeesPy simulation of one of the numerical examples in our previously published paper. The Core was purely written in Mathematica. This is my attempt to perform the analysis again via Opensees Core, to see if I can get the similar results. In the paper, we used Total Lagrangian framework to model the structure. Unfortunately, OpenSees does not include this framework, so, alternatively, I will use Corotational truss element.\nimport numpy as np import opensees.openseespy as ops import matplotlib.pyplot as plt import sees # %matplotlib notebook # %matplotlib widget Below, the base units are defined as python variables:\n## Units m = 1 # Meters KN = 1 # KiloNewtons s = 1 # Seconds Model Defintion The coordinates information for each node are stored node_coords. Each row represent a node with the corresponding coordinates. Elements configuration are also described in connectivity, each row representing an element with its node IDs. Elements cross-sectional areas are stored in area_list. This appraoch, offers a more pythonic and flexible code when building the model. Since this is a relatively large model, some data will be read from external .txt files to keep the code cleaner.\n# Node Coordinates Matrix (size : nn x 3) node_coords = np.loadtxt('assets/nodes.txt', dtype = np.float64) * m # Element Connectivity Matrix (size: nel x 2) connectivity = np.loadtxt('assets/connectivity.txt', dtype = np.int64).tolist() # Loaded Nodes loaded_nodes = np.loadtxt('assets/loaded_nodes.txt', dtype = np.int64).tolist() # Get Number of total Nodes nn = len(node_coords) # Get Number of total Elements nel = len(connectivity) # Cross-sectional area list (size: nel) area_list = np.ones(nel)*(0.001)*(m**2) # Modulus of Elasticity list (size: nel) E_list = np.ones(nel)*(2.0*10**8)*(KN/m**2) # Mass Density rho = 7.850*((KN*s**2)/(m**4)) #Boundary Conditions (size: fixed_nodes x 4) B_C = np.column_stack((np.arange(1,31), np.ones((30,3), dtype = np.int64)) ).tolist() Model Construction I use list comprehension to add nodes,elements and other objects to the domain.\nmodel = ops.Model(ndm=3, ndf=3) # Adding nodes to the model object using list comprehensions [model.node(n+1,*node_coords[n]) for n in range(nn)]; # Applying BC [model.fix(B_C[n][0],*B_C[n][1:]) for n in range(len(B_C))]; # Set Material model.uniaxialMaterial('Elastic',1, E_list[0]) # Adding Elements [model.element('corotTruss', e+1, *connectivity[e], area_list[e], 1,'-rho', rho*area_list[e], '-cMass', 1) for e in range(nel)]; Draw model The model can now be drawn using the sees Python package:\nsees.render(model) Output:\n\u003cFigure size 640x480 with 1 Axes\u003e \u003csees.SkeletalRenderer at 0x7fb589684a90\u003e Eigenvalue Analysis Let’s get the first 6 periods of the structure to see if they coincide with the ones in paper.\neigenvalues = model.eigen(6) T_list = 2*np.pi/np.sqrt(eigenvalues) print('The first 6 period of the structure are as follows:\\n', T_list) Output:\nThe first 6 period of the structure are as follows: [0.07189215 0.06809579 0.06809578 0.04648394 0.04648388 0.03117022] Dynamic Analysis Great accordance is obtained in eigenvalue analysis. Now, let’s do wipeAnalysis() and perform dynamic analysis. The Newmark time integration algorithm with $\\gamma=0.5$ and $\\beta=0.25$ (Constant Average Acceleration Algorithm) is used. Harmonic loads are applied vertically on the loaded_nodes nodes.\nmodel.wipeAnalysis() # define load function P = lambda t: 250*np.sin(250*t) # Dynamic Analysis Parameters dt = 0.00025 time = 0.2 time_domain = np.arange(0,time,dt) # Adding loads to the domain beautifully model.timeSeries('Path', 1, dt=dt, values=np.vectorize(P)(time_domain), time=time_domain) model.pattern('Plain', 1, 1) for n in loaded_nodes: model.load(n, *[0,0,-1]) # Analysis model.constraints('Plain') model.numberer('Plain') model.system('ProfileSPD') model.test('NormUnbalance', 0.0000001, 100) model.algorithm('ModifiedNewton') model.integrator('Newmark', 0.5, 0.25) model.analysis('Transient') time_lst =[] # list to hold time stations for plotting d_apex_list = [] # list to hold vertical displacments of the apex for i in range(len(time_domain)): is_done = model.analyze(1, dt) if is_done != 0: print('Failed to Converge!') break time_lst.append(model.getTime()) d_apex_list.append(model.nodeDisp(362,3)) Visualization Below, the time history of the vertical displacement of the apex is plotted.\nplt.figure(figsize=(12,4)) plt.plot(time_lst, np.array(d_apex_list), color = '#d62d20', linewidth=1.75) plt.ylabel('Vertical Displacement (m)', {'fontstyle':'italic','size':14}) plt.xlabel('Time (sec)', {'fontstyle':'italic','size':14}) plt.xlim([0.0, time]) plt.grid() plt.yticks(fontsize = 14) plt.xticks(fontsize = 14); Output:\n\u003cFigure size 1200x400 with 1 Axes\u003e Closure Very good agreements with the paper are obtained.\nNamadchi, Amir Hossein, Farhang Fattahi, and Javad Alamatian. \"Semiexplicit Unconditionally Stable Time Integration for Dynamic Analysis Based on Composite Scheme.\" Journal of Engineering Mechanics 143, no. 10 (2017): 04017119. ","title":"Shallow Dome","uri":"/opensees-gallery/examples/shallowdome/"},{"content":"This example investigates a simple pendulum using the corotational truss element.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 # # Adapted from https://portwooddigital.com/2022/08/14/parametric-oscillator/ # # Claudio Perez # import opensees.openseespy as ops from opensees.units.ips import inch, sec, gravity as g def create_pendulum(m, k, L, W): # Create a model with 2 dimensions (ndm) # and 2 degrees of freedom per node (ndf) model = ops.Model(ndm=2, ndf=2) # Create a node for the pivot point and fix it model.node(1,0,L); model.fix(1,1,1) # Create a node for the mass model.node(2,0,0); model.mass(2,m,m) # Create a corotational truss linking nodes 1 and 2 model.uniaxialMaterial('Elastic',1,k*L) model.element('CorotTruss',1,1,2,1.0,1) # Initial displacements model.setNodeDisp(2,1,0.05*L,'-commit') model.setNodeDisp(2,2,-W/k-(W/k+L)/3,'-commit') # Pendulum weight model.timeSeries('Constant',1) model.pattern('Plain',1,1) model.load(2,0,-W) return model def analyze_pendulum(model): model.algorithm('Newton') model.integrator('Newmark',0.5,0.25) model.analysis('Transient') Tmax = 12*sec dt = 0.01*sec Nsteps = int(Tmax/dt) u = [] for i in range(Nsteps): model.analyze(1,dt) u.append(model.nodeDisp(2)) return u if __name__ == \"__main__\": # Length of pendulum L = 10*inch # Pendulum mass and weight m = 1.0 W = m*g # Frequency of pendulum omega = (g/L)**0.5 # Frequency of oscillator w = 2*omega # Stiffness of spring k = m*w**2 model = create_pendulum(m, k, L, W) u = analyze_pendulum(model) print(u) ","description":"This example investigates a simple pendulum using the corotational truss element.","title":"Simple Pendulum","uri":"/opensees-gallery/examples/pendulum/"},{"content":"Example Provided by: Antonios Vytiniotis, MIT\nThis article describes the basic OpenSees features needed for the simulation of vertically propagating shear waves in a scale model in a centrifuge. GID has been used for pre- and post- processing. For relatively simple configurations (even the one used in this paradigm) a pre-processor might not be needed, but a post-processor is necessary to visualize field output results. For every presented feature an example command is excerpted from the example tcl file and explained in detail. This tutorial does not explain though in every detail all the options associated in the various commands used. For this, the reader is directed to the OpenSees manual (the most recent is the on-line version of it). The commands and features used in this analysis have been tested with OpenSees versions 1.74, 1.75 and 2.0 but should also work for newer versions too. In case an example does not work, I would be obliged to hear about possible problems at avytin [at] mit . edu.\nThis manual explains how one can create a .tcl file that could be read and executed by the OpenSees interpreter. Notice should be taken that OpenSees is dimensionless, so the user must make sure that he uses a consistent system of units (e.g. SI).\nOnce an example.tcl file has been created, the user can then simply run OpenSees.exe, and in turn, write in the command line of the interpreter \"source example.tcl\" to run his analysis.\nSimulated Geometry The centrifuge model geometry that we need to simulate is shown below. The model consists of two blocks of dense sand. On top of this lies a layer of loose liquefiable sand and on the top there are two facing slopes of Yolo Loam. The right hand side is treated with earthquake drains (PV-Drains) to accelerate the dissipation of excess pore pressure. An acceleration pattern is applied on the bottom of the model.\nElastic.CentrifugeExampleModelGeometry.jpg In the figure below, the most important finite element modelling features used in OpenSees are presented. These are explained in more detail in the next sections.\nCentrifugeExampleOpenSeesModel.jpg Elements Used The elements used in this simulation are described in this section.\nThe Yolo Loam layer is simulated using total stress analysis with 4-noded quad elements. This element can be used to perform drained analysis, total stress analysis, and undrained analysis when coupled with the FluidSolidPorousMaterial material wrapper. An example of this command taken from the example's code is:\n\u003cpre style=\"background:yellow;color:black;width:800px\"\u003e element quad 1 2327 2351 2326 2302 1.0 \"PlaneStrain\" 1 $press 1.3 $gravX $gravY''' \u003c/pre\u003e\nThis command defines a planestrain quad element with id 1, that connects the nodes 2327, 2351, 2326, and 2302. The element has an out-of-plane width of 1 unit. The mechanical behavior is prescribed by material 1. The hydrostatic pressure of the element is the value of press. The total density of the material in the quad element is 1.3. The gravitational components in both directions are defined by the values of the parameters gravX and gravY.\nThe sand layer is simulated using 4-noded quadUP elements. These elements have three degrees of freedom per node: two for displacements, and one for pore pressure. It is important to keep in mind that the velocity, and not the displacement, of the 3rd DOF is the pore pressure, when requesting output or applying pore pressure conditions on the model. These elements can be used to model coupled pore pressure displacement analysis following the u-p formulation. Since they are four-noded they are expected not to perform very well in situations where they simulate incompressible behavior (e.g. undrained conditions). For completely undrained conditions the previously mentioned quad elements should be used together with the FluidSolidPorousMaterial material wrapper. An example how to define a quadUP element is:\n\u003cpre style=\"background:yellow;color:black;width:800px\"\u003e element quadUP 417 4190 4191 4200 4199 1.0 3 $bulk 1. [expr 0.0003/9.81/1.] [expr 0.0003/9.81/1.] $gravX $gravY $press \u003c/pre\u003e\nThis command creates a 4-noded planestrain quadUP element with id 417 that connects the nodes 4190, 4191, 4200, 4199. The element has a out-of-plane width of 1 unit. The mechanical behavior is prescribed by material 3. The bulk modulus of the pore fluid is the value of the variable bulk. The fluid mass density is 1. The hydraulic conductivity is k=0.0003. The gravitational components are defined by the values of the parameters gravX and gravy. The element also has a hydrostatic compression equal to the value of the variable press.\nThe soil material on the Yolo loam layer, where the effective stresses are small, should be able to disconnect from the laminar box. In order for this behavior to be modeled correctly, a zeroLength element should be defined. A zeroLength element connects two nodes that have the same, or almost the same coordinates according to an internally pre-specified threshold. The mechanical properties of this connection are defined by a uniaxial material which is attached to the zeroLength element. A sample definition of this type of element is:\n\u003cpre style=\"background:yellow;color:black;width:800px\"\u003e element zeroLength 3933 4205 4221 -mat 7 7 -dir 1 2 \u003c/pre\u003e\nThis command creates a zeroLength element with id 3933 that connects the nodes 4205 and 4221. The mechanical behavior of this connection is prescribed by the uniaxial material 7 in direction 1 and by the same material in direction 2.\nMaterials Used In this model, there are two types of materials being used. The first type are the continuum material models, referred to as nDMaterial, that are used to simulate the mechanical behaviour of sand, and they are attached to continuum elements. The second type are the uniaxial material elements that are attached either to ZeroLength elements, or to one-dimensional elements (e.g. beams or trusses). If they are attached to ZeroLength elements then their properties are used to simulate the force-displacement behaviour. If they are attached to one-dimensional elements then they simulate the stress-strain behaviour of the material in the element.\nThe Yolo Loam is modeled using a PressureIndependMultiYield material. This material exhibits plasticity only on the deviatoric stress space. It can be used to model the behavior of pressure independent materials, such as clays under usual states of stress (or clay-type material, such as Yolo Loam in this case). An example definition of the PressureIndependMultiyield model is:\n\u003cpre style=\"background:yellow;color:black;width:800px\"\u003e nDMaterial PressureIndependMultiYield 1 2 1.37 13000 65000 6. .1 \u003c/pre\u003e\nThis command creates a PressureIndependMultiYield nDMaterial with tag 1, which is going to be used in a two-dimensional space. The material has a density of 1.37, a reference shear modulus of 13 000, a reference bulk modulus of 65 000, a cohesion of 6, and a peak shear strain parameter of 0.1.\nThe Sand layer is modeled using a PressureDependMultiYield02 nDMaterial model. This material allows for stress level dependent behavior, and shear induced volumetric strains, being able to model cyclic mobility and liquefaction. An example definition of this material is:\n\u003cpre style=\"background:yellow;color:black;width:800px\"\u003e nDMaterial PressureDependMultiYield02 2 2 2.07 130000 260000 36.5 .1 80 0.5 26. 0.013 0.0 0.3 0.0 \u003c/pre\u003e\nThis command creates a PressureDependMultiYield02 nDMaterial Model with tag 2, which is going to be used in a two-dimensional space. The material has a total density of 2.07, a reference shear modulus of 130 000, a reference bulk modulus of 260 000, a friction angle of 36.5, a peak shear strain of 0.1, a reference pressure of 80, a pressuredependence coefficient of 0.5, a phase transformation angle of 26, a contraction1 parameter of 0.013, a contraction3 parameter of 0.0, a dilation1 parameter of 0.3, and dilation3 parameter of 0.0.\nThe connection between the quad soil elements of the top soil layer (Yolo Loam) with the box is modeled using a no tension material. In order for the analysis to converge more easily we couple in parallel the no-tension material with an elastic material of very small elastic modulus. An example of defining an elastic uniaxial material is:\n\u003cpre style=\"background:yellow;color:black;width:800px\"\u003e uniaxialMaterial Elastic 9 10 \u003c/pre\u003e\nwhich defines a linear Elastic uniaxialMaterial with id 9, and elastic modulus (E) of 10.\nAn example of defining an elastic no-tension material is:\n\u003cpre style=\"background:yellow;color:black;width:800px\"\u003e uniaxialMaterial ENT 8 1000000000 \u003c/pre\u003e\nwhich defines an ENT (Elastic-No-Tension) uniaxialMaterial with id 8, and an elastic modulus (E) of 1 000 000 000.\nIn order to combine the above two materials in parallel a Parallel uniaxialMaterial object should be defined:\n\u003cpre style=\"background:yellow;color:black;width:800px\"\u003e uniaxialMaterial Parallel 7 8 9 \u003c/pre\u003e\nwhich defines a Parallel uniaxialMaterial with id 7, where uniaxialMaterial 8 and uniaxialMaterial 9 behave as two springs in parallel.\nTreatment of Boundary Conditions Bottom Boundary Conditions The bottom of the model is fixed in such a way that no movement is allowed on the vertical and horizontal direction. The pore pressure is allowed to fluctuate freely, which means that there is no drainage on the bottom. An example of a fixity command that fixes direction 1 (x), 2 (y), and leaves direction 3 (pore pressure) free is:\n\u003cpre style=\"background:yellow;color:black;width:800px\"\u003e fix 925 1 1 0 \u003c/pre\u003e\nSide Boundary Conditions The displacements of the model on the sides at the level of the dense sand and the loose sand layers are fixed with periodic boundary conditions; each side has the same displacement with the other side. The command below ties the first and the second degree of freedom (DOF) of elements 58 and 4148.\n\u003cpre style=\"background:yellow;color:black;width:800px\"\u003e equalDOF 58 4148 1 2 \u003c/pre\u003e\nThe nodes on the Yolo Loam level are connected at first with nodes with the same coordinates (representing the laminar box) with ENT zeroLength elements and, these nodes are connected with equalDOF objects with nodes on the other side of the box (periodic boundaries).\nEarthquake Drain Pore Pressure Conditions The drainage system is modelled as perfect drains; fixed pore pressure conditions are applied to them throughout the analysis. A pore pressure condition can be specified using the Timeseries command (to specify the behaviour of the condition vs. Time) and the MultipleSupport groundmotion command to specify the node and DOF to which the Timeseries applies at.\nThe code below is used to specify the pore pressure at a point on the top of the EQ-drain:\n\u003cpre style=\"background:yellow;color:black;width:800px\"\u003e set Timeseries64 \"Constant -factor 0.4495\"\npattern MultipleSupport 3 {\n...\ngroundMotion 64 Plain -vel $Timeseries64\nimposedMotion 64 3 64\n...\n} \u003c/pre\u003e\nThe command creates a MultipleSupport pattern object with id 3, an object that allows users to define a fixed acceleration, velocity, or displacement of a specific DOF on a specific node. It then applies the conditions for every node. For every node we specify a imposedMotion object that attaches a specified groundMotion to the node. In this case, we create a groundMotion object with id 64 that is Plain, of type velocity, and has as arguments the value of the parameter Timeseries64 (Constant timeseries of value 0.4495). By means, of this set of commands we specify that the pore pressure in node 64 has a value of 0.4495. If applying this boundary condition does not work, one should specify acceleration, velocity, and displacement boundary conditions all at the same time, at the same node.\nTop Pore Pressure Conditions When one defines the ground water level to be above the ground surface (and applies the relevant pore pressure conditions on top), one needs also to apply the hydrostatic pressure of the water normal to the ground surface in order for the effective stresses to be computed correctly.\nThe code below shows the application of pore pressure 5.6658 at node 1761.\n\u003cpre style=\"background:yellow;color:black;width:800px\"\u003e set Timeseries1761 \"Constant -factor 5.6658\"\npattern MultipleSupport 3 {\n...\ngroundMotion 31761 Plain -vel $Timeseries1761\nimposedMotion 1761 3 31761\n...\n} \u003c/pre\u003e\nIn order to match the effective stresses on the top of the layer in the middle of the central channel, where the ground water level is above the soil surface, one should also specify the loads applied due to the water weight to the soil surface with the following command:\n\u003cpre style=\"background:yellow;color:black;width:800px\"\u003e set Timeseries \"Constant -factor -1.8\"\npattern Plain 4 $Timeseries {\n...\nload 1561 0. .1 0.\n...\n} \u003c/pre\u003e\nThe above command specifies a vertical load of -0.18 on the node 1561. By applying these loads we make sure that the effective stresses at the ground surface are exactly zero.\nAlso, the shear rings of the laminar box have a specific mass. We apply concentrated mass at the x direction on the side nodes of the model. The following command specifies a nodal mass of the value of 0.01015 at the node 58:\n\u003cpre style=\"background:yellow;color:black;width:800px\"\u003e mass 58 0.01015 0 0 \u003c/pre\u003e\nIn this model there are two types of domains, the two-DOF domain where the quad elements and their respective nodes have been created, and the three-DOF domain where the quadup elements and their respective nodes have been created. In order for the two domains to be connected the nodes on the common boundaries of the two domains are connected with equalDOF objects, as shown below.\nCentrifugeExampleConstraint.jpg In the example below the horizontal and vertical displacement DOFs of node 39 having two DOFs is connected to the node 40 having 3 DOFs.\n\u003cpre style=\"background:yellow;color:black;width:800px\"\u003e equalDOF 40 39 1 2 \u003c/pre\u003e\nFigure C Connection of the 2DOF to the 3DOF domains\nSolution Procedure The typical solution procedure used is:\nUse elastic material for the entire model, turn on the gravity and solve the static case. The way this is performed is by solving a coupled transient analysis with a very large time-step, and very large gamma (1.5). The gamma parameter of the Newmark integrator controls the numerical damping (not the Rayleigh damping). If gamma=0.5 then there is no numerical damping. A value of gamma=1.6 makes sure that the initial dynamic transient will dissipate very quickly. The very large time-step (dt=5.e5) is used to make sure that the analysis is drained, and that any initial excess pore pressures have dissipated. The large time-step also helps the dissipation of the initial transient. In the elastic analysis one can choose the Poisson's ratio in such a way that the initial K0 value is predicted correctly. After the elastic step, when all the initial transients and excess pore pressures have dissipated, the material is switched to an elasto-plastic state, and a similar analysis with large gamma and large time-step is performed. After the elasto-plastic gravity step the analysis object is destroyed, and the time is reset to zero. Then the dynamic analysis is executed. This is a typical procedure used for the UCSD soil models. For other models it might not be possible to run the elastic step, so one should start directly with the second step of the analysis. In that case, the user should pay extra attention to (1) make the analysis converge correctly to the initial state, and (2) correctly track and assign the model state parameters.\nElastic Gravity Step The models created by UCSD (PressureDependMultiYield, PressureInDependMultiYield, PressureDependMultiYield02) have been implemented with an internal switch parameter that allows them to behave either as linear elastic, elasto-plastic, or elastic pressure-dependent. In order to switch this type of material to an elastic state for the elastic part of the gravity loading the following command is issued:\n\u003cpre style=\"background:yellow;color:black;width:800px\"\u003e updateMaterialStage -material 1 -stage 0 \u003c/pre\u003e\nThe command above specifies that material 1 should behave according to stage flag 0, which is a linear elastic state.\nNext, the analysis objects need to be defined:\n\u003cpre style=\"background:yellow;color:black;width:800px\"\u003e set gamma 1.6\ncreate the SOE, ConstraintHandler, Integrator, Algorithm and Numberer integrator Newmark $gamma [expr pow($gamma+0.5, 2)/4] 0.00 0.0 0.00 0.0\ntest EnergyIncr 1.0e-8 400 1;\nconstraints Transformation\nalgorithm Newton\nnumberer RCM\nsystem ProfileSPD\nanalysis Transient \u003c/pre\u003e\nThe above command creates a Newmark integrator with gamma=1.6. Beta b=(gamma+0.5)2/4 is chosen because this value provides unconditional stability of the integration algorithm. The Newmark integrator has been shown to produce spurious oscillations in the results, so it is advisable to use the HHT integrator, when possible. On the other hand, the choice of an integrator is also judged on a case to case basis based on its convergence and speed.\nThe test to judge when convergence has been achieved is based on increments of energy. This is a good criterion in an elasto-plastic problem where increments of displacement can be really large during yielding.\nThe constraint handler is set as the transformation handler, after recommendations from the creators of the quadUP elements when one is applying pore pressure boundary conditions.\nThe algorithm selected is a Newton algorithm. It is a robust and simple algorithm with asymptotically quadratic rate of convergence. The Newton-Raphson algorithms are computationally expensive and are known to suffer from residual flip flop due to sudden changes in the tangent stiffness matrix. Linear convergence can be achieved with ModifiedNewton algorithms. In principle, the fastest implemented algorithm should be the KrylovNewton, so it should be preferred, but there are situations that it might not converge to a solution.\nThe system used is a ProfileSPD. The Jacobian matrix of frictional materials is not symmetric, but in many situations ignoring the non-symmetric elements can help improve performance without significant differences in the results. A good alternative would be an unsymmetric system like UmfPack.\nFinally the analysis object selected is Transient. This gives the ability to implement our own code to define the analysis sub-incrementation.\nElasto-plastic Gravity Step The same analysis objects are used for the elasto-plastic gravity step. The materialstage is updated to simulate elastoplastic response (one more time this applies only to PressureDependMultiYield, PressureDependMultiYield02, PressureInDependMultiYield models) :\n\u003cpre style=\"background:yellow;color:black;width:800px\"\u003e updateMaterialStage -material 1 -stage 1 \u003c/pre\u003e\nThe command above specifies that material 1 should behave according to stage flag 1, which is a elasto-plastic state.\nElasto-plastic Dynamic Step The load is applied using a very simple command:\n\u003cpre style=\"background:yellow;color:black;width:800px\"\u003e pattern UniformExcitation 1 1 -accel $Timeseries_1; \u003c/pre\u003e\nThis command creates a UniformExcitation object with tag 1, which applies to all the nodes in direction 1(x), an acceleration pattern (-accel) defined by the value of the parameter $Timeseries_1. If one defines more than one objects of this type, the results would be superimposed. The output of this analysis would be relative relative to the displacement of these nodes (i.e. the nodes fixed in direction 1 will have as output zero accelerations).\nThe analysis objects need to be defined:\n\u003cpre style=\"background:yellow;color:black;width:800px\"\u003e set gamma 0.65\ncreate the SOE, ConstraintHandler, Integrator, Algorithm and Numberer integrator Newmark $gamma [expr pow($gamma+0.5, 2)/4] 0.00 0.0 0.0002 0.0\nconstraints Transformation\nalgorithm Newton\nnumberer RCM\nsystem ProfileSPD\nanalysis Transient \u003c/pre\u003e\nThe above command creates a Newmark integrator with gamma=0.65, which adds some minor numerical damping. Also, some minor Rayleigh damping is added. This is a good compromise between accuracy and numerical stability for this part of the analysis. The rest of the analysis is kept the same with the gravity analysis.\nDuring the analysis recorder objects are used to track pore pressures, effective stresses, accelerations, and displacements.\n\u003cpre style=\"background:yellow;color:black;width:800px\"\u003e set r_1 [recorder Node -file output_disp_11.txt -nodeRange 1 4204 -time -dT 0.05 -dof 1 2 disp]\nset r_2 [recorder Node -file output_accel_11.txt -nodeRange 1 4204 -time -dT 0.05 -dof 1 2 accel]\nset r_3 [recorder Node -file output_pore_11.txt -nodeRange 1 4204 -time -dT 0.05 -dof 3 vel]\nset r_4 [recorder Element -file stress_1_11.txt -time -dT 0.05 -eleRange 1 3932 material 1 stress]\nset r_8 [recorder Element -file strain_1_11.txt -time -dT 0.05 -eleRange 1 3932 material 1 strain] \u003c/pre\u003e\nIn the above code, five types of recorders are illustrated, the displacement, the acceleration, the pore pressure, the stress, and the strain recorders. We note that the strain and stress values are extracted from the material class, so different implementations of materials might not include these recorders. Parameters r_1, r_2, r_3, r_4 have handles to the created recorder objects.\nLater in the analysis we can conveniently destroy the recorders:\n\u003cpre style=\"background:yellow;color:black;width:800px\"\u003e remove recorder $r_1 \u003c/pre\u003e\nThe above command destroys the recorder object with tag the value of the parameter r_1. This is done to store different parts of the analysis to different output files.\nNext, a sample of the code that allows for control on the incrementation of the solution procedure is presented:\n\u003cpre style=\"background:yellow;color:black;width:800px\"\u003e set ok 0\nset currentTime 0.0\nset i_extr_nl 0.0\nset dt 0.005\nset i_suc 0\nset disp_incr 1.0e-5\nset iter 30\nalgorithm Newton\nwhile {$currentTime \u003c 13.} {\ntest EnergyIncr $disp_incr $iter 2;\nset ok [analyze 1 $dt]\nset currentTime [getTime]\nputs \"$ok dt=$dt Disp_incr=$disp_incr #Iter=$iter\"\nif {$ok ==0} {\nset i_suc [expr $i_suc+1]\nif {$disp_incr\u003e1e-3} {\nset i_extr_nl [expr $i_extr_nl+1]\n}\nif {$i_suc\u003e10} {\nset disp_incr [expr $disp_incr/2]\nif {$disp_incr\u003c1e-6} {\nset disp_incr 1e-6\n}\nif {$dt\u003c0.0005} {\nset iter 30\n}\n}\nif {$i_suc\u003e20} {\nset dt [expr $dt*2]\nif {$dt\u003e0.05} {\nset dt 0.05\n}\n}\n}\nif {$ok !=0} {\nset dt [expr $dt/2]\nif {$i_suc==0} {\nset disp_incr [expr $disp_incr*2]\nif {$disp_incr\u003e0.005} {\nset disp_incr 0.005\n}\n}\nif {$dt\u003c0.0005} {\nset iter 200\n}\nset i_suc 0\n}\n} \u003c/pre\u003e\nIn the above algorithm we try to evaluate a step using an initial time-step. In case of non-convergence the algorithm changes the convergence criteria and the time-step so that the analysis converges. In case of convergence, the algorithm increases the time-step and tightens the convergence criteria up to some pre-specified limits. This part of the code should always be tailored according to accuracy and speed needs of every analysis.\nResults Three phases of shaking and dissipation are allowed in the happen in the model. A full analysis of the example file, will take around a day, depending on the processor speed. A sample output, after the end of all the shaking and dissipation of all the accumulated excess pore pressure, produced with GiD is shown below.\nCentrifugeExampleResults.jpg ","title":"Simulating a Centrifuge Test","uri":"/opensees-gallery/community/centrifuge/"},{"content":"Example prepared by: Christopher McGann and Pedro Arduino, University of Washington\nReturn to OpenSees Examples Page\nThis article describes the OpenSees implementation of a site response analysis a soil deposit located above an elastic half-space using total stress analysis. A single soil column is modeled in two-dimensions and is subject to an earthquake ground motion in a manner which accounts for the finite rigidity of the underlying medium.\nProvided with this article are three input files which execute this analysis in different ways.\nfreeFieldSingle.tcl has a single soil layer for simplicity and is intended to outline the basic analysis approach. freeFieldIndepend.tcl and freeFieldDepend.tcl are two approaches to a comparison study with the 1D wave propagation analysis tools ProShake and ProShakeNL (http://www.proshake.com/). Each approach breaks the soil up into a series of sublayers, however, one uses the PressureIndependMultiYield material with user-generated modulus reduction (G/Gmax) curves while the other uses the PressureDependMultiYield material with automatically-generated G/Gmax curves. Also included is the velocity time history of the selected ground motion, velocityHistory.out. This file is required for the analysis.\nSeveral helpful files are included as well:\nGilroyNo1EW.out, the acceleration time history for the selected ground motion, as downloaded from the Peer NGA strong motion database, with the header information removed. processMotion.m, a Matlab script which reshapes the GilroyNo1EW.out acceleration history into a column vector, then integrates this using the trapezoidal method to obtain the velocity time history needed for the site response analysis. accelPlot.m and respSpectra.m, Matlab scripts which produce the verification plots included in this article from the recorded results. Download them all in a compressed file: siteResponseAnalysis.zip\nTo run this example, the user must download the one of the input files and the velocity time history file, velocityHistory.out, and place them in a single directory. Once this has been done, the user can then run the analysis. The Matlab scripts and the acceleration time history files are not essential to the analysis, however, they are provided to demonstrate how an alternative acceleration time history can be converted into the analysis and how certain plots can be obtained from the recorded output.\nA large set of similar examples has been developed at the University of California at San Diego. They are available at http://cyclic.ucsd.edu/opensees. These examples utilize a wide variety of element and material formulations, as well as different boundary and loading conditions than those used in this example. The user is referred to these examples for further information on how to set up a site response model in OpenSees.\nModel Description Fig 1. Schematic representation of the site response model. Node numbers in blue, element numbers in red. In this article, the site response analyses are performed for soil deposits which are underlain by an elastic half-space, which simulates the finite rigidity an underlying medium such as bedrock. It is assumed that there is no groundwater, therefore, total stress analysis is used in this example. The soil is modeled in two-dimensions with two degrees-of-freedom using the plane strain formulation of the quad element element. The provided input files consider only a single layer of soil, however, the files freeFieldIndepend.tcl and freeFieldDepend.tcl, consider a soil profile which has a parabolically-increasing shear wave velocity profile with depth. This is accomplished using sublayers, thus, the use of multiple soil layers in an OpenSees site response analysis is demonstrated. A general schematic of the model is shown in Fig. 1. In this example, the horizontal direction is the first degree-of-freedom and the vertical is the second. The soil node, element, and layer numbering schemes all begin at the bottom.\nNote: The remainder of the main model description in this article, when not otherwise specified, refers to the simpler of the three provided input files, freeFieldSingle.tcl, with the intention of highlighting the main site response analysis details. The other input files are essentially the same, with the main difference being the complexity introduced by the inclusion of multiple layers. The more complex files are explained later in this article during the discussion of the comparison study.\nTo account for the finite rigidity of the underlying half-space, a Lysmer-Kuhlemeyer (1969) dashpot is incorporated at the base of the soil column using a zeroLength element and the viscous uniaxial material. The Lysmer-Kuhlemeyer (1969) dashpot is assigned a dashpot coefficient equal to the product of the mass density and shear wave velocity of the underlying layer with the area of the base of the soil column. In this example, the properties of a bedrock layer are used for the half-space. The soil column is excited at the base by a horizontal force time history which is proportional to the known velocity time history of the ground motion. Further information on this modeling approach can be found in Joyner and Chen (1975) and Lysmer (1978) among others.\nThe horizontal force time history is applied as a Path TimeSeries object using the file, velocityHistory.out. The force history is obtained by multiplying the known velocity time history by a constant factor set as the product of the area of the base of the soil column (width x thickness) with the mass density and shear wave velocity of the underlying layer. The area of the soil column is included to ensure proportional loading for any desired horizontal element size. The provided Matlab script, processMotion.m, shows how the velocity time history was obtained from the selected acceleration time history.\nSoil Profile Geometry For the simple soil profile considered in the file freeFieldSingle.tcl, the soil profile geometry is controlled entirely by the thickness of the soil deposit. In this example, this value is set at 40 meters.\nIn the multi-layered soil profiles in the other input files, the soil profile geometry is controlled by a specified number of layers and the thicknesses of each individual soil layer. In this case the overall thickness of the soil profile is the sum of the layer thicknesses.\nMesh Geometry The geometry of the mesh is based upon the concept of resolving the propagation of the shear waves at or below a particular frequency by ensuring that an adequate number of elements fit within the wavelength of the chosen shear wave. This ensures that the mesh is refined enough such that the desired aspects of the propagating waves are well captured in the analysis.\nThis is accomplished in the model by specifying the highest frequency which the user wishes to be well resolved and the number of elements that the user desires to be in one wavelength of a shear wave propagating at this frequency. The wavelength used to define the mesh geometry is determined by dividing the minimum shear wave velocity of the soil profile by the specified cutoff frequency. In the provided examples there are either 8 or 10 elements per wavelength. The largest value possible value for the specified frequency is the sampling frequency of the ground motion. The provided examples use 100 Hz for the cutoff frequency.\nThe horizontal size of the elements is set to be the minimum vertical element size in the soil column. The number of nodes and the total number of elements are computed automatically. The number of elements is based on the computed element size and the thickness of the soil deposit. For n total elements, there are 2n + 1 total nodes.\nSoil Nodes The soil nodes are created automatically from the input geometry and meshing information. As shown in Fig. 1, the node numbering scheme is left-to-right, top-to-bottom. Nodes with even numbers fall on the y-axis, and the odd-numbered nodes are spaced horizontally by the computed horizontal element size.\nDashpot Nodes A single zeroLength element is used to define the Lysmer-Kuhlemeyer (1969) dashpot, therefore, only two nodes are required. These nodes are arbitrarily assigned numbers 2000 and 2001. If the user has modified the meshing information such that there are more than 2000 nodes in the soil column, the dashpot node numbers will need to be changed.\nBoundary Conditions and Equal Degrees-of-Freedom The nodes at the base of the column are fixed against displacements in the y-direction in accordance with the assumption that the soil layers are underlain by bedrock. The remaining soil nodes are then tied together using the equalDOF command in order to achieve a simple shear deformation pattern. This is done by declaring equalDOF for every pair of nodes which share the same y-coordinate.\nOne of the dashpot nodes is fully fixed (node 2000), while the other is fixed only against displacements in the y-direction (node 2001). To incorporate the dashpot element into the total model, equalDOF is again used, this time linking the horizontal degrees-of-freedom of the partially fixed dashpot node and one of the nodes at the base of the soil column.\nSoil Material Properties and Objects A series of material properties are required to define the constitutive behavior of the soil and the underlying elastic half-space. The main soil properties are the mass density, the shear wave velocity, and Poisson's ratio. From these, the elastic, shear, and bulk moduli are computed. Poisson's ratio is set as zero in these examples for the purposes of emulating a one-dimensional analysis. With Poisson's ratio at zero, no vertical accelerations are generated.\nThe remaining soil properties correspond to the particular constitutive model selected in each analysis, either PressureDependMultiYield or PressureIndependMultiYield. For these examples, these properties are largely based on the recommendations detailed on the PressureDependMultiYield or PressureIndependMultiYield pages of the OpenSees command manual.\nFor the case of multiple layers, one material object is created for each layer using the material properties defined in the input file. With the exception of a few global properties, each layer is given a separate set of properties.\nDuring the creation of these examples is was noted that using too few yield surfaces in these nested surface models, or using poorly spaced user-generated surfaces, can cause high frequency shaking to develop in the model. This appears to be due to the way in which these constitutive models work. There is not one consistent tangent over the length of the backbone curve, instead, a smooth backbone curve is approximated using a series of linear segments. If there are too few, or poorly spaced, yield surfaces, a dramatic change in stiffness can occur as the stress path crosses a particular yield surface, resulting in a shock which is manifested as the observed high frequency shaking. This behavior can be alleviated by using a larger number of yield surfaces, resulting in a smoother approximation to the backbone curve of the soil. Care should be taken, however, depending upon the intentions of the analysis. As the number of surfaces increases, the time needed to complete the analysis also increases, and in the end, the inclusion of this high frequency shaking does not significantly alter the results of the simulation. It is recommended that the user keep these ideas in mind when selecting the number of surfaces to use in a particular analysis.\nSoil Elements Four-node quad elements are used to model the soil using the plane strain formulation of the quad element. The element connectivity uses a counterclockwise pattern for the previously-described node numbering scheme (see Fig. 1). The soil elements in each layer are assigned the material tag of the material object corresponding to that layer. A unit thickness is used in all examples. The self-weight of the soil is considered as a body force acting on each element. The body force is set as the unit weight of the soil in each layer, which is determined from the respective mass density input value.\nDashpot Material and Element The viscous uniaxial material is used to define the Lysmer-Kuhlemeyer (1969) dashpot. This material model requires a single input, the dashpot coefficient, c. Following the method of Joyner and Chen (1975), the dashpot coefficient is defined as the product of the mass density and shear wave velocity of the underlying medium, which, in this example, is assumed to have the properties of bedrock. The dashpot coefficient must also include the area of the base of the soil column to maintain proportional results for any horizontal element size. Since the elements are created with unit thickness, this area is simply the computed horizontal element size.\nA zeroLength element is used for the Lysmer-Kuhlemeyer (1969) dashpot. This element connects the two previously-defined dashpot nodes and is assigned the material tag of the Viscous uniaxial material object in the first degree-of-freedom (horizontal direction).\nRecorders The recorders defined for this example document the following items:\nthe nodal displacements, velocities, and accelerations in both degrees-of-freedom the stress and strain response at each Gauss point in each element The recorded nodal values are the true values for each parameter, not relative values as with the uniformExcitation command.\nTwo sets of recorders are included to capture the response of the soil during the gravity analysis (which is sometimes useful to ensure proper model generation) and the response of the soil during the application of the ground motion. These files are differentiated by a naming scheme in which the records corresponding to the gravity analysis are named 'Gacceleration', 'Gstress', etc ...\nGravity Loading and Analysis The gravity analysis in this example is conducted as a transient analysis with very large time steps, thus simulating a static analysis while avoiding the conflicts which may occur when mixing static and transient analyses. The self-weight of the soil elements provides the loads, therefore, no loading object is required. Gravity is applied for ten steps with entirely elastic constitutive behavior. This allows the material objects to update various parameters to account for confining pressure. Once these steps have converged, the material objects are updated using the updateMaterialStage command to consider elastoplastic behavior, and the gravity analysis is repeated for 40 steps.\nHorizontal Loading and Analysis Using the method of Joyner and Chen (1975), dynamic excitation is applied as a force time history to the base of the soil column, at the node which shares equal degrees-of-freedom with the Lysmer-Kuhlemeyer (1969) dashpot. This force history is obtained by multiplying the velocity time history of the recorded ground motion by the mass density and shear wave velocity of the underlying bedrock layer and the area of the base of the soil column (the horizontal element size in these examples). This technique considers the finite rigidity of the underlying layer by allowing energy to be radiated back into the underlying material.\nThe force history is applied to the model as a Path TimeSeries object using a Plain load pattern object. The actual force applied to the node in each time step is the product of the load factor indicated in the pattern object (1.0 in this example), the additional load factor included in the timeSeries object, and the value found in the file, velocityHistory.out, at that time step. The load factor included in the timeSeries object is used to create a force history from the velocity history found in the namesake file.\nThe transient analysis is conducted with the Newmark integrator using the gamma and beta coefficients defined near the top of the input file. These values are set at 0.5 and 0.25, respectively to ensure there is no numerical damping in the analysis.\nSince these models consider elastoplastic soil behavior, there is inherent hysteretic damping which occurs, however, a small amount of Rayleigh damping is used so there is still some damping at low strain values. The level of Rayleigh damping is controlled by the damping ratio and the circular frequencies of two modes of vibration. This type of approach is discussed in most dynamic analysis texts, such as Chopra (2007).\nThe time step used in the analysis is selected to meet stability considerations using the Courant-Friedrich-Lewy (CFL) condition (discussed well by LeVeque, 2007). Meeting the requirements of this condition ensures that the time step is small enough for stability given the maximum shear wave velocity and the minimum vertical element size in the model. The example files are set up such that the analysis time step and the corresponding number of steps are automatically generated to satisfy this condition. If the required time step is larger than the time step increment found in the recorded ground motion, the value specified in the ground motion is used. If the user alters the shear wave velocity profile such that the lowest layer does not have the highest shear wave velocity, then the value of $vsMax used in this routine will need to be updated.\nRepresentative Results Several plots displaying results obtained from running the example site response analysis from the file, freeFieldSingle.tcl, are provided for use as a means of verification. These plots were generated using the Matlab scripts accelPlot.m, and respSpectra.m, which are available for download with the rest of the files in a compressed folder here.\nFig. 2 shows the acceleration response at the ground surface (top of the soil column). This figure was created by simply plotting the recorded response at each time increment. The m-file, accelPlot.m was used to create the figure.\nFig. 3 shows the computed acceleration, velocity, and displacement response spectra at the ground surface. The figure was created using the m-files, accelPlot.m and respSpectra.m.\nFig 2. Acceleration time history response of at the ground surface of the soil column. Fig 3. Acceleration, velocity, and displacement response spectra at the ground surface of the soil column. \u003cbr style=\"clear: both\" /\u003e\nComparison of Results with One-Dimensional Analysis Tools Fig 4. Acceleration time history response of at the ground surface of the soil column for freeFieldIndepend.tcl analysis as compared to ProShake and ProShakeNL results. Fig 5. Acceleration, velocity, and displacement response spectra at the ground surface of the soil column for freeFieldIndepend.tcl analysis as compared to ProShake and ProShakeNL results. Fig 6. Acceleration time history response of at the ground surface of the soil column for freeFieldDepend.tcl analysis as compared to ProShake and ProShakeNL results. Fig 7. Acceleration, velocity, and displacement response spectra at the ground surface of the soil column for freeFieldDepend.tcl analysis as compared to ProShake and ProShakeNL results. To validate the site response analysis framework used in these examples, a comparison study was accomplished using the one-dimensional, equivalent linear site response analysis program ProShake and the one-dimensional, nonlinear site response analysis program ProShakeNL. The input files freeFieldIndepend.tcl and freeFieldDepend.tcl were used for this purpose.\nIn the comparison study, a sand deposit having a parabolically-increasing shear wave velocity profile with depth was selected. This profile is implemented in OpenSees using 30 material layers, each having a specified shear wave velocity, which is then used to compute appropriate values for the shear and bulk moduli. It is important to note that the pressure dependency exponent is set to zero so the input values of shear and bulk modulus for each layer are not updated based on the overburden stress in each element.\nThe layering scheme was set up to match that used in the 1D analyses, with each layer having appropriate material parameters, and all analyses used the same ground motion applied to the base of the soil deposit. The 1D analyses include an infinite elastic half-space below the soil deposit, and these layers were assigned properties corresponding the bedrock properties used in the OpenSees analyses.\nThe two example input files represent two separate approaches to this comparison study. In the file, freeFieldIndepend.tcl, the soil is defined using the PressureIndependMultiYield nDMaterial, and the user-generated modulus reduction (G/Gmax) option is used, with the selected G/Gmax curves matching those used in the Shake analyses. Using this approach, the strength of each soil layer is defined entirely by the input G/Gmax data and the shear modulus value assigned to that layer. Parameters such as friction angle and cohesion are not used for this purpose. Though the material is called 'pressure independent', it is important to note that pressure dependency was manually introduced into the model by specifying the shear wave velocity of each layer. If it is also assumed that the confining pressure will not dramatically change during the excitation, then this approach becomes even more acceptable, especially in a free-field analysis where 2D elements are used to mimic a 1D analysis.\nFigs. 4 and 5 show the surface acceleration histories and the response spectra at the surface, respectively, obtained from the analysis using the file, freeFieldIndepend.tcl, alongside the results obtained from ProShake and ProShakeNL. As shown, the OpenSees analysis correlates well with the results obtained using the nonlinear 1D analysis (ProShakeNL). It is interesting to note the differences between the equivalent-linear approach of ProShake and the nonlinear approaches used by OpenSees and ProShakeNL. As shown in Fig. 4, during the low amplitude shaking near the beginning of the motion, the ProShake results are significantly different from the others. In the nonlinear analyses, during this initial low amplitude shaking the response is elastic. Plastic behavior does not occur until the stronger shaking which occurs later in the motion. In the equivalent-linear approach, this type of response cannot be captured for a strong motion such as that used in this example. If the largest shaking is enough to produce plastic response, then the soil acts as if it is plastic during the entire motion. One way to use an equivalent-linear analysis tool to check nonlinear results is to use motions in which the amplitudes are scaled down.\nThe second comparison example, found in the file, freeFieldDepend.tcl, represents a more typical approach to a site response analysis of a sand profile in OpenSees. The PressureDependMultiYield nDMaterial is used, with soil properties corresponding to those used in the two Shake analyses, and automatically-generated yield surfaces (G/Gmax) curves. In this case, the constitutive model used the specified friction angle to define the strength of each layer, however, in order to maintain a shear wave velocity profile which corresponds to the other analyses, the pressure dependency exponent is set to zero and the shear wave values are input manually for each layer. If this was not a desired aspect of the analysis, a single material could be used along with a non-zero pressure dependency exponent to produce a pressure-dependent stiffness profile.\nFigs. 6 and 7 show the surface acceleration histories and the response spectra at the surface, respectively, obtained from the analysis using the file, freeFieldDepend.tcl, alongside the results obtained from ProShake and ProShakeNL. As shown, the OpenSees analysis correlates well with the results obtained using ProShakeNL during lower amplitude shaking, though it deviates during the stronger shaking portions of the motion. The peak ground acceleration returned using this approach correlates fairly well with the equivalent-linear results, though this may be coincidental to the amount of Rayleigh damping used in the analysis.\nThis comparison study has demonstrated that a site response analysis conducted in OpenSees using the approaches detailed in these examples is capable of producing results which correlate well with commonly used site response analysis approaches. The approach that is selected should depend upon the objectives of the particular analysis in which they will be used. If the goal of the analysis is to emulate results obtained using a 1D analysis tool, the approach used in freeFieldIndepend.tcl is recommended, however, it is noted that care should be taken when attempting to use this approach in a two-dimensional analysis (i.e. more than just a single soil column). For 2D analyses, it is often easier and more realistic to define materials with pressure dependent strength, such as sands, using and approach similar to that in freeFieldDepend.tcl.\nReferences Chopra, A.K. (2007). Dynamics of Structures, Third Edition, Pearson Prentice Hall. Joyner, W.B. and Chen, A.T.F. (1975). \"Calculation of nonlinear ground response in earthquakes,\" Bulletin of the Seismological Society of America, Vol. 65, No. 5, pp. 1315-1336, October 1975. LeVeque, R.J. (2007). Finite Difference Methods for Ordinary and Partial Differential Equations, Society for Industrial and Applied Mathematics, Philadelphia. Lysmer, J. (1978). \"Analytical procedures in soil dynamics,\" Report No. UCB/EERC-78/29, University of California at Berkeley, Earthquake Engineering Research Center, Richmond, CA. Lysmer, J. and Kuhlemeyer, A.M. (1969). \"Finite dynamic model for infinite media,\" Journal of the Engineering Mechanics Division, ASCE, 95, 859-877. Return to OpenSees Examples Page\n","title":"Site Response Analysis of a Layered Soil Column (Total Stress Analysis)","uri":"/opensees-gallery/community/siteresponseanalysis/"},{"content":"This folder contains ready-to-run 2-dimensional OpenSEES models of four archetype steel buildings designed with perimeter special concentrically-braced frames (SCBFs), with heights of 3, 6, 12 and 16-story.\nNote that now you can generate further frame configurations using the new FM-2D software ( https://github.com/amaelkady/FM-2D ).\nReferences: •\tElkady, A., and Lignos, D. G. (2014). “Modeling of the composite action in fully restrained beam-to-column connections: implications in the seismic design and collapse capacity of steel special moment frames.” Earthquake Engineering \u0026 Structural Dynamics, 43(13), 1935-1954, DOI: 10.1002/eqe.2430.\n•\tElkady, A., and Lignos, D. G. (2015). “Effect of gravity framing on the overstrength and collapse capacity of steel frame buildings with perimeter special moment frames.” Earthquake Engineering \u0026 Structural Dynamics, 44(8), 1289–1307, DOI: 10.1002/eqe.2519.\n•\tHwang, S. H., and Lignos, D. G. (2017). “Effect of modeling assumptions on the earthquake-induced losses and collapse risk of steel-frame buildings with special concentrically braced frames.” Journal of Structural Engineering, 143(9), 04017116, DOI: 10.1061/(ASCE)ST.1943-541X.0001851.\n","title":"Special concentrically-braced frames","uri":"/opensees-gallery/examples/opensees_models_cbf/"},{"content":"Download (Two Story Steel MRF (FGU).ipynb)\nTwo Story Steel MRF December 2021, By Amir Hossein Namadchi In this notebook, a 2 story steel moment resisting frame is modeled. This is an OpenSeesPy simulation of TCL version of the model, presented by Fernando Gutiérrez Urzúa in his YouTube channel. Some minor modifications are made by me in the python version. According to his, modeling assumptions are:\nColumns are modeled as distributed plasticity elements Beams are modeled as concentrated plasticity elements Plastic hinges are modeled as two nodes at the same coordinates, connected via a rotational spring. The functions defined in this notebook are as follows:\nW_section: Creates W-Section based on nominal dimension and generates fibers over it build_model: Builds the 2D Steel Moment resisting Frame Model run_gravity: Runs gravity analysis run_modal: Runs Modal analysis run_pushover: Runs Pushover analysis run_time_history: Runs Time history analysis reset_analysis: Resets the analysis by setting time to 0,removing the recorders and wiping the analysis. Please note that some functions use data obtained by running other functions. For example, in order to run Pushover analysis, some components of eigenvectors are needed that is obtained via run_modal function. It’s highly recommended to watch Dr. Fernando Gutiérrez Urzúa videos for better understanding.\nDependencies import opensees.openseespy as ops import numpy as np import matplotlib.pyplot as plt import pandas as pd import time Functions Below functions can be encapsulated in a single .py file.\ndef W_section(section, sec_tag, mat_tag, nf_dw, nf_tw, nf_bf, nf_tf): \"\"\" Creates W-Section based on nominal dimension and generates fibers over it TCL version by: Remo M. de Souza, 08/99 Python version by: Amir Hossein Namadchi, 2022 Keyword arguments: section -- a dict type containing section info sec_tag -- Section tag mat_tag -- Material Tag nf_dw -- Number of fibers along web depth nf_tw -- Number of fibers along web thickness nf_bf -- Number of fibers along flange width nf_tf -- Number of fibers along flange thickness \"\"\" # unpack variables for readability d, bf = section['d'], section['bf'] tf, tw = section['tf'], section['tw'] dw = d - 2*tf y1, y2, y3, y4 = -d/2, -dw/2, dw/2, d/2 z1, z2, z3, z4 = -bf/2, -tw/2, tw/2, bf/2 ops.section('Fiber', sec_tag) ops.patch('quad', mat_tag, nf_bf, nf_tf, *[y1,z4], *[y1,z1], *[y2,z1], *[y2,z4]) ops.patch('quad', mat_tag, nf_tw, nf_dw, *[y2,z3], *[y2,z2], *[y3,z2], *[y3,z3]) ops.patch('quad', mat_tag, nf_bf, nf_tf, *[y3,z4], *[y3,z1], *[y4,z1], *[y4,z4]) def build_model(): \"\"\" Builds the 2D Steel Moment resisting Frame Model \"\"\" ## Units m = 1.0 # Meters KN = 1.0 # KiloNewtons sec = 1.0 # Seconds mm = 0.001*m # Milimeters cm = 0.01*m # Centimeters ton = KN*(sec**2)/m # mass unit (derived) g = 9.81*(m/sec**2) # gravitational constant ops.wipe() ops.model('basic','-ndm',2,'-ndf',3) L_x = 6.0*m # Span L_y = 3.5*m # Story Height # Node Coordinates Matrix (size : nn x 2) node_coords = np.array([[0, 0], [L_x, 0], [0, L_y], [L_x, L_y], [0, 2*L_y], [L_x, 2*L_y], [0, L_y], [L_x, L_y], [0, 2*L_y], [L_x, 2*L_y]]) # Element Connectivity Matrix (size: nel x 2) connectivity = [[1,3], [2,4], [3,5], [4,6], [7,8], [9,10], [7,3], [8,4], [9,5], [10,6] ] # Get Number of elements nel = len(connectivity) # Distinguish beams, columns \u0026 hinges by their element tag ID all_the_beams = [5, 6] all_the_cols = [1, 2, 3, 4] all_the_hinges = [7, 8, 9, 10] # Columns are modeled using `Steel01` material, beams are # assumed elastic and plastic hinges are modeled via `Bilin` # material, proposed by *D. G. Lignos \u0026 H. Krawinkler* # Uniaxial bilinear steel material with kinematic hardening mat_S355 = {'ID':'Steel01', 'matTag':1, 'Fy':(3.55e5)*(KN/m**2), 'E0':(2.1e8)*(KN/m**2), 'b':0.01} ## Material used for plastic hinges # Modified Ibarra-Medina-Krawinkler Deterioration Model with Bilinear Hysteretic Response (Bilin Material) # https://ascelibrary.org/doi/full/10.1061/%28ASCE%29ST.1943-541X.0000376 mat_lignos = {'ID':'Bilin', 'matTag':2, 'K0':(64033.2)*(KN/m), 'as_Plus':0.00203545752454409, 'as_Neg':0.00203545752454409, 'My_Plus':101.175*(KN*m), 'My_Neg':-101.175*(KN*m), 'Lamda_S':1.50476106091578, 'Lamda_C':1.50476106091578, 'Lamda_A':1.50476106091578, 'Lamda_K':1.50476106091578, 'c_S':1, 'c_C':1, 'c_A':1, 'c_K':1, 'theta_p_Plus':0.0853883552651735, 'theta_p_Neg': 0.0853883552651735, 'theta_pc_Plus':0.234610805942179, 'theta_pc_Neg':0.234610805942179, 'Res_Pos': 0.4, 'Res_Neg': 0.4, 'theta_u_Plus': 0.4, 'theta_u_Neg': 0.4, 'D_Plus':1, 'D_Neg':1 } # Main Beams and Columns sections = {'IPE220':{'d':220.0*mm, 'tw':5.9*mm, 'bf':110.0*mm, 'tf':9.2*mm, 'A':33.4*(cm**2), 'I1':2772.0*(cm**4), 'I2':205.0*(cm**4)}, 'HE180B':{'d':180.0*mm, 'tw':8.5*mm, 'bf':180.0*mm, 'tf':14.0*mm, 'A':65.3*(cm**2), 'I1':3830.0*(cm**4), 'I2':1360.0*(cm**4)} } # For columns, `nonlinearBeamColumn` and for beams, # `elasticBeamColumn` is employed. Furthermore, `zeroLength` # element is used to model plastic hinges. # Main Nodes [ops.node(n+1,*node_coords[n]) for n in range(len(node_coords))]; # Boundary Conditions ## Fixing the Base Nodes [ops.fix(n, 1, 1, 1) for n in [1, 2]]; ## Tie the displacements (not rotations) in plastic hinges: ops.equalDOF(3, 7, *[1,2]) ops.equalDOF(4, 8, *[1,2]) ops.equalDOF(5, 9, *[1,2]) ops.equalDOF(6, 10, *[1,2]) # Materials ## For Columns ops.uniaxialMaterial(*mat_S355.values()) ## For Plastic Hinges ops.uniaxialMaterial(*mat_lignos.values()) # Adding Sections ## For Columns W_section(sections['HE180B'], 1, mat_S355['matTag'], *[4, 2, 4, 2]) # Transformations ops.geomTransf('PDelta', 1) # Adding Elements ## Beams [ops.element('elasticBeamColumn', e, *connectivity[e-1], sections['IPE220']['A'], mat_S355['E0'], sections['IPE220']['I1'], 1) for e in all_the_beams]; ## Columns [ops.element('nonlinearBeamColumn', e, *connectivity[e-1], 4, 1, 1) for e in all_the_cols]; ## Plastic Hinges [ops.element('zeroLength', e, *connectivity[e-1], '-mat', mat_lignos['matTag'], '-dir', 6) for e in all_the_hinges]; global m_1 D_L = 20.0*(KN/m) # Distributed load C_L = 50.0*(KN) # Concentrated load m_1 = 75.0*ton # lumped mass 1 # Now, loads \u0026 lumped masses will be added to the domain. loaded_nodes = [3,4,5,6] loaded_elems = [5,6] ops.timeSeries('Linear',1,'-factor',1.0) ops.pattern('Plain', 1, 1) [ops.load(n, *[0,-C_L,0]) for n in loaded_nodes]; ops.eleLoad('-ele', *loaded_elems,'-type', '-beamUniform',-D_L) [ops.mass(n, *[m_1*0.5,0,0]) for n in loaded_nodes]; print('Model built successfully!') def run_gravity(steps = 10): \"\"\" Runs gravity analysis. Note that the model should be built before calling this function. Keyword arguments: steps -- total number of analysis steps \"\"\" ops.initialize() # Records the response of a number of nodes at every converged step ops.recorder('Node', '-file', 'assets/Gravity_Reactions.out', '-time','-node', *[1,2], '-dof', *[1,2,3], 'reaction') # plain constraint handler enforces homogeneous single point constraints ops.constraints('Plain') # RCM numberer uses the reverse Cuthill-McKee scheme to order the matrix equations ops.numberer('RCM') # Constructs a profileSPDSOE (Symmetric Positive Definite) system of equation object ops.system('ProfileSPD') # Uses the norm of the left hand side solution vector of the matrix equation to # determine if convergence has been reached ops.test('NormDispIncr', 1.0e-6, 100, 0, 2) # Uses the Newton-Raphson algorithm to solve the nonlinear residual equation ops.algorithm('Newton') # Uses LoadControl integrator object ops.integrator('LoadControl', 0.1) # Constructs the Static Analysis object ops.analysis('Static') # Records the current state of the model ops.record() # Performs the analysis ops.analyze(steps) print(\"Gravity analysis Done!\") def run_modal(n_evs = 2): \"\"\" Runs Modal analysis. Note that the model should be built before calling this function. Keyword arguments: n_evs -- number of eigenvalues \"\"\" ops.initialize() # Records Eigenvector entries for Node 1,3 \u0026 5 @ dof 1 ops.recorder('Node', '-file', 'assets/ModalAnalysis_Node_EigenVectors_EigenVec1.out', '-node', *[1,3,5], '-dof', 1, 'eigen 1') ops.recorder('Node', '-file', 'assets/ModalAnalysis_Node_EigenVectors_EigenVec2.out', '-node', *[1,3,5], '-dof', 1, 'eigen 2') # Constructs a transformation constraint handler, # which enforces the constraints using the transformation method. ops.constraints('Transformation') # Constructs a Plain degree-of-freedom numbering object # to provide the mapping between the degrees-of-freedom at # the nodes and the equation numbers. ops.numberer('Plain') # Construct a BandGeneralSOE linear system of equation object ops.system('BandGen') # Uses the norm of the left hand side solution vector of the matrix equation to # determine if convergence has been reached ops.test('NormDispIncr', 1.0e-12, 25, 0, 2) # Uses the Newton-Raphson algorithm to solve the nonlinear residual equation ops.algorithm('Newton') # Create a Newmark integrator. ops.integrator('Newmark', 0.5, 0.25) # Constructs the Transient Analysis object ops.analysis('Transient') # Eigenvalue analysis lamda = np.array(ops.eigen(n_evs)) # Writing Eigenvalue information to file with open(\"assets/ModalAnalysis_Node_EigenVectors_EigenVal.out\", \"w\") as eig_file: # Writing data to a file eig_file.write(\"lambda omega period frequency\\n\") for l in lamda: line_to_write = [l, l**0.5, 2*np.pi/(l**0.5), (l**0.5)/(2*np.pi)] eig_file.write('{:2.6e} {:2.6e} {:2.6e} {:2.6e}'.format(*line_to_write)) eig_file.write('\\n') # Record eigenvectors ops.record() print(\"Modal analysis Done!\") def run_pushover(steps = 5000): \"\"\" Runs Pushover analysis. Note that the model should be built before calling this function. Also, Gravity analysis should be called afterwards. Morover, the function requires some components of eigenvectors obtained by calling the `run_modal` function. Keyword arguments: steps -- total number of analysis steps \"\"\" ## Records the response of a number of nodes at every converged step # Global behaviour # records horizontal reactions of node 1 \u0026 2 ops.recorder('Node', '-file', 'assets/Pushover_Horizontal_Reactions.out', '-time','-node', *[1,2], '-dof', 1, 'reaction') # records horizontal displacements of node 3 \u0026 5 ops.recorder('Node','-file', 'assets/Pushover_Story_Displacement.out', '-time','-node', *[3,5], '-dof',1, 'disp') # Local behaviour # records Mz_1 \u0026 Mz_2 for each hinge. other forces are zero ops.recorder('Element','-file', 'assets/Pushover_BeamHinge_GlbForc.out', '-time','-ele', *[7,8,9,10],'force') # records the rotation of each hinges, ranging from 7 to 10 ops.recorder('Element','-file', 'assets/Pushover_BeamHinge_Deformation.out', '-time','-eleRange',*[7, 10], 'deformation') # records Px_1,Py_1,Mz_1,Px_2,Py_2,Mz_2 for elements 1 to 4 ops.recorder('Element','-file', 'assets/Pushover_Column_GlbForc.out', '-time','-eleRange',*[1,4], 'globalForce') # eps, theta_1, theta_2 for elements 1 to 4 ops.recorder('Element','-file', 'assets/Pushover_Column_ChordRot.out', '-time','-ele', *[1,2,3,4], 'chordRotation') # Measure analysis duration tic = time.time() # load eigenvectors for mode 1 phi = np.abs(np.loadtxt('assets/ModalAnalysis_Node_EigenVectors_EigenVec1.out')) # Apply lateral load based on first mode shape in x direction (EC8-1) ops.pattern('Plain', 2, 1) [ops.load(n, *[m_1*phi[1],0,0]) for n in [3,4]]; [ops.load(n, *[m_1*phi[2],0,0]) for n in [5,6]]; # Define step parameters step = +1.0e-04 number_of_steps = steps # Constructs a transformation constraint handler, # which enforces the constraints using the transformation method. ops.constraints('Transformation') # RCM numberer uses the reverse Cuthill-McKee scheme to order the matrix equations ops.numberer('RCM') # Construct a BandGeneralSOE linear system of equation object ops.system('BandGen') # Uses the norm of the left hand side solution vector of the matrix equation to # determine if convergence has been reached ops.test('NormDispIncr', 0.000001, 100) # Line search increases the effectiveness of the Newton method # when convergence is slow due to roughness of the residual. ops.algorithm('NewtonLineSearch',True, 0.8, 1000, 0.1, 10.0) # Displacement Control tries to determine the time step that will # result in a displacement increment for a particular degree-of-freedom # at a node to be a prescribed value. # Target node is 5 and dof is 1 ops.integrator('DisplacementControl',5,1, step) # Constructs the Static Analysis object ops.analysis('Static') # Records the current state of the model ops.record() # Performs the analysis ops.analyze(number_of_steps) toc = time.time() print('Pushover Analysis Done in {:1.2f} seconds'.format(toc-tic)) def run_time_history(g_motion_id = 1, scaling_id = 1, lamda = 1, acc_dir = 'assets/acc_1.txt'): \"\"\" Runs Time history analysis. Note that the model should be built before calling this function. Also, Gravity analysis should be called afterwards. Keyword arguments: g_motion_id -- Groundmotion id (in case you run many GMs, like in an IDA) scaling_id -- Scaling id (in case you run many GMs, like in an IDA) lamda -- Scaling of the GM acc_dir -- file directory of GM to read from \"\"\" ## Records the response of a number of nodes at every converged step # Global behaviour # records horizontal reactions of node 1 \u0026 2 ops.recorder('Node','-file', ('assets/TimeHistory_Horizontal_Reactions.' +str(g_motion_id)+'.'+str(scaling_id)+'.out'), '-time','-node',*[1,2],'-dof',1,'reaction') # records horizontal displacements of node 3 \u0026 5 ops.recorder('Node','-file', ('assets/TimeHistory_Story_Displacement.' +str(g_motion_id)+'.'+str(scaling_id)+'.out'), '-time','-node',*[3,5],'-dof',1,'disp') # Local behaviour # records Mz_1 \u0026 Mz_2 for each hinge. other forces are zero ops.recorder('Element','-file', ('assets/TimeHistory_BeamHinge_GlbForc.' +str(g_motion_id)+'.'+str(scaling_id)+'.out'), '-time','-ele',*[7,8,9,10],'force') # records the rotation of each hinges, ranging from 7 to 10 ops.recorder('Element','-file', ('assets/TimeHistory_BeamHinge_Deformation.' +str(g_motion_id)+'.'+str(scaling_id)+'.out'), '-time','-eleRange',*[7,10],'deformation') # records Px_1,Py_1,Mz_1,Px_2,Py_2,Mz_2 for elements 1 to 4 ops.recorder('Element','-file', ('assets/TimeHistory_Column_GlbForc.' +str(g_motion_id)+'.'+str(scaling_id)+'.out'), '-time','-eleRange',*[1,4],'globalForce') # eps, theta_1, theta_2 for elements 1 to 4 ops.recorder('Element','-file', ('assets/TimeHistory_Column_ChordRot.' +str(g_motion_id)+'.'+str(scaling_id)+'.out'), '-time','-ele',*[1,2,3,4],'chordRotation') # Reading omega for obraining Rayleigh damping model omega = np.loadtxt('assets/ModalAnalysis_Node_EigenVectors_EigenVal.out',skiprows=1)[:,1] xis = np.array([0.03, 0.03]) a_R, b_R = 2*((omega[0]*omega[1])/(omega[1]**2-omega[0]**2))*( np.array([[omega[1],-omega[0]], [-1/omega[1],1/omega[0]]])@xis) ## Analysis Parameters accelerogram = np.loadtxt(acc_dir) # Loads accelerogram file dt = 0.02 # Time-Step n_steps = len(accelerogram) # Number of steps tol = 1.0e-6 # prescribed tolerance max_iter = 5000 # Maximum number of iterations per step # Uses the norm of the left hand side solution vector of the matrix equation to # determine if convergence has been reached ops.test('NormDispIncr', tol, max_iter,0,0) # RCM numberer uses the reverse Cuthill-McKee scheme to order the matrix equations ops.numberer('RCM') # Construct a BandGeneralSOE linear system of equation object ops.system('BandGen') # The relationship between load factor and time is input by the user as a # series of discrete points ops.timeSeries('Path', 2, '-dt', dt, '-values', *accelerogram, '-factor', lamda) # allows the user to apply a uniform excitation to a model acting in a certain direction ops.pattern('UniformExcitation', 3, 1,'-accel', 2) # Constructs a transformation constraint handler, # which enforces the constraints using the transformation method. ops.constraints('Transformation') # Create a Newmark integrator. ops.integrator('Newmark', 0.5, 0.25) # assign damping to all previously-defined elements and nodes ops.rayleigh(a_R, b_R, 0.0, 0.0) # Introduces line search to the Newton algorithm to solve the nonlinear residual equation ops.algorithm('NewtonLineSearch',True,False,False,False,0.8,100,0.1,10.0) # Constructs the Transient Analysis object ops.analysis('Transient') # Measure analysis duration t = 0 ok = 0 print('Running Time-Histroy analysis with lambda=',lamda) start_time = time.time() final_time = ops.getTime() + n_steps*dt dt_analysis = 0.1*dt while (ok == 0 and t \u003c= final_time): ok = ops.analyze(1, dt_analysis) t = ops.getTime() finish_time = time.time() if ok == 0: print('Time-History Analysis Done in {:1.2f} seconds'.format(finish_time-start_time)) else: print('Time-History Analysis Failed in {:1.2f} seconds'.format(finish_time-start_time)) ops.wipe() def reset_analysis(): \"\"\" Resets the analysis by setting time to 0, removing the recorders and wiping the analysis. \"\"\" # Reset for next analysis case ## Set the time in the Domain to zero ops.setTime(0.0) ## Set the loads constant in the domain ops.loadConst() ## Remove all recorder objects. ops.remove('recorders') ## destroy all components of the Analysis object ops.wipeAnalysis() Analysis Gravity Analysis build_model(); run_gravity(); reset_analysis(); ops.wipe(); Output:\nModified Ibarra-Medina-Krawinkler Model with Bilinear Hysteretic Response Model built successfully! Gravity analysis Done! df_reactions = pd.read_table('assets/Gravity_Reactions.out', header=None, sep=\" \", names=[\"Pseudo-Time\",\"R1_1\",\"R1_2\",\"R1_3\",\"R2_1\",\"R2_2\",\"R2_3\"]) df_reactions Output:\n\u003cdiv\u003e \u003cstyle scoped\u003e .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } \u003c/style\u003e \u003ctable border=\"1\" class=\"dataframe\"\u003e \u003cthead\u003e \u003ctr style=\"text-align: right;\"\u003e \u003cth\u003e\u003c/th\u003e \u003cth\u003ePseudo-Time\u003c/th\u003e \u003cth\u003eR1_1\u003c/th\u003e \u003cth\u003eR1_2\u003c/th\u003e \u003cth\u003eR1_3\u003c/th\u003e \u003cth\u003eR2_1\u003c/th\u003e \u003cth\u003eR2_2\u003c/th\u003e \u003cth\u003eR2_3\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003cth\u003e0\u003c/th\u003e \u003ctd\u003e0.0\u003c/td\u003e \u003ctd\u003e0.000000\u003c/td\u003e \u003ctd\u003e0\u003c/td\u003e \u003ctd\u003e0.000000\u003c/td\u003e \u003ctd\u003e0.000000\u003c/td\u003e \u003ctd\u003e0\u003c/td\u003e \u003ctd\u003e0.000000\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003cth\u003e1\u003c/th\u003e \u003ctd\u003e0.1\u003c/td\u003e \u003ctd\u003e0.749647\u003c/td\u003e \u003ctd\u003e22\u003c/td\u003e \u003ctd\u003e-0.884039\u003c/td\u003e \u003ctd\u003e-0.749647\u003c/td\u003e \u003ctd\u003e22\u003c/td\u003e \u003ctd\u003e0.884039\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003cth\u003e2\u003c/th\u003e \u003ctd\u003e0.2\u003c/td\u003e \u003ctd\u003e1.499200\u003c/td\u003e \u003ctd\u003e44\u003c/td\u003e \u003ctd\u003e-1.768080\u003c/td\u003e \u003ctd\u003e-1.499200\u003c/td\u003e \u003ctd\u003e44\u003c/td\u003e \u003ctd\u003e1.768080\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003cth\u003e3\u003c/th\u003e \u003ctd\u003e0.3\u003c/td\u003e \u003ctd\u003e2.248670\u003c/td\u003e \u003ctd\u003e66\u003c/td\u003e \u003ctd\u003e-2.652130\u003c/td\u003e \u003ctd\u003e-2.248670\u003c/td\u003e \u003ctd\u003e66\u003c/td\u003e \u003ctd\u003e2.652130\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003cth\u003e4\u003c/th\u003e \u003ctd\u003e0.4\u003c/td\u003e \u003ctd\u003e2.998040\u003c/td\u003e \u003ctd\u003e88\u003c/td\u003e \u003ctd\u003e-3.536180\u003c/td\u003e \u003ctd\u003e-2.998040\u003c/td\u003e \u003ctd\u003e88\u003c/td\u003e \u003ctd\u003e3.536180\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003cth\u003e5\u003c/th\u003e \u003ctd\u003e0.5\u003c/td\u003e \u003ctd\u003e3.747320\u003c/td\u003e \u003ctd\u003e110\u003c/td\u003e \u003ctd\u003e-4.420230\u003c/td\u003e \u003ctd\u003e-3.747320\u003c/td\u003e \u003ctd\u003e110\u003c/td\u003e \u003ctd\u003e4.420230\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003cth\u003e6\u003c/th\u003e \u003ctd\u003e0.6\u003c/td\u003e \u003ctd\u003e4.496520\u003c/td\u003e \u003ctd\u003e132\u003c/td\u003e \u003ctd\u003e-5.304280\u003c/td\u003e \u003ctd\u003e-4.496520\u003c/td\u003e \u003ctd\u003e132\u003c/td\u003e \u003ctd\u003e5.304280\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003cth\u003e7\u003c/th\u003e \u003ctd\u003e0.7\u003c/td\u003e \u003ctd\u003e5.245620\u003c/td\u003e \u003ctd\u003e154\u003c/td\u003e \u003ctd\u003e-6.188340\u003c/td\u003e \u003ctd\u003e-5.245620\u003c/td\u003e \u003ctd\u003e154\u003c/td\u003e \u003ctd\u003e6.188340\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003cth\u003e8\u003c/th\u003e \u003ctd\u003e0.8\u003c/td\u003e \u003ctd\u003e5.994630\u003c/td\u003e \u003ctd\u003e176\u003c/td\u003e \u003ctd\u003e-7.072400\u003c/td\u003e \u003ctd\u003e-5.994630\u003c/td\u003e \u003ctd\u003e176\u003c/td\u003e \u003ctd\u003e7.072400\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003cth\u003e9\u003c/th\u003e \u003ctd\u003e0.9\u003c/td\u003e \u003ctd\u003e6.743550\u003c/td\u003e \u003ctd\u003e198\u003c/td\u003e \u003ctd\u003e-7.956470\u003c/td\u003e \u003ctd\u003e-6.743550\u003c/td\u003e \u003ctd\u003e198\u003c/td\u003e \u003ctd\u003e7.956470\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003cth\u003e10\u003c/th\u003e \u003ctd\u003e1.0\u003c/td\u003e \u003ctd\u003e7.492370\u003c/td\u003e \u003ctd\u003e220\u003c/td\u003e \u003ctd\u003e-8.840540\u003c/td\u003e \u003ctd\u003e-7.492370\u003c/td\u003e \u003ctd\u003e220\u003c/td\u003e \u003ctd\u003e8.840540\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e \u003c/div\u003e Pseudo-Time R1_1 R1_2 R1_3 R2_1 R2_2 R2_3 0 0.0 0.000000 0 0.000000 0.000000 0 0.000000 1 0.1 0.749647 22 -0.884039 -0.749647 22 0.884039 2 0.2 1.499200 44 -1.768080 -1.499200 44 1.768080 3 0.3 2.248670 66 -2.652130 -2.248670 66 2.652130 4 0.4 2.998040 88 -3.536180 -2.998040 88 3.536180 5 0.5 3.747320 110 -4.420230 -3.747320 110 4.420230 6 0.6 4.496520 132 -5.304280 -4.496520 132 5.304280 7 0.7 5.245620 154 -6.188340 -5.245620 154 6.188340 8 0.8 5.994630 176 -7.072400 -5.994630 176 7.072400 9 0.9 6.743550 198 -7.956470 -6.743550 198 7.956470 10 1.0 7.492370 220 -8.840540 -7.492370 220 8.840540 Modal Analysis build_model(); run_modal(); reset_analysis(); ops.wipe(); Output:\nModel built successfully! Modal analysis Done! df_eigs = pd.read_table('assets/ModalAnalysis_Node_EigenVectors_EigenVal.out', sep=\" \") df_eigs Output:\n\u003cdiv\u003e \u003cstyle scoped\u003e .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } \u003c/style\u003e \u003ctable border=\"1\" class=\"dataframe\"\u003e \u003cthead\u003e \u003ctr style=\"text-align: right;\"\u003e \u003cth\u003e\u003c/th\u003e \u003cth\u003elambda\u003c/th\u003e \u003cth\u003eomega\u003c/th\u003e \u003cth\u003eperiod\u003c/th\u003e \u003cth\u003efrequency\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003cth\u003e0\u003c/th\u003e \u003ctd\u003e7.352407\u003c/td\u003e \u003ctd\u003e2.711532\u003c/td\u003e \u003ctd\u003e2.317208\u003c/td\u003e \u003ctd\u003e0.431554\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003cth\u003e1\u003c/th\u003e \u003ctd\u003e102.341000\u003c/td\u003e \u003ctd\u003e10.116370\u003c/td\u003e \u003ctd\u003e0.621091\u003c/td\u003e \u003ctd\u003e1.610071\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e \u003c/div\u003e lambda omega period frequency 0 7.352407 2.711532 2.317208 0.431554 1 102.341000 10.116370 0.621091 1.610071 Pushover Analysis build_model(); run_gravity(); reset_analysis(); run_pushover(); ops.wipe(); Output:\nModel built successfully! Gravity analysis Done! Pushover Analysis Done in 1.68 seconds Time-History Analysis build_model(); run_gravity(); reset_analysis(); run_time_history(); ops.wipe(); Output:\nModel built successfully! Gravity analysis Done! Running Time-Histroy analysis with lambda= 1 Time-History Analysis Done in 17.42 seconds Visualization Pushover Analysis pover_x_react = np.loadtxt('assets/Pushover_Horizontal_Reactions.out') pover_story_disp = np.loadtxt('assets/Pushover_Story_Displacement.out') plt.figure(figsize=(10,5)) plt.plot(pover_story_disp[:,2], -(pover_x_react[:,1]+pover_x_react[:,2]), color = '#2ab7ca', linewidth=1.75) plt.ylabel('Base Shear (KN)', {'fontname':'Cambria', 'fontstyle':'italic','size':14}) plt.xlabel('Roof Displacement (m)', {'fontname':'Cambria', 'fontstyle':'italic','size':14}) plt.grid(which='both') plt.title('Pushover Curve',{'fontname':'Cambria', 'fontstyle':'normal','size':16}) plt.yticks(fontname = 'Cambria', fontsize = 14) plt.xticks(fontname = 'Cambria', fontsize = 14); Output:\n\u003cFigure size 720x360 with 1 Axes\u003e Time History Analysis Ground Motion histroy G_M =np.loadtxt('assets/acc_1.txt') times = np.arange(0,0.02*len(G_M),0.02) plt.figure(figsize=(12,4)) plt.plot(times,G_M, color = '#6495ED', linewidth=1.2) plt.ylabel('Acceleration (m/s2)', {'fontname':'Cambria', 'fontstyle':'italic','size':14}) plt.xlabel('Time (sec)', {'fontname':'Cambria', 'fontstyle':'italic','size':14}) plt.grid(which='both') plt.title('Time history of Ground Motion record',{'fontname':'Cambria', 'fontstyle':'normal','size':16}) plt.yticks(fontname = 'Cambria', fontsize = 14); plt.xticks(fontname = 'Cambria', fontsize = 14); Output:\n\u003cFigure size 864x288 with 1 Axes\u003e Time history of story displacement story_disp_th = np.loadtxt('assets/TimeHistory_Story_Displacement.1.1.out') plt.figure(figsize=(12,5)) plt.plot(story_disp_th[:,0], story_disp_th[:,1], color = '#DE3163', linewidth=1.2) plt.plot(story_disp_th[:,0], story_disp_th[:,2], color = '#FFBF00', linewidth=1.2) plt.ylabel('Horizontal Displacement (m)', {'fontname':'Cambria', 'fontstyle':'italic','size':14}) plt.xlabel('Time (sec)', {'fontname':'Cambria', 'fontstyle':'italic','size':14}) plt.grid(which='both') plt.title('Time history of horizontal dispacement',{'fontname':'Cambria', 'fontstyle':'normal','size':16}) plt.yticks(fontname = 'Cambria', fontsize = 14); plt.xticks(fontname = 'Cambria', fontsize = 14); plt.legend(['Story 1', 'Story 2'],prop={'family':'Cambria','size':14}); Output:\n\u003cFigure size 864x360 with 1 Axes\u003e References Fernando Gutiérrez Urzúa's YouTube channel (https://www.youtube.com/user/lfgurzua) OpenseesPy Documentation (https://openseespydoc.readthedocs.io/en/latest/) ","title":"Steel MRF","uri":"/opensees-gallery/examples/steelmrf/"},{"content":"Download (NLSMRF.ipynb)\nNonlinear seismic response of a MRF March 2020, By Amir Hossein Namadchi This is an OpenSeesPy simulation of a moment resisting frame subjected to seismic excitation. The model was introduced by C. Kolay \u0026 J. M. Ricles in their paper entitled Assessment of explicit and semi-explicit classes of model-based algorithms for direct integration in structural dynamics. The beams and columns of the MRF are modeled using dispBeamColumn fiber elements. The gravity load resisting system associated with the MRF is modeled using a lean-on column composed of linear elastic beam-column elements with 2nd Order $P-\\Delta$ effects [1].\nimport numpy as np import opensees.openseespy as ops import matplotlib.pyplot as plt import sees # %matplotlib notebook Units from opensees.units.mks import m, N, sec, inch, kg, gravity as g import opensees.units.mks as units KN = N*1000 # kg *= 1000 # *= gravity # TODO!!!!!!!!!!! ## Units # m = 1.0 # Meters # KN = 1.0 # KiloNewtons # sec = 1.0 # Seconds # inch = 0.0254*m # inches # kg = KN*(sec**2)/m # mass unit (derived) # g = 9.81*(m/sec**2) # gravitational constant inch Output:\n0.0254 Earthquake record This will load 1994 Northridge earthquake ground motion record (Canyon Country - W Lost Cany station) downloaded for the PEER website. Then, the record is scaled by a factor of 3 as follows (scaling could also be done when defining timeSeries):\ndt = 0.01*sec northridge = np.loadtxt('RSN960_NORTHR_LOS270.AT2', skiprows=4).flatten() northridge = np.column_stack((np.arange(0,len(northridge)*dt, dt), northridge*3*g)) Model Definition Geometry Node coordinates and element connectivity are defined.\nmodel = ops.Model(ndm=2, ndf=3) ## Main Nodes # Node Coordinates Matrix (size : nn x 2) node_coords = np.array([[0,0],[6,0], [0,1],[6,1], [0,2],[6,2], [0,2.5],[6,2.5], [0,3],[0.5,3],[1,3],[3,3],[5,3],[5.5,3],[6,3], [0,3.5],[6,3.5], [0,4],[6,4], [0,5],[6,5], [0,5.5],[6,5.5], [0,6],[0.5,6],[1,6],[3,6],[5,6],[5.5,6],[6,6] ], dtype = np.float64)*m ## Main Elements # Element Connectivity Matrix (size: nel x 2) connectivity = [[1, 3], [3, 5], [5, 7], [7, 9], [9, 10], [10, 11], [11, 12], [12, 13], [13, 14], [14, 15], [15, 8], [8, 6], [6, 4], [4, 2], [9, 16], [16, 18], [18, 20], [20, 22], [22, 24], [24, 25], [25, 26], [26, 27], [27, 28], [28, 29], [29, 30], [30, 23], [23, 21], [21, 19], [19, 17], [17, 15]] # Get Number of elements nel = len(connectivity) # Distinguish beams and columns by their element tag ID all_the_beams = list(range(5, 10+1)) + list(range(20, 25+1)) all_the_cols = list(np.setdiff1d(np.arange(1, nel+1), all_the_beams)) Sections \u0026 Material sections are defined in dict which is quite self-explanatory.\n# Main Beams and Columns sections = {'W24x55':{'d':23.57*inch, 'tw':0.395*inch, 'bf':7.005*inch, 'tf':0.505*inch, 'A':16.2*(inch**2), 'I1':1350*(inch**4), 'I2':29.1*(inch**4)}, 'W14x120':{'d':14.48*inch, 'tw':0.590*inch, 'bf':14.670*inch, 'tf':0.940*inch, 'A':35.3*(inch**2), 'I1':1380*(inch**4), 'I2':495*(inch**4)} } # Leaning columns section properties leaning_col = {'A':(9.76e-2)*m**2, 'I1':(7.125e-4)*m**4} # Material properties F_y = 345000*(KN/m**2) # yield strength E_0 = 2e8*(KN/m**2) # initial elastic tangent eta = 0.01 # strain-hardening ratio rho = 7850*(kg/m**3) # mass density Adding to the Domain # Nodal loads and Masses lumped_mass = 50.97*kg # seismic floor mass P_1 = 500*KN # Nodal loads # Adding nodes to the domain ## Main Nodes for n in range(len(node_coords)): model.node(n+1, *node_coords[n]) ## Fictitious Nodes (Leaning columns) model.node(100,*[7.0, 0.0]) # @ Base model.node(101,*[7.0, 3.0], '-mass', *[lumped_mass, 0.00001, 0.00001]) # @ Story 1 model.node(102,*[7.0, 6.0], '-mass', *[lumped_mass, 0.00001, 0.00001]) # @ Story 2 (roof) # Material # -\u003e uniaxial bilinear steel material with kinematic hardening model.uniaxialMaterial('Steel01', 1, F_y, E_0, eta) # Adding Sections ## Beams # model.section('WFSection2d', 1, 1, # sections['W24x55']['d'], # sections['W24x55']['tw'], # sections['W24x55']['bf'], # sections['W24x55']['tf'], 10, 3) model.section('Fiber', 1, shape=(\"W24x55\", 1, (10,3), units)) ## Columns model.section('Fiber', 2, shape=(\"W14x120\", 1, (10,3), units)) # model.section('WFSection2d', 2, 1, # sections['W14x120']['d'], # sections['W14x120']['tw'], # sections['W14x120']['bf'], # sections['W14x120']['tf'], 10, 3) # Boundary Conditions ## Fixing the Base Nodes for n in [1, 2, 100]: model.fix(n, 1, 1, 0) ## Rigid floor diaphragm model.equalDOF(12, 101, 1) model.equalDOF(27, 102, 1) # Transformations \u0026 Integration ## Transformation model.geomTransf('Linear', 1) # For Beams model.geomTransf('PDelta', 2) # For leaning Columns ## Integration scheme model.beamIntegration('Lobatto', 1, 1, 5) # For Beams model.beamIntegration('Lobatto', 2, 2, 5) # For Columns # Adding Elements ## Beams for e in all_the_beams: model.element('DispBeamColumn', e, *connectivity[e-1], 1, 1, '-cMass', rho*sections['W24x55']['A']) ## Columns ## -\u003e OpenseesPy cannot handle numpy int types ## -\u003e so I had to convert them to primitive python int type for e in list(map(int, all_the_cols)): model.element('DispBeamColumn', e, *connectivity[e-1], 1, 2, '-cMass', rho*sections['W14x120']['A']) ## Leaning Columns model.element('ElasticBeamColumn', nel+1, *[100, 101], leaning_col['A'], E_0, leaning_col['I1'], 2) model.element('ElasticBeamColumn', nel+2, *[101, 102], leaning_col['A'], E_0, leaning_col['I1'], 2) Draw Model The model can now be drawn using sees:\nsees.render(model) model.print(\"-json\", file=\"model.json\") Output:\n\u003cFigure size 640x480 with 1 Axes\u003e Damping Model The model assumes 2% damping for the first and second modes of the system according to rayleigh’s damping model. for two modes, the damping coefficients can be obtained by:\n$$ \\left( \\begin{array}{l} {\\alpha _0}\\\\ {\\alpha _1} \\end{array} \\right) = 2\\frac{{{\\omega _m}{\\omega _n}}}{{\\omega _n^2 - \\omega _m^2}}\\left[ {\\begin{array}{*{20}{c}} {{\\omega _n}}\u0026{ - {\\omega _m}}\\\\ { - 1/{\\omega _n}}\u0026{1/{\\omega _m}} \\end{array}} \\right]\\left( \\begin{array}{l} {\\zeta _m}\\\\ {\\zeta _n} \\end{array} \\right)\\ $$ So, we need to perform an eigen analysis to obtain first two natural frequencies.\n# Building Rayleigh damping model omega = np.sqrt(model.eigen('-fullGenLapack', 2)) print('Two first periods are:', 2*np.pi/omega) a_m, b_k = 2*((omega[0]*omega[1])/(omega[1]**2-omega[0]**2))*( np.array([[omega[1],-omega[0]], [-1/omega[1],1/omega[0]]])@np.array([0.02,0.02])) ## Rayleigh damping based on initial stiffness model.rayleigh(a_m, 0, b_k, 0) Output:\nTwo first periods are: [1.17694844e-06 1.74174909e-07] Analysis Gravity Analysis # Time Series model.timeSeries('Linear', 1) # For gravitional loads # Load Pattern model.pattern('Plain', 1, 1) model.load(101, *[0.0, -P_1, 0.0]) model.load(102, *[0.0, -P_1, 0.0]) # Settings model.constraints('Transformation') model.numberer('RCM') model.system('ProfileSPD') model.test('NormUnbalance', 0.000001, 100) model.algorithm('Newton') model.integrator('LoadControl', 0.1) model.analysis('Static') # Perform static analysis assert model.analyze(10) == 0 Output:\nStaticAnalysis::analyze - the Algorithm failed at step: 0 with domain at load factor 0.1 Time History Analysis # Set time to zero model.loadConst('-time', 0.0) model.wipeAnalysis() # Time Series model.timeSeries('Path', 2, dt=dt, # For EQ values=northridge[:,1], time = northridge[:,0]) # Load Pattern model.pattern('UniformExcitation', 2, 1, '-accel', 2) # Settings model.constraints('Plain') model.numberer('RCM') model.system('ProfileSPD') model.test('NormUnbalance', 0.0000001, 100) model.algorithm('Newton') model.integrator('Newmark', 0.5, 0.25) model.analysis('Transient') # Record some responses to plot time_lst =[] # list to hold time stations for plotting d_lst = [] # list to hold roof displacments for i in range(len(northridge)): model.analyze(1, dt) time_lst.append(model.getTime()) d_lst.append(model.nodeDisp(27,1)) Visualization Time history of the horizontal displacement of the roof is plotted here\nplt.figure(figsize=(12,4)) plt.plot(time_lst, np.array(d_lst), color = '#d62d20', linewidth=1.75) plt.ylabel('Horizontal Displacement (m)', {'fontstyle':'italic','size':14}) plt.xlabel('Time (sec)', {'fontstyle':'italic','size':14}) plt.grid() plt.yticks(fontsize = 14) plt.xticks(fontsize = 14); References Kolay, C. and Ricles, J.M., 2016. Assessment of explicit and semi‐explicit classes of model‐based algorithms for direct integration in structural dynamics. International Journal for Numerical Methods in Engineering, 107(1), pp.49-73. ","title":"Steel MRF","uri":"/opensees-gallery/examples/steelmrf_northridge/"},{"content":"From opstool\n","tags":["Python"],"title":"Suspension Bridge","uri":"/opensees-gallery/gallery/suspensionbridge/"},{"content":"This article discusses a three-dimensional effective stress site response analysis of a slope using OpenSees. The considered site consists of layered cohesionless soil underlain by bedrock. The slope has a 2% grade perpendicular to the direction of shaking. The model consists of a single column of 3D brick elements supported vertically at the base. Periodic boundary conditions are applied in both horizontal directions. A Lysmer-Kuhlemeyer (1969) dashpot is utilized to account for the finite rigidity of an underlying elastic medium, and the loading is applied in a manner consistent with that proposed by Joyner and Chen (1975).\nProvided with this article are several files. Files which are required for the analysis are indicated. The files include:\nThe example input file, freeField3D.tcl (required for analysis) The velocity time history of the selected earthquake record, yerbaNSvelocity.out (required for analysis) A GiD post-process mesh file, freeField3D.flavia.msh (generated automatically by running freeField3D.tcl) A Matlab script, flaviaWriter.m, which can be used to reformat the recorded output from OpenSees into a file which can be read by GiD for post-process visulization. Non-Matlab users may find the process represented by this file useful in creating an alternative means for accomplishing this reformatting. The post-process results file, freeField3D.flavia.res, which is generated through the use of the flaviaWriter.m script. This file, combined with the file freeField3D.flavia.msh, allows the user to visualize the results of the site response analysis using GiD. All of the files mentioned above can be downloaded here.\nTo run this example, the user must download the input file, freeField3D.tcl, and the velocity time history file, yerbaNSvelocity.out, and place them in a single directory. The additional files described above are not essential to the analysis. They are provided to demonstrate how to use the GiD tool to visualize results from this type of analysis.\nFor further information into a site response analysis using OpenSees, the user is referred to the 2D total stress site response analysis example, the 2D effective stress site response analysis example, and the set of examples developed at UCSD available here.\nModel Description Fig. 1: Schematic of 3D site response model. The site response analysis discussed in this article is for a soil profile consisting of a 10 m thick layer of loose sand (Dr = 40%) above a 20 m thick layer of more dense sand (Dr = 75%). The profile is assumed to be on an infinite slope with a 2% grade. The soil profile is the same as that described in the 2D effective stress site response example The entire soil profile is underlain by an elastic half-space which represents the finite rigidity of an underlying bedrock layer. The groundwater table is located at a depth of 2 m. Earthquake excitation is applied in the direction perpendicular to the slope.\nMesh Geometry The input file freeField3D.tcl is set-up in a manner such that the user need only define the geometry of the soil layers and groundwater table along with the number of elements (vertically) within each layer. Note: if the ground water table is not located at the surface, an additional soil layer must be included to differentiate the dry or moist soil above the gwt from the saturated soil below the gwt. The default values are for 0.5 m high elements. A single column of 8-node brick elements is created based off of the input information. The vertical direction for this column is oriented with the global y-direction, and the elements are sized equally in the global x- and z-directions. The shaking is applied in the x-direction and the slope is in the z-direction. A schematic representation of the model is shown in Fig. 1.\nBoundary Conditions The column of elements is supported vertically at the base. Periodic boundary conditions are applied in the global x- and z-directions using the equalDOF command. Dashpots are applied at the base of the column in the global x- and z-directions to simulate the underlying bedrock layer after Lysmer and Kuhlemeyer (1969). The viscous uniaxial material is used with zeroLength elements to define the dashpots. Following the method of Joyner and Chen (1975), the dashpot coefficients are defined as the product of the mass density and shear wave velocity of the underlying bedrock. Above the groundwater table, the pore pressure degrees-of-freedom are fixed to allow drainage. The pore pressure degrees-of-freedom for all nodes below the groundwater table are left free to indicate saturated undrained conditions.\nMaterial and Element Definitions The soil constitutive behavior is modeled using the PressureDependMultiYield02 nDMaterial object. The default material parameters are based upon the recommended table of parameters available on the PressureDependMultiYield02 page for the appropriate relative densities.\nNote: The mass density input values for the material objects should be total mass densities, i.e. above the groundwater table, the mass density should reflect dry or moist conditions, and below the groundwater table, the mass density should be the saturated value.\nIncluded with the material definitions for each soil layer are additional parameters which are used by the elements. These include the fluid bulk modulus, the voids ratio, the body forces, and the x-, y-, and z-direction permeabilities. For effective stress analysis, the body forces should be the components of gravity. Note the difference to total stress analysis, where body forces are typically the components of the material unit weight. The slope in this example is simulated as a static shear stress generated by applying gravity with components in the the y- and z-directions.\nThe SSPbrickUP element is used in this example. This element uses a u-p formulation to consider the coupling between the solid and fluid phases of the soil mixture. The SSPbrickUP element uses stabilized single-point integration for the solid phase, and includes direction stabilization of the fluid phase in the incompressible-impermeable limit via a stabilization parameter. This element provides a computationally-efficient alternative to a higher-order 3D u-p element such as the 20_8_BrickUP Element.\nLoading and Analysis The analysis is split in to two phases, (1) an initial gravitational phase and (2) a dynamic excitation phase. Separate recorders are generated for each phase. The gravitational analysis phase serves the purpose of developing the initial state of stress for the soil column, including the static shear stress representing the infinite slope. In the second phase of the analysis, an earthquake ground motion is applied to the base of the soil column in a manner consistent with that proposed by Joyner and Chen (1975). The motion is applied in the horizontal direction perpendicular to the slope (x-direction).\nDuring the gravitational analysis, the permeability in each direction is set at 1.0 m/s to facilitate development of hydrostatic conditions. After completion of this analysis phase, the permeabilities are updated to their input values using the setParameter command.\nResults Fig. 2: Displacements in direction of shaking (u) and direction of slope (w) with pore pressure ratio in middle of liquefied soil. Several sets of results are presents to demonstrate the types of results which can be obtained from this type of analysis in OpenSees and to allow the user to confirm proper download and implementation of the example input files. Post-processing for the included plots was accomplished using Matlab and GiD. Refer to the following section of this article for further information on post-processing with GiD.\nFig. 2 shows the displacement at the top of the soil column (ground surface) in the direction of shaking and the direction of the slope along with the pore pressure ratio in the middle of the liquefiable soil. The slope is initially stable, then loses stability and begins move in the down-slope direction. As shown in Fig. 2, this loss of stability is due to liquefaction in the saturated loose sand layer. If the analysis is continued past the end of the applied ground motion, the pore pressures will eventually dissipate and the slope will become stable as the liquefied soil regains strength.\nFig. 3 shows how the down-slope displacement increases during the application of the ground motion, and how this displacement correlates with the reduced strength of the liquefiable soil as indicated by pore pressure ratio. As shown, the down-slope displacement increases as the pore pressure ratio approaches 1.0, then continues to increase after this point. The displacements in this figure are magnified for clarity. \u003cbr style=\"clear: both\" /\u003e\n\u003cbr style=\"clear: both\" /\u003e\nGiD Visualization Several files have been included in this article for the purpose of visualizing results in the pre- and post-processing tool GiD. The files related to this purpose are available for download here. The files are:\nfreeField3D.flavia.msh freeField3D.flavia.res flaviaWriter.m The file freeField3D.flavia.msh contains a list of the nodes and elements used in the analysis in a format that GiD understands. This file is automatically created by running the example freeField3D.tcl in OpenSees. The file freeField3D.flavia.res contains the data recorded during the analysis by the OpenSees recorders in a format that GiD can read. The Matlab script, flaviaWriter.m, converts the data recorded by OpenSees into this format. Further information on the formats for the *.flavia.msh and *.flavia.res files can be found in the GiD customization manual available here.\nTo visualize the results in GiD, the user should take the following steps:\ndownload and install copy of GiD save a blank project with the name freeField3D.gid place the files freeField3D.flavia.msh and freeField3D.flavia.res into the freeField3D.gid directory with this project open, select the Postprocess option in the 'files' menu The program will then load the post-processing data contained in freeField3D.flavia.msh and freeField3D.flavia.res.\nReferences Joyner, W.B. and Chen A.T.F. (1975) \"Calculation of nonlinear ground response in earthquakes,\" Bulletin of the Seismological Society of America, 65(5), 1315-1336. Kramer, S.L. (1996). Geotechnical Earthquake Engineering. Prentice Hall, Upper Saddle River, NJ. Lysmer, J. and Kuhlemeyer, A.M. (1969). \"Finite dynamic model for infinite media,\" Journal of the Engineering Mechanics Division, ASCE, 95, 859-877. Return to OpenSees Examples Page\nExample prepared by: Christopher McGann and Pedro Arduino, University of Washington\n","title":"Three-Dimensional Site Response Analysis of Sloping Ground","uri":"/opensees-gallery/community/siteresponse3d/"},{"content":"","title":"TODO","uri":"/opensees-gallery/examples/structuralmatrices/"},{"content":"This command is used to construct a YamamotoBiaxialHDR element object, which is defined by two nodes. This element can be used to represent the isotropic behavior of high-damping rubber bearing in the local y-z plane.\nelement YamamotoBiaxialHDR $eleTag $iNode $jNode $Tp $DDo $DDi $Hr \u0026lt;-coRS $cr $cs\u0026gt; \u0026lt;-orient \u0026lt;$x1 $x2 $x3\u0026gt; $y1 $y2 $y3\u0026gt; \u0026lt;-mass $m\u0026gt; eleTag unique element object tag\ninode jnode\nend nodes\nTp compound type\n= 1 : X0.6R manufactured by Bridgestone corporation.\nDDo outer diameter [m]\nDDi bore diameter [m]\nHr total thickness of rubber layer [m]\nOptional Data\ncr cs\ncoefficients for shear stress components of $\\tau_{r}$ and \u003cmath\u003e\\tau_{s}\u003c/math\u003e\nx1 x2 x3\nvector components in global coordinates defining local x-axis\nyp1 yp2 yp3\nvector components in global coordinates defining vector yp which lies in the local x-y plane for the element\nm element mass [kg]\nNOTES:\n1) The valid queries to a YamamotoBiaxialHDR element when creating an ElementRecorder object are 'globalForce', 'localForce', 'basicForce', 'localDisplacement' and 'basicDeformation'.\nYamamotoBiaxialHDR_Model.png Examples element YamamotoBiaxialHDR 1 1 2 1 1.300 0.030 0.261 -orient 0 0 1 1 0 0\nYamamotoBiaxialHDR_Sample.tcl YamamotoBiaxialHDR_input_X.tcl YamamotoBiaxialHDR_input_Y.tcl             References Masashi Yamamoto, Shigeo Minewaki, Harumi Yoneda and Masahiko Higashino, \"Nonlinear behavior of high-damping rubber bearings under horizontal bidirectional loading: full-scale tests and analytical modeling\", Earthquake Engineering and Structural Dynamics, 41, 1845-1860, 2012.\nCode Developed by: mkiku ","title":"YamamotoBiaxialHDR","uri":"/opensees-gallery/community/yamamotobiaxialhdr/"},{"content":"Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 from math import cos,sin,sqrt,pi import opensees.openseespy as ops # ZeroLength5.tcl # CE 221 Spring 1999 Midterm Problem # # Written: MHS # Date: Jan 2000 # # |A B # |@--------@------------ # | 4 6 ^ def rotSpring2D(model, eleID, nodeR, nodeC, matID): # Procedure which creates a rotational spring for a planar problem # rotSpring2D.tcl # SETS A MULTIPOINT CONSTRAINT ON THE TRANSLATIONAL DEGREES OF FREEDOM, # SO DO NOT USE THIS PROCEDURE IF THERE ARE TRANSLATIONAL ZEROLENGTH # ELEMENTS ALSO BEING USED BETWEEN THESE TWO NODES # # Written: MHS # Date: Jan 2000 # # Formal arguments # eleID - unique element ID for this zero length rotational spring # nodeR - node ID which will be retained by the multi-point constraint # nodeC - node ID which will be constrained by the multi-point constraint # matID - material ID which represents the moment-rotation relationship # for the spring model.element('zeroLength', eleID, nodeR, nodeC, mat=matID, dir=6) model.equalDOF(nodeR, nodeC, 1, 2) # Define the model builder model = ops.Model(ndm=2, ndf=3) # Define nodes model.node(1, 0.0, 0.0) model.node(2, 0.0, 0.0) model.node(3, 4.0, 0.0) model.node(4, 4.0, 0.0) model.node(5, 10.0, 0.0) # Define single point constraints model.fix(1, 1, 1, 1) model.fix(5, 1, 1, 0) # Define moment-rotation relationship for spring A model.uniaxialMaterial('ElasticPP', 1, 10, 0.8) # Define moment-rotation relationship for spring B model.uniaxialMaterial('ElasticPP', 3, 6, 1.0) model.uniaxialMaterial('Elastic', 4, 4) model.uniaxialMaterial('Parallel', 2, 3, 4) # Geometric transformation model.geomTransf('Linear', 1) # Define beam elements model.element('elasticBeamColumn', 3, 2, 3, 100, 1000, 1000, 1) model.element('elasticBeamColumn', 4, 4, 5, 100, 1000, 1000, 1) # eleID nodeR nodeC matID rotSpring2D(model, 1 , 1, 2 , 1) rotSpring2D(model, 2 , 3, 4 , 2) model.pattern('Plain', 1, \"Linear\", \"{load 3 0.0 10.0 0.0}\") model.integrator('LoadControl', 1, 1, 1, 1) model.test('NormDispIncr', 1.0e-8, 10, 1) model.numberer('Plain') model.algorithm('KrylovNewton', maxDim=3) model.constraints('Penalty', 1.0e12, 1.0e12) model.system('UmfPack') model.analysis('Static') model.analyze(1) model.print( 'algorithm') model.print( 'node', 4) Tcl 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 # ZeroLength5.tcl # CE 221 Spring 1999 Midterm Problem #1 # # Written: MHS # Date: Jan 2000 # # |A B # |@--------@------------ # | 4 6 ^ # Define the model builder model BasicBuilder -ndm 2 -ndf 3 # Define nodes node 1 0.0 0.0 node 2 0.0 0.0 node 3 4.0 0.0 node 4 4.0 0.0 node 5 10.0 0.0 # Define single point constraints fix 1 1 1 1 fix 5 1 1 0 # Define moment-rotation relationship for spring A uniaxialMaterial ElasticPP 1 10 0.8 # Define moment-rotation relationship for spring B uniaxialMaterial ElasticPP 3 6 1.0 uniaxialMaterial Elastic 4 4 uniaxialMaterial Parallel 2 3 4 # Geometric transformation geomTransf Linear 1 # Define beam elements element elasticBeamColumn 3 2 3 100 1000 1000 1 element elasticBeamColumn 4 4 5 100 1000 1000 1 source rotSpring2D.tcl # eleID nodeR nodeC matID rotSpring2D 1 1 2 1 rotSpring2D 2 3 4 2 pattern Plain 1 Linear { load 3 0.0 10.0 0.0 } integrator LoadControl 1 1 1 1 test NormDispIncr 1.0e-8 10 1 numberer Plain algorithm KrylovNewton -maxDim 3 constraints Penalty 1.0e12 1.0e12 system UmfPack analysis Static analyze 1 print algorithm print node 4 ","tags":["Python","Tcl"],"title":"Zero-Length Elements","uri":"/opensees-gallery/examples/zerolength/"}]
